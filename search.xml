<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hexo-theme</title>
      <link href="/2019/08/02/hexo-theme/"/>
      <url>/2019/08/02/hexo-theme/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>npm &amp;&amp; yarn 差异以及常用命令</title>
      <link href="/2019/07/01/npm&amp;&amp;yarn/"/>
      <url>/2019/07/01/npm&amp;&amp;yarn/</url>
      <content type="html"><![CDATA[<p>yarn 从去年vue-cli更新以来一直用，但一直都没认真了解过</p><h2 id="yarn-背景介绍"><a href="#yarn-背景介绍" class="headerlink" title="yarn 背景介绍"></a>yarn 背景介绍</h2><p>安装方法 <a href="https://yarn.bootcss.com/docs/install" target="_blank" rel="noopener">三种安装方式</a><br>Yarn 是一个包管理器，代码通过包（package） 或者模块（module）的方式来共享， 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。</p><h2 id="yarn-npm-差异"><a href="#yarn-npm-差异" class="headerlink" title="yarn npm 差异"></a>yarn npm 差异</h2><ul><li>同步安装：npm 是按照队列执行每个 package，Yarn 是同步执行所有任务</li><li>离线模式：Yarn可以从缓存中获取以前安装过的安装包，而npm每次都从网络下载</li><li>安装版本统一：yarn.lock 文件记录了所有安装模块的版本号，这样使我们每次拉取同一个项目依赖时使用都是一样的版本号，而 npm 需要执行 npm shrinkwrap 才会生成一个锁定文件 npm-shrinkwrap.json</li><li>npm 输出内容多长，安装慢就算了还老是失败，相较而言 yarn 真的快多了</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>更多命令 <a href="https://yarn.bootcss.com/docs/cli/" target="_blank" rel="noopener">官网 CLI 命令</a></p><table><thead><tr><th style="text-align:center"><strong>npm 命令</strong></th><th style="text-align:center"><strong>yarn 命令</strong></th><th style="text-align:center"><strong>命令介绍</strong></th></tr></thead><tbody><tr><td style="text-align:center">npm install xxx  <br>  npm i xxx</td><td style="text-align:center">yarn</td><td style="text-align:center">安装但不写入package.json</td></tr><tr><td style="text-align:center">npm install –save xxx  <br>  npm i -s xxx</td><td style="text-align:center">yarn add xxx</td><td style="text-align:center">安装xxx模块，并且记录到package.json字段对应的dependency</td></tr><tr><td style="text-align:center">npm install –save-dev xxx  <br>  npm i -D xxx</td><td style="text-align:center">yarn add xxx –dev</td><td style="text-align:center">安装xxx模块，并且记录到package.jso字段对应的dev-dependency是开发环境必须依赖的模块</td></tr><tr><td style="text-align:center">npm install –global xxx  <br>  npm i -g xxx</td><td style="text-align:center">yarn global add xxx</td><td style="text-align:center">全局安装xxx模块，如果模块里package.json有bin配置，会自动链接，作为cli命令</td></tr><tr><td style="text-align:center">npm uninstall react –save</td><td style="text-align:center">yarn remove taco</td><td style="text-align:center">安装并记录package.json中的dependency字段</td></tr><tr><td style="text-align:center">npm update –save</td><td style="text-align:center">yarn upgrade</td><td style="text-align:center">更新并记录package.json中的dependency字段</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://yarn.bootcss.com" target="_blank" rel="noopener">官网命令</a><br><a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">知乎文章：npm和yarn的区别，我们该如何选择？</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>理解浏览器缓存机制</title>
      <link href="/2019/05/14/browser_cache/"/>
      <url>/2019/05/14/browser_cache/</url>
      <content type="html"><![CDATA[<p>有关浏览器缓存的几个疑问</p><ul><li>浏览器缓存判断流程？</li><li>两种分类协商缓存和强制缓存是什么？怎么判断？</li><li>缓存的资源放在哪儿？</li><li>不同的刷新对缓存的影响？</li></ul><h2 id="浏览器缓存的流程"><a href="#浏览器缓存的流程" class="headerlink" title="浏览器缓存的流程"></a>浏览器缓存的流程</h2><p>当客户端请求某个资源，首先需要询问浏览器是否存在缓存<br>有以下三种结果：</p><ul><li>不存在，那么直接向服务器发起请求，就像第一次访问该网站一样</li><li>存在，通过Cache-Control、Expires判断后缓存已失效，那么则使用协商缓存，携带该资源缓存标识向服务器发起请求，服务器根据 http header 判断后决定是否使用缓存，若协商缓存失效重新拉取请求结果则状态码为 200 ，若协商缓存生效那么继续使用缓存状态码为 304</li><li>存在，通过Cache-Control、Expires判断后未失效，那么继续使用缓存状态码为 304</li></ul><p>图示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  浏览器发起请求</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">    是否有缓存 ——— 是 ——— 缓存是否失效 ——— 是 ——— 协商缓存 ———— 成功</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        否                    否                  失败          |</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        |—————————————————————|————————————————————|           |</span><br><span class="line">        |                     |                                |</span><br><span class="line">  向服务器请求资源           读取缓存————————————————————————————|</span><br><span class="line">        |                     |</span><br><span class="line">        |                     |</span><br><span class="line">根据 http header 存缓存        |</span><br><span class="line">        |                     |</span><br><span class="line">        |—————————————————————|</span><br><span class="line">        |</span><br><span class="line">     完成加载</span><br></pre></td></tr></table></figure><p>所以有两种缓存类型，强制缓存和协商缓存，优先判断的不需要发 http 请求的是强制缓存<br>当强制缓存无效时才启用协商缓存，协商缓存需要发送 http 请求交由服务器判断，可以应用于一些时常需要动态更新的资源文件</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>浏览器判断强制缓存是否存在和是否失效这两个：Cache-Control、Expires</p><ul><li>Cache-Control *</li></ul><p>http/1.1的字段，控制网页缓存的主要规则，取值：</p><ul><li>public： 所有内容都将被缓存</li><li>private：默认值，所有内容只有客户端可以缓存， CDN 等中继缓存服务器不能缓存</li><li>no-cache：客户端缓存内容，但由协商缓存决定是否使用缓存</li><li>no-store：所有内容都不会被缓存</li><li>max-ag=xxx：缓存内容在xxx秒后失效</li><li>max-stale=xxx: 指定时间内，即使缓存过时依然使用资源</li><li>min-fresh=xxx：缓存的资源至上要保持指定时间的新鲜期</li><li>only-if-cached：仅仅返回已经缓存的资源，不访问网络，无缓存返回 504</li><li><p>no-transform：强制要求代理服务器不要对资源进行转换，禁止代理服务器对 Content-Type、Content-Encoding, Content-Range 字段进行修改</p></li><li><p>Expires *</p></li></ul><p>http/1.0 的字段，请求结果缓存到期时间，优先级低于 Cache-Control:max-age<br>由于 Expires 设置的时绝对时间<br>若 Expires 和 Cache-Control:max-age 两者都没出现浏览器默认使用启发式算法：响应头的（ Date - Last - Modified ）<em> 10，也就是（响应时间 - 文件最后修改时间 ）</em> 10</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>Etag / If-None-Match 优先级高于Last-Modified / If-Modfied-Since，同时存在前者生效</p><ul><li><p>Last-Modified / If-Modified-Since / If-Unmodified-since *</p></li><li><p>Last-Modified 是服务器响应请求时返回该资源在服务器的最后修改时间</p></li><li>If-Modified-Since 是客户端再次发起请求时携带上次服务器返回的Last-Modified, 服务器接收到这个时间将与该资源在服务器最后修改的时间进行对比，若服务器修改的时间大于客户端发送的时间，则状态码200重新返回资源，否则返回304表示资源无更新继续使用缓存</li><li><p>If-Unmodified-since 同上，资源未修改正常执行更新反之返回412</p></li><li><p>Etag / If-None-Match *</p></li><li><p>Etag 是资源唯一标识符，服务器响应请求时返回当前资源的唯一标识符</p></li><li>If-None-Match 是客户端再次发起该请求时携带上次请求时服务器返回的唯一标识符 Etag，服务器接收到该值会与该资源在服务器的 Etag 值做对比，一致状态码 304 表示无更新继续使用缓存，反之则返回资源文件状态码 200</li></ul><h2 id="缓存的资源在哪儿？"><a href="#缓存的资源在哪儿？" class="headerlink" title="缓存的资源在哪儿？"></a>缓存的资源在哪儿？</h2><p>浏览器通过 http 请求获取到资源，那么资源会缓存在哪儿</p><p>memory cache：内存缓存，会将编译解析的文件，直接存入该进程内存中，占据一定的内存资源，以便下次快速读取，进程关闭即清空</p><p>from disk cache：硬盘缓存，盘缓存是将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行i/o操作，然后解析读取，速度比内存缓存慢</p><p>浏览器读取缓存时 memory ——&gt; disk ——&gt; 两者都没有便发起网络请求 ——&gt; 获取资源缓存到硬盘和内存</p><p>在浏览器中，css 文件会存入硬盘文件中，因为 css 文件通常只在页面渲染时加载一次，<br>而 js 和图片等文件解析执行后直接存入内存缓存中，是因为可能会频繁读取，当刷新页面时只需直接从内存缓存中读取</p><h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><ul><li>刷新网页，如果缓存没有失效，浏览器直接使用缓存，反之 http 请求数据</li><li>手动刷新 / F5，浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新</li><li>强制刷新 / Ctrl + F5，浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>其他和缓存相关的 header 头部 *</p></li><li><p>date 响应生成时间</p></li><li>age 代理服务器生成，表示代理服务器对于请求资源的已缓存时间, 单位为秒</li><li>Pragma：no-cache: http / 1.0 作用和 Cache-Control:no-cache 一样，如果在控制台勾选 Disable cache, 浏览器自动带上该字段</li><li><p>vary 缓存版本，可用于区分 pc 和 移动端需要加载的资源</p></li><li><p>浏览器禁用缓存 *</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache, no-store, must-revalidate"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">浏览器的缓存机制小结</a><br><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a><br>[]</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>canvas 文字粒子特效</title>
      <link href="/2019/04/23/canvas-fontparticle/"/>
      <url>/2019/04/23/canvas-fontparticle/</url>
      <content type="html"><![CDATA[<p>一个文字粒子效果,折腾了一些时间，纯粹觉得好玩 <a href="https://tong-h.github.io/canvas-store/fontparticle/index.html" target="_blank" rel="noopener">点这里看效果</a></p><h2 id="随机初始化部分粒子"><a href="#随机初始化部分粒子" class="headerlink" title="随机初始化部分粒子"></a>随机初始化部分粒子</h2><p>1、首先要明白每个粒子都是一个对象，都有自己的移动轨迹，起点，移动速度，终点</p><p>2、粒子活动轨迹：初始化 —- 聚合拼合文字形状 —- 散开 —- 再聚合 —- 散开…</p><p>3、我们需要根据动画时间调整粒子移动的速度来安排他们的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.startx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * docsize[<span class="number">0</span>]),   <span class="comment">// 初始起点</span></span><br><span class="line">        <span class="keyword">this</span>.starty = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * docsize[<span class="number">1</span>]),</span><br><span class="line">        <span class="keyword">this</span>.speedx = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed,     <span class="comment">// 移动速度</span></span><br><span class="line">        <span class="keyword">this</span>.speedy = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed, </span><br><span class="line">        <span class="keyword">this</span>.endx = <span class="number">0</span>,                                          <span class="comment">// 终点</span></span><br><span class="line">        <span class="keyword">this</span>.endy = <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>)              <span class="comment">// 粒子颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    endpoint(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.endx = x</span><br><span class="line">        <span class="keyword">this</span>.endy = y</span><br><span class="line">    &#125;</span><br><span class="line">    animal() &#123;</span><br><span class="line">        <span class="keyword">this</span>.startx += <span class="keyword">this</span>.speedx</span><br><span class="line">        <span class="keyword">this</span>.starty += <span class="keyword">this</span>.speedy</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达边界改变粒子运动方向</span></span><br><span class="line">        <span class="keyword">this</span>.speedx *= <span class="keyword">this</span>.startx &gt; docsize[<span class="number">0</span>] || <span class="keyword">this</span>.startx &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.speedy *= <span class="keyword">this</span>.starty &gt; docsize[<span class="number">1</span>] || <span class="keyword">this</span>.starty &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整点的移动速度用以聚和拼合文字</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">100</span> || time === <span class="number">600</span> || time === <span class="number">1100</span>) &#123; </span><br><span class="line">            <span class="keyword">this</span>.speedx = (<span class="keyword">this</span>.endx - <span class="keyword">this</span>.startx) / joinspeed</span><br><span class="line">            <span class="keyword">this</span>.speedy = (<span class="keyword">this</span>.endy - <span class="keyword">this</span>.starty) / joinspeed</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达终点后静止不动</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">100</span> + joinspeed || time === <span class="number">600</span> + joinspeed || time === <span class="number">1100</span> + joinspeed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.speedx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">this</span>.speedy = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 散开</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">300</span> || time === <span class="number">800</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.speedx = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed</span><br><span class="line">            <span class="keyword">this</span>.speedy = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maincontent.beginPath()</span><br><span class="line">        maincontent.fillStyle = color[<span class="keyword">this</span>.color]</span><br><span class="line">        maincontent.arc(<span class="keyword">this</span>.startx, <span class="keyword">this</span>.starty, <span class="number">7</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>)</span><br><span class="line">        maincontent.fill()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-canvas-画板生成文字"><a href="#使用-canvas-画板生成文字" class="headerlink" title="使用 canvas 画板生成文字"></a>使用 canvas 画板生成文字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【文字面积，循环时用于判读y轴高度，粒子大小间隔， 文字宽度】</span></span><br><span class="line"><span class="keyword">let</span> [imgdata, cyclic, size, textwith] = [&#123;&#125;, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">textcontext.font = <span class="string">"normal 900 "</span> + fontsize +<span class="string">"px Avenir, Helvetica Neue, Helvetica, Arial, sans-serif"</span></span><br><span class="line">textwith = <span class="built_in">Math</span>.floor(textcontext.measureText(text).width)</span><br><span class="line">textcontext.fillStyle = <span class="string">'#ff0000'</span></span><br><span class="line">textcontext.fillText(text, (docsize[<span class="number">0</span>] - textwith) / <span class="number">2</span>, (docsize[<span class="number">1</span>]) / <span class="number">2</span>)</span><br><span class="line">textwith = ~~ (textwith) * size + size</span><br></pre></td></tr></table></figure><h2 id="遍历-imageData-获取文字区域的像素坐标"><a href="#遍历-imageData-获取文字区域的像素坐标" class="headerlink" title="遍历 imageData 获取文字区域的像素坐标"></a>遍历 imageData 获取文字区域的像素坐标</h2><p>不了解 imagedata 怎么用？ 看看这篇文章<a href="https://tong-h.github.io/2019/02/21/canvas-1/#more" target="_blank" rel="noopener">cannvas的imagedata对象</a></p><p>获取坐标这里有很多种方法，我看了一些教程好像没人像我这么写，要注意的是</p><ul><li>imageData 4个元素为一个像素，也就是一个R G B A 值，A 是 alpha 透明度</li><li>空白的区域rgba就是 0,0,0,0 , 文字区域就是有颜色的如果你没有设置字体颜色默认是黑色 rgba 就是 0,0,0,255，通过判断第四个元素可以获取文字区域</li><li>但是我建议重新设置一个其他的颜色比如红色 255,0,0,255，用第1个和2个数字来判断这样字体边缘会圆滑些，因为在字体边缘黑色和白色的交界处可能有某几个像素不是透明的</li><li>每个坐标最后都会生成一个圆，所以这里获取的是圆心的坐标，圆之间还需要留有空隙，所以遍历的时候你要根据你的圆的大小掌握好间隔</li><li>获取文字区域粒子数量后需要判断，目前屏幕上现有的粒子是否足够拼合和文字或者是否还需再添加粒子</li><li>确定粒子数量后再将文字坐标作为粒子移动终点赋值给粒子</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文字所在区域，尽可能减小面积</span></span><br><span class="line">imgdata = textcontext.getImageData(<span class="number">0</span>,<span class="number">0</span>, textwith, fontsize * <span class="number">2</span>)</span><br><span class="line">textcontext.clearRect(<span class="number">0</span>, <span class="number">0</span>, docsize[<span class="number">0</span>], docsize[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粒子圆心坐标，粒子数组</span></span><br><span class="line"><span class="keyword">let</span> [x, y, len] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历data数据查找文字所在的坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgdata.data.length; i += size * <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (imgdata.data[i] === <span class="number">255</span> &amp;&amp; imgdata.data[i+<span class="number">3</span>] === <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前粒子数量是否能够拼合文字</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; pointarr.length - <span class="number">1</span>) pointarr.push(<span class="keyword">new</span> Point)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每个粒子聚拢的终点</span></span><br><span class="line">        pointarr[len].endpoint(i /<span class="number">4</span> % textwith, cyclic)</span><br><span class="line">        len ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i/<span class="number">4</span> == cyclic * textwith) &#123;</span><br><span class="line">        cyclic += size</span><br><span class="line">        i = textwith * (cyclic<span class="number">-1</span>) * <span class="number">4</span></span><br><span class="line">    &#125;·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pointarr.length - <span class="number">1</span> - len &gt; <span class="number">0</span> ? pointarr.splice(len, pointarr.length - len) : <span class="string">''</span></span><br></pre></td></tr></table></figure><h2 id="源码带有详细的注解点这儿"><a href="#源码带有详细的注解点这儿" class="headerlink" title="源码带有详细的注解点这儿"></a>源码带有详细的注解<a href="https://tong-h.github.io/canvas-store/roundPercent/index.html" target="_blank" rel="noopener">点这儿</a></h2><p><a href="https://github.com/Tong-H/canvas-store" target="_blank" rel="noopener">更多效果</a><br>开源不易，觉得还不错点个 start 吧 (´▽`ʃ♡ƪ)</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Web Worker &amp;&amp; postMessage &amp;&amp; onMessage 使用教程</title>
      <link href="/2019/04/21/webworker/"/>
      <url>/2019/04/21/webworker/</url>
      <content type="html"><![CDATA[<p>最近使用 iframe 的时候想要获取 iframe 文档信息的时候遇到了跨域问题，最后使用 postmessage 做父子页面通信解决需求也顺便学习了下 webworker 的使用<br>webWoker 使用依赖 postMessage() 和 onMessage(), 所以先说这两个吧</p><h1 id="postMessage-amp-amp-onMessage"><a href="#postMessage-amp-amp-onMessage" class="headerlink" title="postMessage &amp;&amp; onMessage"></a>postMessage &amp;&amp; onMessage</h1><ul><li>提供网页文档之间互相发送和接收信息的功能，可用于解决跨域访问的问题</li><li>会在所有页面脚本执行完毕之后(包括方法之后或者之前设置的timeout 事件)再执行</li><li>挂载于window对象上</li></ul><h2 id="postMessage-语法：-otherWindow-postMessage-message-targetOrigin-transfer"><a href="#postMessage-语法：-otherWindow-postMessage-message-targetOrigin-transfer" class="headerlink" title="postMessage 语法： otherWindow.postMessage(message, targetOrigin, [transfer]);"></a>postMessage 语法： otherWindow.postMessage(message, targetOrigin, [transfer]);</h2><p>&emsp;&emsp;message: 发送的数据，不限类型，因为他自己会序列化<br>&emsp;&emsp;targetOrigin：通过窗口的origin属性指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI<br>&emsp;&emsp;transfer：可选参数；一个 Transferable 对象([什么是Transferable[(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable))，和message" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable))，和message</a> 同时传递的,对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</p><h2 id="onMessage-语法："><a href="#onMessage-语法：" class="headerlink" title="onMessage 语法："></a>onMessage 语法：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; ... &#125;)</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="获取到的-event-对象包含"><a href="#获取到的-event-对象包含" class="headerlink" title="获取到的 event 对象包含"></a>获取到的 event 对象包含</h2><p>&emsp;&emsp;data：接收的数据对象，对应 postMessage 的 message 参数<br>&emsp;&emsp;origin：消息发送方窗口的 origin，字符串由 协议、“://“、域名、“ : 端口号”拼接而成<br>&emsp;&emsp;source：对发送消息的窗口对象的引用</p><h2 id="举个小栗子"><a href="#举个小栗子" class="headerlink" title="举个小栗子"></a>举个小栗子</h2><ul><li><p>父页面向子页面传值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在 iframe 加载完毕后，获取 iframe 的 window 对象，调用 postMessage 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="javascript">        frame.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            frame.contentWindow.postMessage(&#123; <span class="attr">name</span>: <span class="string">'a page'</span> &#125;,<span class="string">'*'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子页面监听 message 事件设置回调打印 event</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>b page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (event) =&gt; <span class="built_in">console</span>.log(<span class="string">'this b page'</span>, event), <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子页面向父页面传值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父页面监听 message 事件设置回调打印 event</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (event) =&gt; <span class="built_in">console</span>.log(<span class="string">'this a page'</span>, event), <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 使用 parent 获取 window 对象，调用 postMessage 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>b page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(parent)</span></span><br><span class="line"><span class="javascript">        parent.postMessage( &#123;<span class="attr">name</span>: <span class="string">'b page'</span>&#125;, <span class="string">'*'</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Workers"><a href="#Workers" class="headerlink" title="Workers"></a>Workers</h1><ul><li>我自己感觉很多比较麻烦耗内存的js逻辑操作都可以放在worker里，比如轮询服务器状态或者一些很耗时量很大的数据操作用</li><li>让脚本在浏览器后台线程中运行</li><li>在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" target="_blank" rel="noopener">window对象下可用的方法</a></li><li>worker 中也能再创建 worker</li><li>由于安全限制 Worker 不能读取本地文件，所以脚本必须来自网络，读取本地文件会报错 “Uncaught SecurityError: Failed to create a worker: script at ‘(path)/worker.js’ cannot be accessed from origin ‘null’.”</li><li>关于<a href="https://caniuse.com/#search=webworker" target="_blank" rel="noopener">兼容性</a></li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在使用 worker 的 js文件里<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Worker() 指定脚本 url 创建一个新的 worker</span></span><br><span class="line"><span class="comment">// 参数就是 Worker 线程所要执行的任务</span></span><br><span class="line"><span class="comment">// Worker 使用 postMessage 和 onMessage 进行通信</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">"worker.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 postMessage() 和 onMessage() 发送和接收数据</span></span><br><span class="line">myWorker.postMessage(<span class="string">"request"</span>);</span><br></pre></td></tr></table></figure></p><p>在 worker.js文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息响应</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  <span class="built_in">console</span>.log(self)</span><br><span class="line">  <span class="comment">// 消息回传</span></span><br><span class="line">  postMessage(workerResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关闭-错误-加载脚本"><a href="#关闭-错误-加载脚本" class="headerlink" title="关闭/错误/加载脚本"></a>关闭/错误/加载脚本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 文件中，强制终止</span></span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 worker 线程中，自己关闭</span></span><br><span class="line">self.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 错误代理</span></span><br><span class="line">worker.onerror(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送的数据无法序列化成字符串时，会触发这个事件</span></span><br><span class="line">Worker.onmessageerror(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 使用 importScripts() 加载脚本，可以加载多个</span></span><br><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'script2.js'</span>);</span><br></pre></td></tr></table></figure><h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h2><p>如果你现在没有条件加载网络上的文件，可以使用 URL.createObjectURL 方法建立缓存 URL<br>可以试着运行一下面两个页面感受一下</p><p>可以运行一下这个页面，一个普通的 for 循环，因为数字太大运行时会有明显的卡顿<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Web worker<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> num=<span class="number">99</span>;num&lt;<span class="number">1000000000</span>;num++)&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"numshow"</span>).innerHTML += event.data+<span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"numshow"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个可以使用 URL.createObjectURL 方法建立缓存 URL<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Web worker<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">5</span>);</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">"("</span> + webWorker.toString() + <span class="string">")()"</span>], &#123;<span class="attr">type</span>: <span class="string">'text/javascript'</span>&#125;)));</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        worker.onmessage= <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">// 数据打印</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"numshow"</span>).innerHTML += event.data+<span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 向 worker 线程发送数据</span></span></span><br><span class="line"><span class="javascript">            event.data === <span class="number">1</span> ? worker.postMessage(<span class="string">'num'</span>):<span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;; </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">webWorker</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// worker 对象 self</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(self)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 接收来自主线程的数据</span></span></span><br><span class="line"><span class="javascript">        self.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> num = <span class="number">1</span>; num &lt; <span class="number">1000000000</span>; num++) &#123; </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 当 num === 200的时候关闭 worker 线程</span></span></span><br><span class="line"><span class="javascript">            num === <span class="number">200</span> ? (postMessage(<span class="string">"worker关闭"</span>), close()) : postMessage(num**<span class="number">2</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"numshow"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>postMessage：MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a><br>webworker：MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a><br>阮一峰：<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>typescript 学习之基础篇</title>
      <link href="/2019/03/25/ts-1/"/>
      <url>/2019/03/25/ts-1/</url>
      <content type="html"><![CDATA[<p>vue-cli已经内置了 TypeScript 工具支持，在 Vue  (3.x) 中也计划了相当多的 TypeScript 支持改进，很多大佬以及用过的人也都在推荐入坑，而且目前也比较成熟，资源也很丰富，值得入坑</p><h1 id="typescript"><a href="#typescript" class="headerlink" title="? typescript"></a>? typescript</h1><p>官方介绍 TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上<br>我的理解是 TypeScript扩展了JavaScript的语法，为 js 增加了类型机制，引入类，接口，枚举，泛型，方法重载等一系列的概念和方法，丰富了js的使用，而且和 VScode 搭配写起来是真的舒服</p><p>全局安装：npm install -g typescript<br>编译命令：tsc hello.ts</p><p>TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀<br>在报错的时候终止 js 文件的生成，在 tsconfig.json 中配置 noEmitOnError </p><h1 id="原始数据类型声明"><a href="#原始数据类型声明" class="headerlink" title="原始数据类型声明"></a>原始数据类型声明</h1><p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>在ts中变量声明，变量或者参数都必须要声明其类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> createdByBoolean: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">'string'</span></span><br><span class="line"><span class="comment">// ` 用来定义 ES6 中的模板字符串，$&#123;expr&#125; 用来在模板字符串中嵌入表达式</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.I'll be <span class="subst">$&#123;myAge + 1&#125;</span> years old next month.`</span>; </span><br><span class="line"></span><br><span class="line">Null 和 Undefined 和 <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>; <span class="comment">// void只能赋值为 undefined 和 null</span></span><br></pre></td></tr></table></figure></p><h1 id="内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量"><a href="#内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量" class="headerlink" title="内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量"></a>内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量</h1><p>这些内置对象的定义文件可以在<a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>查找</p><p>ECMAScript 标准的内置对象比如Boolean、Date、RegExp等，更多内置对象<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN</a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure></p><p>DOM 和 BOM 的内置对象比如Document、HTMLElement、Event、NodeList等<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="赋值多个类型"><a href="#赋值多个类型" class="headerlink" title="赋值多个类型"></a>赋值多个类型</h1><h2 id="任意类型-any：表示允许赋值为任意类型，且能在赋值过程中改变类型"><a href="#任意类型-any：表示允许赋值为任意类型，且能在赋值过程中改变类型" class="headerlink" title="任意类型 any：表示允许赋值为任意类型，且能在赋值过程中改变类型"></a>任意类型 <code>any</code>：表示允许赋值为任意类型，且能在赋值过程中改变类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>变量声明，赋值但未指定其类型，TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'7'</span> <span class="comment">// TypeScript会推断为string类型</span></span><br><span class="line">a = <span class="number">7</span>  <span class="comment">// 这个赋值会导致报错</span></span><br></pre></td></tr></table></figure></p><p>变量声明，未赋值未指定其类型，会被推断成 <code>any</code>类型而完全不被类型检查<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a    <span class="comment">// any 类型</span></span><br><span class="line">a = <span class="string">'7'</span></span><br><span class="line">a = <span class="number">7</span></span><br></pre></td></tr></table></figure></p><h2 id="联合类型：可以指定多种类型，可赋值为其中一种，使用-分隔每个类型"><a href="#联合类型：可以指定多种类型，可赋值为其中一种，使用-分隔每个类型" class="headerlink" title="联合类型：可以指定多种类型，可赋值为其中一种，使用 |` 分隔每个类型"></a>联合类型：可以指定多种类型，可赋值为其中一种，使用 |` 分隔每个类型</h2><p>示例<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 指定类型为 string 和 number</span></span><br><span class="line">a = <span class="string">'7'</span>; <span class="comment">// 类型推断为 number</span></span><br><span class="line">a = <span class="number">7</span>; <span class="comment">// 类型推断为 string</span></span><br><span class="line">a = <span class="literal">true</span>; <span class="comment">// 类型推断为 boolean 报错</span></span><br></pre></td></tr></table></figure></p><h1 id="使用接口定义对象类型"><a href="#使用接口定义对象类型" class="headerlink" title="使用接口定义对象类型"></a>使用接口定义对象类型</h1><ul><li>接口使用<code>interface</code> 关键字定义</li><li>接口首字母大写</li><li><p>对象类型的属性分为确定属性、只读属性、可选属性、任意属性</p></li><li><p>确定属性：也就是固定的属性，接口有 变量声明时就必须有,</p></li><li>只读属性：<code>readonly</code> 关键字定义，第一次赋值后无法更改，是在接口创建后只能<strong> 第一次给对象赋值的时候为只读属性赋值 </strong>， 而不是第一次给只读属性赋值</li><li>可选属性：属性名 + ?，表示该属性可以不存在</li><li>任意属性：<code>[propName: string]: any;</code> 冒号前半部分表示任意属性取 <code>string类型</code>的值，后半部分是类型的子集</li><li>一旦定义了任意属性，那么另外三种属性的类型都必须是它的类型的子集，可将任意属性的类型的子集定义为 <code>联合类型</code> 或者 <code>any 类型</code></li></ul><p>一个栗子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;                <span class="comment">// 只读属性</span></span><br><span class="line">    a: <span class="built_in">string</span>;                                  <span class="comment">// 确定属性</span></span><br><span class="line">    b?: <span class="built_in">number</span>;                             <span class="comment">// 可选属性</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;     <span class="comment">// 任意属性</span></span><br><span class="line">&#125;       <span class="comment">// 会报错，任意属性类型的子集为 string，而 b 和 id 的类型为number，不属于任意属性类型的子集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: Person = &#123; <span class="comment">// 报错 没有给只读属性 id 赋值</span></span><br><span class="line">    a: <span class="string">'123'</span>,</span><br><span class="line">    b: <span class="number">456</span>,</span><br><span class="line">    c: <span class="string">'789'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.id = <span class="number">89757</span>; <span class="comment">// 报错 因为这不是对象第一次赋值</span></span><br></pre></td></tr></table></figure></p><p>修改为<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    a: <span class="built_in">string</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj: Person = &#123; </span><br><span class="line">    id: <span class="number">8</span>,</span><br><span class="line">    a: <span class="string">'123'</span>,</span><br><span class="line">    b: <span class="number">456</span>,</span><br><span class="line">    c: <span class="string">'789'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="数组类型：类型-方括号，-数组的每一项元素都必须符合类型"><a href="#数组类型：类型-方括号，-数组的每一项元素都必须符合类型" class="headerlink" title="数组类型：类型 + 方括号，  数组的每一项元素都必须符合类型 "></a>数组类型：类型 + 方括号， <strong> 数组的每一项元素都必须符合类型 </strong></h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// 数组元素类型只能是 number</span></span><br><span class="line"><span class="keyword">let</span> c: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// 联合类型和数组的结合</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">3</span>, &#123;a: <span class="number">1</span>&#125;]; <span class="comment">// any 类型</span></span><br></pre></td></tr></table></figure><p>接口定义<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure></p><h1 id="函数的类型定义"><a href="#函数的类型定义" class="headerlink" title="函数的类型定义"></a>函数的类型定义</h1><ul><li>函数的输入和输出为必须，且都必须定义类型</li><li>可选参数：参数名 + ? ，可选参数必须在必填参数后面</li><li>默认参数：设置了默认值的参数会被 TypeScript 识别为可选参数，但不受 “可选参数必须在必填参数后面” 这个限制</li><li>剩余参数：指除了 必选参数 和 可选参数 以外的参数，使用 … 获取剩余参数为数组格式需定义类型，剩余参数必须排在参数末尾</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小括号里面是输入的参数包括对参数类型的定义，花括号前面的number是输出的类型</span></span><br><span class="line"><span class="comment">// y 设置了默认参数，为可选参数</span></span><br><span class="line"><span class="comment">// z为可选参数</span></span><br><span class="line"><span class="comment">// rest 为剩余参数，any 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = 6, z?: <span class="built_in">number</span>, ...rest: <span class="built_in">any</span>[]</span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 4,5 为剩余参数</span></span><br></pre></td></tr></table></figure><p>函数表达式:  <code>=&gt;</code>不是箭头函数，他表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="类型断言：-lt-类型-gt-值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型"><a href="#类型断言：-lt-类型-gt-值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型" class="headerlink" title="类型断言：&lt;类型&gt;值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型"></a>类型断言：&lt;类型&gt;值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="comment">// 当然这地方你也可以将他定义为any类型</span></span><br><span class="line">    <span class="keyword">return</span> something.length;  <span class="comment">// 报错 类型“number”上不存在属性“length”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">使用类型断言</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`ts</span></span><br><span class="line"><span class="string">function getLength(something: string): number &#123;</span></span><br><span class="line"><span class="string">    return (&lt;string&gt;something).length;  // 将参数定义为string后再去访问他的length</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="类型别名：使用type关键字给一个类型起个新名字，常用于联合类型"><a href="#类型别名：使用type关键字给一个类型起个新名字，常用于联合类型" class="headerlink" title="类型别名：使用type关键字给一个类型起个新名字，常用于联合类型"></a>类型别名：使用<code>type</code>关键字给一个类型起个新名字，常用于联合类型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个"><a href="#字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个" class="headerlink" title="字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个"></a>字符串字面量类型：使用<code>type</code>关键字约束取值只能是某几个字符串中的一个</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  </span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，dbclick不在EventNames中</span></span><br></pre></td></tr></table></figure><h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><ul><li>声明文件以<code>.d.ts</code>为后缀</li><li><code>@type</code>引入第三方声明文件：npm install @types/jquery –save-dev，可以统一管理第三方库的声明文件只需在插件名称前加上<code>@type</code></li><li>declare var/let/const 声明全局变量，一般全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var / let</li><li>declare function 声明全局方法</li><li>declare class 声明全局类</li><li>declare enum 声明全局枚举类型</li><li>declare namespace 声明全局对象（含有子属性）</li><li>interface 和 type 声明全局类型</li></ul><h1 id="元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象"><a href="#元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象" class="headerlink" title="元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象"></a>元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'first'</span>, <span class="number">15</span>];  <span class="comment">// 定义，定义时也可不赋值</span></span><br><span class="line">tup = [<span class="string">'second'</span>, <span class="number">30</span>]                    <span class="comment">// 直接赋值</span></span><br><span class="line">tup[<span class="number">0</span>] = <span class="string">'second'</span>                       <span class="comment">// 通过索引赋值</span></span><br><span class="line">tup = [<span class="string">'second'</span>]                         <span class="comment">// 报错，需要提供所有元组类型中指定的项</span></span><br><span class="line">tup.push(<span class="number">20</span>);                             <span class="comment">// 添加越界元素</span></span><br><span class="line">tup.push(<span class="literal">true</span>);                          <span class="comment">// 报错，越界元素类型会被限制为元组中每个类型的联合类型</span></span><br></pre></td></tr></table></figure><h1 id="枚举：enum关键字用于限定取值在一定范围内"><a href="#枚举：enum关键字用于限定取值在一定范围内" class="headerlink" title="枚举：enum关键字用于限定取值在一定范围内"></a>枚举：<code>enum</code>关键字用于限定取值在一定范围内</h1><p>普通枚举<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举成员会被赋值为从 0 开始递增的数字</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Sun === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们手动赋值时，未被赋值的枚举项会接着上一个枚举项 +1 递增，手动赋值的枚举项也可以为小数或负数</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon = <span class="number">8</span>, Tue, Wed, Thu = <span class="number">5.5</span>, Fri, Sat&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Days.Mon === <span class="number">8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Wed === <span class="number">10</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Fri === <span class="number">6.5</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动赋值的枚举项可以不是数字，需要使用类型断言来让 tsc 无视类型检查，非数字枚举项后面不能跟未手动赋值的枚举项，因为无法获得初始值</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon, Tue, Wed, Thu, Fri, Sat = &lt;<span class="built_in">any</span>&gt;<span class="string">"S"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当枚举项是计算所得项时，后面不能跟是未手动赋值的项</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue = <span class="string">"blue"</span>.length&#125;;</span><br></pre></td></tr></table></figure></p><p>常数枚举：<code>const enum</code>关键字定义，常数枚举会在编译阶段被删除，并且不能包含计算成员<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;Up, Down, Left, Right&#125;</span><br></pre></td></tr></table></figure></p><p>外部枚举：是指使用<code>declare enum</code> 定义的枚举类型，只会用于编译时的检查，编译结果中会被删除<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;Up, Down, Left, Right&#125;</span><br></pre></td></tr></table></figure></p><h1 id="类：基于es6-class-和-es7-新提案的基础上添加了三种访问修饰符"><a href="#类：基于es6-class-和-es7-新提案的基础上添加了三种访问修饰符" class="headerlink" title="类：基于es6 class 和 es7 新提案的基础上添加了三种访问修饰符"></a>类：基于es6 class 和 es7 新提案的基础上添加了三种访问修饰符</h1><p><em>public：修饰的属性或方法是公有的，任何地方都能被访问</em>private：修饰的属性或方法是私有的，不能在声明它的类的外部访问<br>*protected：和 private 类似，区别是它在子类中允许被访问 </p><h1 id="泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性"><a href="#泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性" class="headerlink" title="泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性"></a>泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性</h1><p>vs code 提示：Experimental support for decorators is a feature that is subject to change in a future release. Set the ‘experimentalDecorators’ option to remove this </p><p>在 tsconfig.json 文件中修改规则 experimentalDecorators</p><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p>官网 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">http://www.typescriptlang.org/</a><br>对新手比官网更友好些 <a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" target="_blank" rel="noopener">https://ts.xcatliu.com/introduction/what-is-typescript.html</a><br>vue + ts项目实战 <a href="https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-14</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>canvas性能优化篇</title>
      <link href="/2019/03/18/canvas-3/"/>
      <url>/2019/03/18/canvas-3/</url>
      <content type="html"><![CDATA[<p>看了很多大佬的文章，自己也对项目做了一些优化，其实有很多地方平常码代码的时候稍微注意一下就能节约很多性能开销</p><h1 id="1-离屏渲染"><a href="#1-离屏渲染" class="headerlink" title="1.离屏渲染"></a>1.离屏渲染</h1><p>在离屏canvas上预渲染相似的图形或重复的对象，通俗的解释是将离屏canvas当成预渲染，在离屏canvas上绘制好一整块图形，绘制好后在放到视图canvas中，适合每一帧画图运算复杂的图形</p><p>比如你想把一张图片放到canvas上，使用drawImage()方法，有三种写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将image放到目标canvas指定位置</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy); </span><br><span class="line"><span class="comment">// 将image放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 将image裁剪之后放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure></p><p>第一种只是把图片原样放到canvas里，第二章指定宽高就意味着放大或者缩小图片后再放进去，带三种是裁剪后再放大或者缩小放到canvas中，这三种写法操作依次增加，性能开销也是依次提高<br>而离屏渲染就可以让我们先把图片裁剪成想要的尺寸内容保存起来，绘制的时候就可以使用第一种写法简单的把图片放进去就完了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在离屏 canvas 上绘制</span></span><br><span class="line"><span class="keyword">var</span> offscreencanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="comment">// 宽高赋值为想要的图片尺寸</span></span><br><span class="line">offscreencanvas.width = dWidth;</span><br><span class="line">offscreencanvas.height = dHeight;</span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">offscreencanvas.getContext(<span class="string">'2d'</span>).drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 在视图canvas中绘制</span></span><br><span class="line">viewcontext.drawImage(canvas, x, y);</span><br></pre></td></tr></table></figure><h1 id="2-分层画布"><a href="#2-分层画布" class="headerlink" title="2.分层画布"></a>2.分层画布</h1><p>多个相互重叠的canvas根据变化程度分开渲染，越复杂的场景越适合</p><p>比如一个简单的游戏场景，游戏背景始终不变或者变化次数较少但是人物游戏的主体是一直在根据玩家的指挥不停的改变，</p><p>场景：最近写的一个画板，比如这样一个简单的画圆，可以看到有原来的绘画的痕迹，那就要 渲染没画圆之前的画布 -&gt; 再画圆，鼠标移动的时候不断的执行这个渲染过程</p><p><img src="/2019/03/18/canvas-3/canvas-3.gif" alt="示例画圆gif"></p><p>这个时候就可以使用分层画布，画画在一个上层canvas上，原来绘画痕迹在下层canvas上，那么画圆的过程就是清空 -&gt; 画圆，画好之后再放到下层canvas上，这样就不需要去渲染之前的画布，就能节约性能开销</p><h1 id="3-一次性绘制"><a href="#3-一次性绘制" class="headerlink" title="3.一次性绘制"></a>3.一次性绘制</h1><p>绘制操作的性能开销较高，可以创建一个包含所有线条的路径，然后通过单个绘制路径调用进行绘制</p><p>从这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变成这样，在绘制复杂路径时，最好将所有点都放入路径中，而不是分别呈现各个片段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">&#125;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p><h1 id="4-使用requestAnimationFrame执行动画"><a href="#4-使用requestAnimationFrame执行动画" class="headerlink" title="4.使用requestAnimationFrame执行动画"></a>4.使用requestAnimationFrame执行动画</h1><p>canvas动画的本质是不断地擦除和重绘，再结合一些时间控制的方法达到动画的目的<br>显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms<br>而requestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命</p><p>详细看<a href="https://tong-h.github.io/2019/03/07/canvas-2/#more" target="_blank" rel="noopener">这儿</a></p><h1 id="5-清空画布"><a href="#5-清空画布" class="headerlink" title="5.清空画布"></a>5.清空画布</h1><p>三种方法性能，性能依次提高<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect()</span><br><span class="line">context.clearRect()</span><br><span class="line">canvas.width = canvas.width; <span class="comment">// 一种画布专用的技巧</span></span><br></pre></td></tr></table></figure></p><h1 id="6-减少调用canvas的api"><a href="#6-减少调用canvas的api" class="headerlink" title="6.减少调用canvas的api"></a>6.减少调用canvas的api</h1><p>比如像背景可以使用css属性设置或者img标签加一些定位什么的</p><p>画布的缩放可以使用CSS transforms，不要将小画布放大，而是去将大画布缩小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scaleX = canvas.width / <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> scaleY = canvas.height / <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scaleToFit = <span class="built_in">Math</span>.min(scaleX, scaleY);</span><br><span class="line"><span class="keyword">var</span> scaleToCover = <span class="built_in">Math</span>.max(scaleX, scaleY);</span><br><span class="line"></span><br><span class="line">stage.style.transformOrigin = <span class="string">'0 0'</span>; <span class="comment">//scale from top left</span></span><br><span class="line">stage.style.transform = <span class="string">'scale('</span> + scaleToFit + <span class="string">')'</span>;</span><br></pre></td></tr></table></figure></p><h1 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h1><ul><li>尽可能使用计算代替canvas渲染，通常情况下，渲染比计算的开销大很多（3~4 个量级）</li><li>减少改变 context 的状态以及不要赋一些乱七八糟类型的值，比如人家要一个number你要给一个string，浏览器会用一些额外时间来处理这些非法输入，可能会造成三四倍的时间开销</li><li>避免使用浮点数坐标，使用非整数的坐标绘制内容，系统会自动使用抗锯齿功能，尝试对线条进行平滑处理，这又是一种性能消耗。可以调用 Math.round 四舍五入取整</li><li>减少使用 shadowBlur 效果，和很多图像环境渲染一样，阴影渲染的性能开销通常比较高</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a><br><a href="https://www.html5rocks.com/zh/tutorials/canvas/performance/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/canvas/performance/</a><br><a href="http://taobaofed.org/blog/2016/02/22/canvas-performance/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/02/22/canvas-performance/</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>canvas动画篇</title>
      <link href="/2019/03/07/canvas-2/"/>
      <url>/2019/03/07/canvas-2/</url>
      <content type="html"><![CDATA[<p>最近用canvas蛮多的，canvas写动画也蛮好使的</p><h1 id="canvas-由-js-来控制，但用-js-写动画通常3种方法控制时间"><a href="#canvas-由-js-来控制，但用-js-写动画通常3种方法控制时间" class="headerlink" title="canvas 由 js 来控制，但用 js 写动画通常3种方法控制时间"></a>canvas 由 js 来控制，但用 js 写动画通常3种方法控制时间</h1><ul><li><p><font color="#bb1509" size="4"><strong>setInterval( function, delay )</strong></font> 在指定的毫秒数下循环调用函数或表达式，直到使用clearInterval清除</p></li><li><p><font color="#bb1509" size="4"><strong>setTimeout( function, delay )</strong></font> 在指定的毫秒数后调用函数或计算表达式</p></li></ul><p>前两个是平时会用得会比较多的，setInterval 和 setTimeout的本质是将回调函数添加到任务队列的尾部等待执行，但是前面的任务到底需要多少时间执行完是不确定的，如果前面堵塞了那么后面就无法执行<br>尤其setInterval指定的是”开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间，<strong>下一个回调开始执行的时间 = 指定时间 - 回调函数执行的时间</strong>，因此实际上，两次执行之间的间隔会小于指定的时间</p><p>下面的写法可以确保执行时间始终是2000ms<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  timer = setTimeout(f, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></p><ul><li><font color="#bb1509" size="4"><strong>window.requestAnimationFrame(callback) 和 window.requestAnimationFrame(requestID)</strong></font><br>前者是告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，返回一个 requestID，该回调会在浏览器下一次重绘之前执行<br>后者是取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求，接受一个 requestID，不需要的时候就取消掉释放内存绝对是个好习惯</li></ul><p>显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms<br>requestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命</p><h1 id="一些canvas的小例子"><a href="#一些canvas的小例子" class="headerlink" title="一些canvas的小例子"></a>一些canvas的小例子</h1><p>自己学习过程中用canvas写的一些小东西，源码带有注解给大家参考，会坚持不断更新这个目录….</p><p><strong><a href="https://tong-h.github.io/canvas-store/roundPercent/index.html" target="_blank" rel="noopener">环形百分比动画</a></strong><br><img src="https://tong-h.github.io/canvas-store/roundPercent/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/particle/index.html" target="_blank" rel="noopener">粒子动画</a></strong><br><img src="https://tong-h.github.io/canvas-store/particle/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/draw/index.html" target="_blank" rel="noopener">电子画板</a></strong><br><img src="https://tong-h.github.io/canvas-store/draw/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/imgcut/index.html" target="_blank" rel="noopener">图片裁剪</a></strong><br><img src="https://tong-h.github.io/canvas-store/imgcut/img.png" alt="示例图片"></p><h1 id="本站和canvas有关的文章"><a href="#本站和canvas有关的文章" class="headerlink" title="本站和canvas有关的文章"></a>本站和canvas有关的文章</h1><p><strong><a href="https://tong-h.github.io/2019/02/21/canvas-1/#more" target="_blank" rel="noopener">cannvas的imagedata对象</a></strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.w3cplus.com/javascript/requestAnimationFrame.html" target="_blank" rel="noopener">https://www.w3cplus.com/javascript/requestAnimationFrame.html</a> © w3cplus.com<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a><br><a href="https://javascript.ruanyifeng.com/advanced/timer.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/advanced/timer.html</a></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>google 搜索语法</title>
      <link href="/2019/03/01/googleSearch/"/>
      <url>/2019/03/01/googleSearch/</url>
      <content type="html"><![CDATA[<p>现在越来越习惯用google了，不是我嫌弃百度，只是用了google发现百度真的让人爱不起来，没有对比就没有伤害</p><p>收集了一些google常用的语法，备忘</p><p>这些是已经被弃用的：+、~、inpostauthor:、allinpostauthor:、inposttitle:、link:、info:、daterange:、phonebook:、#</p><p>这些是在被弃用边缘，搜索结果不是非常准确的</p><table><thead><tr><th style="text-align:center">symbol</th><th style="text-align:left">example</th><th style="text-align:left">explain</th></tr></thead><tbody><tr><td style="text-align:center">..</td><td style="text-align:left">apple 2010..2014</td><td style="text-align:left">范围搜索，返回2010到2014，不超过2015的信息</td></tr><tr><td style="text-align:center">inanchor:</td><td style="text-align:left">inanchor：apple iphone</td><td style="text-align:left">返回锚文本中包含指定词汇的页面</td></tr><tr><td style="text-align:center">allinanchor:</td><td style="text-align:left">inanchor：apple iphone</td><td style="text-align:left">和inanchor类似，返回锚文本中包含所有指定词汇的页面</td></tr><tr><td style="text-align:center">blogurl:</td><td style="text-align:left">blogurl：阮一峰</td><td style="text-align:left">谷歌博客搜索</td></tr><tr><td style="text-align:center">loc:</td><td style="text-align:left">loc:san francisco</td><td style="text-align:left">查找给定区域的结果</td></tr></tbody></table><p>以下是谷歌最新的常用搜索语法，帮助你更快找到你要的信息</p><table><thead><tr><th style="text-align:center">symbol</th><th style="text-align:left">example</th><th style="text-align:left">explain</th></tr></thead><tbody><tr><td style="text-align:center"> OR或者管道符号（竖线）</td><td style="text-align:left">x OR y</td><td style="text-align:left">返回x或者y的信息，或者和两者都相关的信息</td></tr><tr><td style="text-align:center"> AND</td><td style="text-align:left">x AND y</td><td style="text-align:left">返回和两者都相关的信息</td></tr><tr><td style="text-align:center"> - 短横线</td><td style="text-align:left">x -y</td><td style="text-align:left">排除一个相似的容易造成误导的词语，返回x相关的信息而不是y，注意: 符号-和y之间没有空格</td></tr><tr><td style="text-align:center"> * 通配符</td><td style="text-align:left">x * y</td><td style="text-align:left">匹配任何信息</td></tr><tr><td style="text-align:center"> () 括号</td><td style="text-align:left">(x OR y) -z</td><td style="text-align:left">将多个款项和符号组合搜索</td></tr><tr><td style="text-align:center"> $ 美元符号</td><td style="text-align:left">iphone $2000</td><td style="text-align:left">价格搜索</td></tr><tr><td style="text-align:center"> define:</td><td style="text-align:left">define:china</td><td style="text-align:left">显示谷歌内置的词典，以卡片形式展现</td></tr><tr><td style="text-align:center"> cache:</td><td style="text-align:left">cache:<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></td><td style="text-align:left">返回该页面最新缓存版本</td></tr><tr><td style="text-align:center"> filetype: 或者 ext:</td><td style="text-align:left">个人简历 filetype:pdf</td><td style="text-align:left">返回符合指定的文件类型的信息</td></tr><tr><td style="text-align:center"> site:</td><td style="text-align:left">js site:github.com</td><td style="text-align:left">将搜索限制在某个指定的网站</td></tr><tr><td style="text-align:center"> related:</td><td style="text-align:left">related:github.com</td><td style="text-align:left">查找和给定域名相关的站点</td></tr><tr><td style="text-align:center"> intitle:</td><td style="text-align:left">intitle:github</td><td style="text-align:left">返回所有标题中包含“github”的信息</td></tr><tr><td style="text-align:center"> allintitle:</td><td style="text-align:left">allintitle:github js</td><td style="text-align:left">和intitle类似，返回标题中包含所有单词的信息</td></tr><tr><td style="text-align:center"> inurl:</td><td style="text-align:left">inurl:github</td><td style="text-align:left">和intitle类似，不同的是匹配的是url而不是标题</td></tr><tr><td style="text-align:center"> allinurl</td><td style="text-align:left">allinurl:github js</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:center"> intext:</td><td style="text-align:left">intext:github</td><td style="text-align:left">和intitle类似，不同的是匹配的是内容而不是标题</td></tr><tr><td style="text-align:center"> allintext:</td><td style="text-align:left">allintext:github js</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:center"> AROUND(X)</td><td style="text-align:left">apple AROUND（4）iphone</td><td style="text-align:left">间隔限制，单词“apple”和“iphone”必须出现在内容中，并且相隔不超过四个单词。</td></tr><tr><td style="text-align:center"> weather:</td><td style="text-align:left">weather:san francisco</td><td style="text-align:left">查找指定位置的天气</td></tr><tr><td style="text-align:center"> stocks:</td><td style="text-align:left">stocks:aapl</td><td style="text-align:left">查找指定的股票信息</td></tr><tr><td style="text-align:center"> map:</td><td style="text-align:left">map:silicon valley</td><td style="text-align:left">地图搜索</td></tr><tr><td style="text-align:center"> movie:</td><td style="text-align:left">movie:steve jobs</td><td style="text-align:left">电影搜索</td></tr><tr><td style="text-align:center"> in</td><td style="text-align:left">$329 in GBP</td><td style="text-align:left">单位转换，前者向后者转换</td></tr><tr><td style="text-align:center"> source:</td><td style="text-align:left">apple source:the_verge</td><td style="text-align:left">在google News中查找来自某个来源的新闻</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cannvas的imagedata对象</title>
      <link href="/2019/02/21/canvas-1/"/>
      <url>/2019/02/21/canvas-1/</url>
      <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>ImageData 是canvas的图像数据，由<strong> ImageData() </strong>构造函数返回一个实例化的对象，<strong> 三个可读属性 </strong> </p><ul><li><p>data：一个 Uint8ClampedArray 类型的一维数组，包含RGBA 顺序的数据，每4个元素表示一个RGBA 值即对应一个像素, 左上角在数组的索引0位置，像素从左到右被处理，然后往下，遍历整个数组<br><strong> RGBA：</strong> R - 红色（0-255）、G - 绿色（0-255）、B - 蓝色（0-255）、A - alpha 通道（0-255; 0 是透明的，255 是完全可见的）<br><strong>  Uint8ClampedArray（8位无符号整型固定数组）：</strong> 类型化数组表示一个由值固定在0-255区间的8位无符号整型组成的数组；如果你指定一个在 [0,255] 区间外的值，它将被替换为0或255；如果你指定一个非整数，那么它将被设置为最接近它的整数。（数组）内容被初始化为0。</p></li><li><p>width：以像素为单位的图像的宽</p></li><li><p>height：以像素为单位的图像的高</p></li></ul><p><strong> 三个参数的关系是：data.length = height * width * 4 </strong><br>不满足这个关系的时候就会报错：” The input data length is not a multiple of (4 * width).” ，不要问我为什么知道</p><h2 id="构建一个ImageData-对象"><a href="#构建一个ImageData-对象" class="headerlink" title="构建一个ImageData 对象"></a>构建一个ImageData 对象</h2><h3 id="使用canvas-API"><a href="#使用canvas-API" class="headerlink" title="使用canvas API"></a>使用canvas API</h3><p><strong> createImageData(): 传入宽和高获得一个ImageData对象或者传入一个已经存在的ImageData对象渲染到画布 </strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ctx.createImageData(<span class="number">200</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure></p><p><strong> getImageData(): 提取一个矩形区域的图像数据，返回一个ImageData对象 </strong><br>ctx.getImageData(矩形区域的左上角 x 坐标, 矩形区域的左上角 y 坐标, 矩形区域的宽度, 矩形区域的高度)<br>下面是一个简单的小例子让div背景色随着鼠标指针下的图片颜色变化而变化，思路是使用 getImageData() 获取鼠标下1像素的区域，也就是一个RGBA值赋值给div<br>运行时注意canvas图片使用 getImageData() 的跨域问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'./static/img/1547436818106.png'</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  img.style.display = <span class="string">'none'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> color = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>)</span><br><span class="line">canvas.addEventListener(<span class="string">'mousemove'</span>, (e) =&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> pixel = ctx.getImageData(e.layerx, e.layery, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  color.style.background =  <span class="string">'rgba('</span> + pixel.data[<span class="number">0</span>] + <span class="string">','</span> + pixel.data[<span class="number">1</span>] + <span class="string">','</span> + pixel.data[<span class="number">2</span>] + <span class="string">','</span> + (pixel.data[<span class="number">3</span>] / <span class="number">255</span>) + <span class="string">')'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="直接使用ImageData-构造函数创建-data可为空"><a href="#直接使用ImageData-构造函数创建-data可为空" class="headerlink" title="直接使用ImageData()构造函数创建, data可为空"></a>直接使用ImageData()构造函数创建, data可为空</h3><p>当data为空时会自动按照width和height的大小，以0填充整个像素矩阵，也就是一个空白画布<br>若需要传入data图像数据，要注意 width * height * 4 = data.length<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imagedata = <span class="keyword">new</span> ImageData(data, width, height)</span><br><span class="line"><span class="comment">// ImageData &#123; width: width, height: height, data: Uint8ClampedArray[width * height * 4] &#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="操作像素"><a href="#操作像素" class="headerlink" title="操作像素"></a>操作像素</h2><p><strong> putImageData(): 对画布进行像素数据的写入，也就是将指定的 ImageData 对象放到画布上，7个参数，前3个为必填 </strong><br>ctx.putImageData(imagedata, 图像数据在目标画布中的位置X坐标, Y坐标, 在图像数据中截取一个矩形区域左上角的位置X坐标, Y坐标, 矩形区域Width, Height);<br>一个小例子图片灰度处理，思路是使用 getImageData() 获取当前 ImageData 数据，然后遍历 data 数组改变 RGBA 的值，最后在使用 putImageData() 放回画布<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'./static/img/shareedu.png'</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  img.style.display = <span class="string">'none'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,canvas.width, canvas.height)</span><br><span class="line">  <span class="keyword">let</span> data = pre.data</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> avg = (data[i] + data[i +<span class="number">1</span>] + data[i +<span class="number">2</span>]) / <span class="number">3</span></span><br><span class="line">    data[i] = avg</span><br><span class="line">    data[i + <span class="number">1</span>] = avg</span><br><span class="line">    data[i + <span class="number">2</span>] = avg</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.putImageData(pre, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong> drawImage(): 在画布上绘制图像，9个参数，image, dx, dy为必填 </strong><br>image: 图像源<br>sx: 选择需要的图像源区域，矩形选择框的左上角 X 轴坐标。<br>sy:  矩形选择框的Y 轴坐标。<br>sWidth: 需要绘制到目标上下文中的，image的矩形（裁剪）选择框的宽度。如果不说明，整个矩形（裁剪）从坐标的sx和sy开始，到image的右下角结束。<br>sHeight: 需要绘制到目标上下文中的，image的矩形（裁剪）选择框的高度。<br>dx: image的左上角在目标canvas上 X 轴坐标。<br>dy: image的左上角在目标canvas上 Y 轴坐标。<br>dWidth: image在目标canvas上绘制的宽度。 允许对绘制的image进行缩放<br>dHeight: image在目标canvas上绘制的高度。 允许对绘制的image进行缩放<br>一个小例子将图片放在鼠标指定位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'./static/img/shareedu.png'</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>).addEventListener(<span class="string">'mousedown'</span>, (e)=&gt;&#123;</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,ctx.canvas.width,ctx.canvas.height)</span><br><span class="line">  ctx.drawImage(img, e.offsetX, e.offsetY, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong> imageSmoothingEnabled, 这是个属性设置图片是否平滑，只需要将他赋值为true（平滑）或者false（不平滑） </strong></p><p><strong> canvas.toDataURL(‘image/png’, quality) 返回一个包含图片展示的 data URI , 2个参数, 图片格式默认为png, 0到1的品质选择（图片格式为 image/jpeg 或 image/webp的情况下） </strong></p><p><strong> canvas.toBlob(callback, type, encoderOptions),创建一个Blob对像，用以展示canvas上的图片，3个参数 </strong><br>callback：回调函数返回一个blob对象<br>type：图片格式，默认为’image/png’<br>encoderOptions:  0到1的品质选择（图片格式为 image/jpeg 或 image/webp的情况下）</p><h1 id="一些canvas的小例子"><a href="#一些canvas的小例子" class="headerlink" title="一些canvas的小例子"></a>一些canvas的小例子</h1><p>自己学习过程中用canvas写的一些小东西，源码带有注解给大家参考，会坚持不断更新这个目录….</p><p><strong><a href="https://tong-h.github.io/canvas-store/roundPercent/index.html" target="_blank" rel="noopener">环形百分比动画</a></strong><br><img src="https://tong-h.github.io/canvas-store/roundPercent/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/particle/index.html" target="_blank" rel="noopener">粒子动画</a></strong><br><img src="https://tong-h.github.io/canvas-store/particle/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/draw/index.html" target="_blank" rel="noopener">电子画板</a></strong><br><img src="https://tong-h.github.io/canvas-store/draw/img.png" alt="示例图片"><br><strong><a href="https://tong-h.github.io/canvas-store/imgcut/index.html" target="_blank" rel="noopener">图片裁剪</a></strong><br><img src="https://tong-h.github.io/canvas-store/imgcut/img.png" alt="示例图片"></p><h1 id="本站和canvas有关的文章"><a href="#本站和canvas有关的文章" class="headerlink" title="本站和canvas有关的文章"></a>本站和canvas有关的文章</h1><p><strong><a href="https://tong-h.github.io/2019/03/07/canvas-2/#more" target="_blank" rel="noopener">canvas动画篇</a></strong></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Electron踩坑指南不完全篇</title>
      <link href="/2018/12/13/electron/"/>
      <url>/2018/12/13/electron/</url>
      <content type="html"><![CDATA[<p>前段时间做了个客户端的项目，主要适用于老师教案管理、远程上课录屏、和学生互动答疑等场景，原生开发对公司来说成本有点大，基于guthub上有各种桌面打包框架so只能前端上了</p><p>Electron + vue = product</p><p>这是一篇踩坑的记录，没有太深入的原理什么的讲解，主要是码代码过程中碰到的一些暗坑你如果正在写Electron的项目那么你也可能会遇到，这篇文章会给你一些参考</p><h1 id="为什么用Electron"><a href="#为什么用Electron" class="headerlink" title="为什么用Electron"></a>为什么用Electron</h1><p>这是目前大家知道比较多的三种跨平台的桌面框架<br>NWJS      <a href="https://nwjs.io/" target="_blank" rel="noopener">https://nwjs.io/</a><br>HEX       <a href="http://hex.youdao.com/zh-cn/tutorial/index.html" target="_blank" rel="noopener">http://hex.youdao.com/zh-cn/tutorial/index.html</a><br>Electron  <a href="https://Electronjs.org/docs" target="_blank" rel="noopener">https://Electronjs.org/docs</a></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong> Electron </strong></th><th style="text-align:center"><strong> nw.js </strong></th><th style="text-align:center"><strong> hex </strong>  </th></tr></thead><tbody><tr><td style="text-align:center"> <strong> 发布时间 </strong></td><td style="text-align:center">2013年</td><td style="text-align:center">2011年</td><td style="text-align:center">2012年 </td></tr><tr><td style="text-align:center"> <strong> 开发公司 </strong></td><td style="text-align:center">github</td><td style="text-align:center">intel</td><td style="text-align:center">有道翻译 </td></tr><tr><td style="text-align:center"> <strong> 代表作 </strong></td><td style="text-align:center">Atom、Visual Studio Code 、WordPress</td><td style="text-align:center">微信web开发工具、钉钉</td><td style="text-align:center">有道云笔记，有道词典</td></tr><tr><td style="text-align:center"> <strong> github start </strong></td><td style="text-align:center">66608</td><td style="text-align:center">34555</td><td style="text-align:center">1429 </td></tr></tbody></table><p>三个框架都是 chromium + nodejs + native api ， 不用考虑浏览器兼容性还能用nodejs，简直不要太爽</p><ul><li>Chromium 是 Google 为发展 Chrome 浏览器而启动的开源项目，它对HTML5的支持非常优秀，其内嵌的V8引擎是业内效率最好的JavaScript脚本引擎之一，且其项目开源，又有专门的社区和团队维护，作为UI渲染引擎，它是不二之选，体验上，你可以试用下google chrome浏览器，基本一致</li><li>Node.js （或者简称 Node） 一个工具，选择Node.JS，是因为开发桌面应用，本地资源操作是必备的能力，这方面JavaScript无能为力，而Node.JS则很好的解决了这个问题，它使得JavaScript操作本地资源变的毫无障碍。另一方面，Node.JS核心也是采用V8引擎，使得其与Chromium的整合变得更顺理成章</li><li>API 应用程序接口描述了一系列可供你使用的函数库中的函数</li></ul><p>我绝对是有道词典的忠实用户但是hex用的人较少怕遇坑爬不出来，nwjs主要优点是能兼容winXP，但是我不需要。。。而且nw和Electron是同一个大佬一前一后开发，Electron相当于是nwjs的重构升级版，官网又这么好看又那么火，还犹豫？</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>官网传送门</p><ul><li>官方api <a href="https://Electronjs.org/docs" target="_blank" rel="noopener">https://Electronjs.org/docs</a></li><li>Electron-vue文档 <a href="https://simulatedgreg.gitbooks.io/Electron-vue/content/cn/getting_started.html" target="_blank" rel="noopener">https://simulatedgreg.gitbooks.io/Electron-vue/content/cn/getting_started.html</a></li><li>中文社区文档<a href="https://Electron.org.cn/doc/index.html" target="_blank" rel="noopener">https://Electron.org.cn/doc/index.html</a></li></ul><p>常用的一些模块：</p><ul><li>文件打开删除等操作 shell模块  <a href="https://Electronjs.org/docs/api/shell" target="_blank" rel="noopener">https://Electronjs.org/docs/api/shell</a></li><li>窗口管理修改新建参数等 BrowserWindow模块  <a href="https://Electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">https://Electronjs.org/docs/api/browser-window</a></li><li>主进程和渲染进程通信 ipcRenderer 模块   <a href="https://Electronjs.org/docs/api/ipc-renderer" target="_blank" rel="noopener">https://Electronjs.org/docs/api/ipc-renderer</a></li><li>获取屏幕大小、鼠标位置等信息 screen 模块  <a href="https://Electronjs.org/docs/api/screen" target="_blank" rel="noopener">https://Electronjs.org/docs/api/screen</a></li><li>渲染进程使用BrowserWindow 实例  remote模块  <a href="https://Electronjs.org/docs/api/remote" target="_blank" rel="noopener">https://Electronjs.org/docs/api/remote</a></li></ul><h1 id="暗-坑"><a href="#暗-坑" class="headerlink" title="暗 坑"></a>暗 坑</h1><p>Electron是个很成熟很完善的框架，所以这些也不叫暗坑，只是小白如果没有很仔细的阅读api就可能容易掉坑里，不要问我为什么知道，我是有故事的人</p><h2 id="Q、已经引了BrowserWindow-为什么使用函数会是undefined？"><a href="#Q、已经引了BrowserWindow-为什么使用函数会是undefined？" class="headerlink" title="Q、已经引了BrowserWindow 为什么使用函数会是undefined？"></a>Q、已经引了BrowserWindow 为什么使用函数会是undefined？</h2><p>A、Electron分为主进程和渲染进程，Electron 运行 package.json 的 main 脚本的进程被称为主进程只有一个，而渲染进程就是你的页面一个BrowserWindow 实例，所以api也分为主进程和渲染进程以及两者通用的api，所以用api的时候得注意，在渲染进程中使用 BrowserWindow 实例需要引入 remote 模块</p><p>主进程可用的模块:app、autoUpdate、BrowserView、BrowserWindow、contentTracing、dialog、globalShortcut、inAppPurchase、ipcMain、Menu、MenuItem、net、netLog、powerMonitor、powerSaveBlocker、protocol、session、systemPreferences、Tray、webContents<br>渲染进程（网页）可用的模块:、desktopCapturer、ipcRenderer、remote、webFrame<br>两种进程都可用的模块:、clipboard、crashReporter、nativeImage、screen、shell</p><h2 id="Q、想在渲染进程使用主进程的api？"><a href="#Q、想在渲染进程使用主进程的api？" class="headerlink" title="Q、想在渲染进程使用主进程的api？"></a>Q、想在渲染进程使用主进程的api？</h2><p>A、有某些功能必须得在主进程才能实现，比如保存文件、选择文件路径什么的，这些操作可以使用 ipcRenderer 模块用于两个进程之间的通信，由渲染进程发出指令后在主进程进行功能操作</p><h2 id="Q、单击PDF文件的链接时，Electron会提示下载而非直接预览？"><a href="#Q、单击PDF文件的链接时，Electron会提示下载而非直接预览？" class="headerlink" title="Q、单击PDF文件的链接时，Electron会提示下载而非直接预览？"></a>Q、单击PDF文件的链接时，Electron会提示下载而非直接预览？</h2><p>A、单击PDF文件的链接时，在普通浏览器中它会预览该文件。但在Electron中你需要尝试使用 iframe 加载，如果无效可以再试下 webview </p><h2 id="Q、动态的修改静态文件的路径会报链接404？"><a href="#Q、动态的修改静态文件的路径会报链接404？" class="headerlink" title="Q、动态的修改静态文件的路径会报链接404？"></a>Q、动态的修改静态文件的路径会报链接404？</h2><p>A、使用Electron-vue框架，动态的修改静态文件的路径会报链接404但是一开始写死就没问题，所有静态文件都建议放在根目录下 static 文件夹下，然后任何页面访问 static/… 即可</p><h2 id="Q、透明窗口无效？"><a href="#Q、透明窗口无效？" class="headerlink" title="Q、透明窗口无效？"></a>Q、透明窗口无效？</h2><p>A、新建窗口时已经设置了frame: false,transparent: true, 为什么页面还是白色，开发模式下看透明窗口需要关掉开发者模式后刷新</p><h2 id="Q、新建一个窗口，然后拖动该窗口，宽度和高度会小于指定值？"><a href="#Q、新建一个窗口，然后拖动该窗口，宽度和高度会小于指定值？" class="headerlink" title="Q、新建一个窗口，然后拖动该窗口，宽度和高度会小于指定值？"></a>Q、新建一个窗口，然后拖动该窗口，宽度和高度会小于指定值？</h2><p>A、 guthub上有大佬说setResizable: false下最小化且连续恢复，则窗口的高度每次都会减少一个看起来等于菜单栏的量，取消菜单后正常，设置window.setMenu(null)，但是这个方法对我不适用<br>在 issues上翻了一圈，最后 useContentSize: true设置为true + 更改width和height属性以适应测量大小 = 解决</p><h2 id="Q、navigator-mediaDevices-getUserMedia-使用该属性报错？"><a href="#Q、navigator-mediaDevices-getUserMedia-使用该属性报错？" class="headerlink" title="Q、navigator.mediaDevices.getUserMedia 使用该属性报错？"></a>Q、navigator.mediaDevices.getUserMedia 使用该属性报错？</h2><p>A、之前使用这个属性报错还以为Electron不支持，感觉很奇怪他继承的是最新的 chromium 为什么会不支持这个属性，然后某天翻api发现 desktopCapturer 模块，这个属性被Electron封装了，需要引入 desktopCapturer 模块，所以敲黑板一定要认真看api</p><h2 id="Q、打包问题？"><a href="#Q、打包问题？" class="headerlink" title="Q、打包问题？"></a>Q、打包问题？</h2><p>A、前端大部分框架都封装了webpack，glup什么的都有打包功能，然后一搜 “ 某某框架 打包 ” ，出来的都是什么打包报错？ 空白？一大堆问题，感觉这个问题好像无解<br>之前我写demo的时候打包各种报错，可能是因为写demo的时候各种实验各种乱搞把框架玩坏了，反正正式写项目的时候一个打包问题都没有碰到过<br>只是一点第一次打包的时候很慢，因为Electron需要翻墙下载文件，这时候如果打包失败，多半就是被墙了</p><h2 id="Q、’-’和’-‘符号路径问题"><a href="#Q、’-’和’-‘符号路径问题" class="headerlink" title="Q、’\’和’/‘符号路径问题"></a>Q、’\’和’/‘符号路径问题</h2><p>A、通过Electron获取的路径这样的’d:\project...’，本来挺好的文件保存读取什么的用这个路径都挺正常的，但是使用nodejs的exec库调取cmd执行ffmpeg的命令会报错，需要把路径分隔符’\’换成’/‘ </p><h2 id="Q、关于新建窗口时的白屏"><a href="#Q、关于新建窗口时的白屏" class="headerlink" title="Q、关于新建窗口时的白屏"></a>Q、关于新建窗口时的白屏</h2><p>A、新建窗口由于加载页面和初始化窗口会有一段时间的白屏，有个方法就是初始化程序的时候就加载的所有窗口，但是只显示主窗口,其余的窗口隐藏,这样就能有效创建窗口时的白屏</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语单词打卡记录</title>
      <link href="/2018/11/16/english-clockIn/"/>
      <url>/2018/11/16/english-clockIn/</url>
      <content type="html"><![CDATA[<p>背单词接近3个月了，作为一个朝九晚六的上班族，一般背单词的时间是早上地铁有那么半个小时作为新单词时间然后晚上地铁半个小时是新单词为主 + 少部分需要复习的单词，然后睡觉前1个小时是单词复习时间。</p><p>平时的强度是每天新单词20个这个量其实不多，但是需要复习的单词平均每天有160个左右。<br>我背单词是用anki，个人感觉这是个相当好用的记忆软件，可以帮助你记忆生活任何知识，优点太多就不列举了。用过的小伙伴应该都知道anki根据记忆的遗忘曲线每天都会有需要复习的单词，随着每天持续的加入新单词那么每天需要复习的单词也会越来越多，但是如果每天都坚持背单词并把所有到期需要复习的单词清空掉那么每天需要复习的就不会有这么多。</p><p>但是人啊 (。_。) ，每个星期总有那么一两天各种原因理由(又出现一个大bug？、今天加班、状态不好、其他乱七八糟的事)就会忘了背或者没背完。到期的单词没有被清空就会堆积在第二天，但是第二天也会有单词到期，所以一般就是今天160没背完明天翻个番，眼看着数量越来越多就会越来越不想背然后拖到周末被一次性清空。</p><p>anki记忆卡有四个选项重来、困难、一般、简单，根据自己的记忆深度决定这个单词的到期时间，到时间就把这个单词牵出来遛一遛晃一晃加深印象。那么我一次性拖到周末虽然也背完了但非常不利于单词的记忆，这导致很多背过的单词再出现我会感觉很陌生这样效率就大大降低了。</p><hr><hr><hr>]]></content>
      
      <categories>
          
          <category> rests </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 死磕英语 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端使用html5、ffmpeg实现录屏摄像等功能</title>
      <link href="/2018/11/06/streamcapture/"/>
      <url>/2018/11/06/streamcapture/</url>
      <content type="html"><![CDATA[<p>前段时间做一个windows的桌面应用，vue + electron，涉及到录屏和摄像功能，网上相关的文档蛮少的给需要的人一些参考</p><p>如果文章描写有误或者还有更好的方法，请留言告诉我，笔芯 (´▽`ʃ♡ƪ)</p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p><strong> 涉及技术：vue、electron、ffmpeg、node </strong></p><p>关于录屏和摄像对比了两种方法</p><ul><li><p>使用HTML5的api实现</p><p>摄像：mediaDevices（获取设备）+ getUserMedia（获取流） + MediaRecorder（存储）</p><p>录屏：getDisplayMedia（获取流） + MediaRecorder（存储）</p></li><li><p>ffmpeg + node：FFmpeg是一套非常强大的音视频处理的开源工具，不多介绍，而Electron基于node和chromium，它允许使用node的API以及几乎所有的node模块，这意味这着我们可以调用cmd命令来操作ffmpeg实现录屏和摄像录制，当然ffmpeg功能绝不止这点</p></li></ul><h1 id="HTML5实现"><a href="#HTML5实现" class="headerlink" title="HTML5实现"></a>HTML5实现</h1><h2 id="mediaDevices"><a href="#mediaDevices" class="headerlink" title="mediaDevices"></a>mediaDevices</h2><ul><li><p>用于收集系统上可用的多媒体输入和输出设备的信息</p></li><li><p>该方法调用成功返回设备列表，并传入带有devceID的MediaStreamConstraints对象可以指定设备获取流媒体来源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.enumerateDevices().then(<span class="function"><span class="params">devicelist</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// audiooutput 扬声器</span></span><br><span class="line">  <span class="comment">// audioinput  麦克风</span></span><br><span class="line">  <span class="comment">// audiooutput 摄像</span></span><br><span class="line">  <span class="built_in">console</span>.log(devicelist)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><h2 id="getUserMedia"><a href="#getUserMedia" class="headerlink" title="getUserMedia"></a>getUserMedia</h2></li><li><p>用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。</p></li><li><p>该方法返回视频流，将获取到的流赋给video标签可实现边录边看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(MediaStreamConstraints).then(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">    videoElement.srcObject = stream; <span class="comment">// </span></span><br><span class="line">  &#125;, error =&gt; <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><h2 id="getDisplayMedia"><a href="#getDisplayMedia" class="headerlink" title="getDisplayMedia"></a>getDisplayMedia</h2></li><li><p>将用户的显示或其部分用作媒体流的来源，它允许以视频流的形式获取用户的显示器或其一部分</p></li><li><p>录屏主要依靠该方法，和getUserMedia一样返回一个promise对象，调用成功返回流，将这个流赋给video 元素实现边录边看</p></li><li><p><strong> 需要注意的是</strong> 如果你做的是网页端在谷歌上使用这个元素，需要在chrome://flags/开启Experimental Web Platform features功能<br><a href="https://tong-h.github.io/canvas-store/capture/index.html" target="_blank" rel="noopener">demo戳这儿</a></p><p>&emsp;&emsp;&emsp;&emsp;而Electron基于node + chromium构建，在electron需要引入desktopCapturer模块，并在基于该模块使用这个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getDisplayMedia(&#123; <span class="attr">video</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">    videoElement.srcObject = stream;</span><br><span class="line">  &#125;, error =&gt; <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><h2 id="MediaRecorder"><a href="#MediaRecorder" class="headerlink" title="MediaRecorder"></a>MediaRecorder</h2></li><li><p>记录和捕获媒体，也就是视频和音频</p></li><li><p>getDisplayMedia 和 getUserMedia 获取到的流都需要使用MediaRecorder存储起来，并且可以保存成文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> herf</span><br><span class="line"><span class="keyword">this</span>.recorder = <span class="keyword">new</span> MediaRecorder(stream);</span><br><span class="line"><span class="keyword">this</span>.recorder.ondataavailable = <span class="function"><span class="params">e</span> =&gt;</span> &#123; </span><br><span class="line">  herf = e.data;</span><br><span class="line">  download.href = URL.createObjectURL(herf);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.recorder.start();</span><br></pre></td></tr></table></figure></li></ul><h1 id="第二种使用ffmpeg"><a href="#第二种使用ffmpeg" class="headerlink" title="第二种使用ffmpeg"></a>第二种使用ffmpeg</h1><p>官网安装包下载 <a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds/</a></p><p>一些基本参数</p><ul><li>-formats                输出所有可用格式</li><li>-f fmt                  指定格式(音频或视频格式)</li><li>-i filename              指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头</li><li>-y                      覆盖已有文件</li><li>-t duration              记录时长为t</li><li>-fs limit_size          设置文件大小上限</li><li>-itsoffset time_off      设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss* [.xxx]的格式也支持<br>音 频</li><li>-ab bitrate           设置音频码率</li><li>-ar freq              设置音频采样率</li><li>-ac channels          设置通道 缺省为1<br>视 频</li><li>-b bitrate            设置比特率，缺省200kb/s</li><li>-r fps                设置帧频 缺省25</li><li>-s size               设置帧大小 格式为WXH 缺省160X128.下面的简写也可以直接使用：</li></ul><h2 id="录屏相关命令"><a href="#录屏相关命令" class="headerlink" title="录屏相关命令"></a>录屏相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列出可用的设备包括音频和摄像等等</span><br><span class="line">ffmpeg -list_devices true -f dshow -i dummy</span><br><span class="line"></span><br><span class="line">录屏，你也可以加入关于视频的一些基本参数来获得你想要的文件</span><br><span class="line">ffmpeg -f gdigrab -i desktop captrue.mkv -y</span><br></pre></td></tr></table></figure><h2 id="node调用"><a href="#node调用" class="headerlink" title="node调用"></a>node调用</h2><p>cd进入bin文件夹后执行录屏相关命令</p><p>关于停止录制，虽然ffmpeg按 Q 可以停止录制，但是我们通过代码调用是看不到cmd命令行的而且他在录制过程中是一直占用这个进程什么命令也无法输入<br>所以这个地方我只想到一个办法就是强制停止该进程</p><p>参考文章</p><p>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia</a><br>&emsp;<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder</a><br>&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/enumerateDevices" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/enumerateDevices</a></p><p>W3C <a href="https://w3c.github.io/mediacapture-screen-share/" target="_blank" rel="noopener">https://w3c.github.io/mediacapture-screen-share/</a></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端是否需要对密码进行加密传输 &amp;&amp; HTTPS</title>
      <link href="/2018/10/16/https/"/>
      <url>/2018/10/16/https/</url>
      <content type="html"><![CDATA[<p>最近学习node，写demo登陆和注册功能的时候因为要考虑后台的加密和安全所以也想了下前端的，前端传输密码的时候是否应该加密之后再传输呢<br>看了一些网站的登陆，csdn、简书等是明文传输，但腾讯、百度这些一线大站是经过前端加密的，看了些大佬的文章，顺便自己搬个凳子记个笔记</p><h1 id="前端是否需要对密码进行加密传输"><a href="#前端是否需要对密码进行加密传输" class="headerlink" title="前端是否需要对密码进行加密传输"></a>前端是否需要对密码进行加密传输</h1><p>前端的加密本身不能对网站的安全性有任何提高功能，所有的关于网站的安全技术都应该放在后台，但是这也不是完全没有意义，可以增加攻击成本，尽可能降低攻击带来的损失，毕竟丢了密文比丢了明文要强，而且犯罪分子技术参差不齐，简单的加密能够拦截很大一部分菜鸟，至于高手。。。</p><p>最后看到比较统一的是隐秘信息传输应该使用https</p><h1 id="什么是https-ssl证书又是什么"><a href="#什么是https-ssl证书又是什么" class="headerlink" title="什么是https? ssl证书又是什么"></a>什么是https? ssl证书又是什么</h1><p>这篇文章只是想弄懂流程和原理，不会去纠结具体的术语</p><p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，处在同一网络中的其它用户可以通过网络抓包来窃取和篡改数据包的内容，甚至运营商或者wifi提供者，有可能会篡改http报文，添加广告等信息以达到盈利的目的</p><p>可以通过和SSL(Secure Socket Layer，安全套接层)组合使用来为浏览器和服务器之间的通信加密。在这条加密线路上进行通信的http被称为HTTPS（HTTP Secure，超文本传输安全协议）。</p><p>SSL证书（Secure socket layer），就是遵守SSL协议，由受信任的数字证书颁发机构CA颁发，主要用来提供对用户浏览器和服务器的认证，对传送的数据进行加密和隐藏，确保数据在传送中不被改变保证数据的完整性，加密方式为「非对称加密」和「对称加密」。</p><h2 id="https的工作流程"><a href="#https的工作流程" class="headerlink" title="https的工作流程"></a>https的工作流程</h2><p>1、用户连接到你的Web站点，该Web站点受服务器证书所保护</p><p>2、你的服务器进行响应，并自动传送你网站的数字证书给用户，（浏览器内置一个受信任的机构列表和这些机构的证书）用户的浏览器查看该证书是否存在于浏览器的受信任机构列表中，并且通过服务器证书中的信息与当前正在访问的网站（域名等）是否一致来鉴别你的网站，鉴别没成功会提醒用户是否继续该访问</p><p>3、鉴别成功后，用户的浏览器产生一把唯一的会话钥匙，用以跟网站之间所有的通讯过程进行加密，会话密钥是随机生成，每次都会有不一样的结果，</p><p>4、使用者的浏览器以网站的公钥对交谈钥匙码进行加密，以便只有让你的网站得以阅读此交谈钥匙码</p><h2 id="https的优点："><a href="#https的优点：" class="headerlink" title="https的优点："></a>https的优点：</h2><p>1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>4、谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h2 id="https的缺点："><a href="#https的缺点：" class="headerlink" title="https的缺点："></a>https的缺点：</h2><p>1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%</p><p>2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>3、SSL证书需要钱，功能越强大的证书费用越高</p><p>4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名</p><p>5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>知乎各位大佬的回答 <a href="https://www.zhihu.com/question/25539382" target="_blank" rel="noopener">https://www.zhihu.com/question/25539382</a><br>HTTP与HTTPS的区别  <a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql常用语句</title>
      <link href="/2018/10/10/mysql/"/>
      <url>/2018/10/10/mysql/</url>
      <content type="html"><![CDATA[<p>sql语法特点：</p><ul><li>没有””双引号，字符串使用’’单引号包含；</li><li>没有逻辑相等，赋值和逻辑相等都是=；</li><li>类型不再是最严格的，任何数据都可以包含在’’单引号内；</li><li>没有布尔值的概念，但是在视图中可以输入true/false；</li><li>它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; !=，返回一个布尔值；</li><li>它也有逻辑运算符：！(not) &amp;&amp;(and) ||(or)；</li><li><p>它不区别大小写。</p></li><li><p>以下语句，user为表名, id,name,sex,card,phone,address为字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据库创建#</span></span><br><span class="line"><span class="string">"create database"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"drop table if exists user"</span></span><br><span class="line"><span class="comment"># 如果存在(if exists)就删除表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有(if not exists)就新增表，设置id为主键，address为外键关联address表的id字段</span></span><br><span class="line"><span class="string">"""create table if not exists user(</span></span><br><span class="line"><span class="string">    id int auto_increment primary key,</span></span><br><span class="line"><span class="string">    name varchar(5),</span></span><br><span class="line"><span class="string">    sex  char(1),</span></span><br><span class="line"><span class="string">    card  char(18),</span></span><br><span class="line"><span class="string">    phone  char(11),</span></span><br><span class="line"><span class="string">    address varchar(30),</span></span><br><span class="line"><span class="string">    foreign key(address) references address(id))"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改自增长Id,数据库新增的数据会从1000开始但是原来的数据不会改变</span></span><br><span class="line"><span class="string">"alter table user auto_increment=1000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增数据库表字段plus</span></span><br><span class="line"><span class="string">"alter table user add plus varchar(8)"</span></span><br><span class="line"><span class="comment"># --------------------------插入数据----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 数据插入时一定要注意 类型对应，数量对应，顺序对应</span></span><br><span class="line"><span class="comment"># 字符串值必须包含在''以内，赋值可以使用default,null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入单条数据，如果不列出字段名mysql会按照顺序添加</span></span><br><span class="line"><span class="string">"""insert into user(name, sex, id_card, phone, address)</span></span><br><span class="line"><span class="string">        values ('李四', '女', '511569845612354879', '10086', '太古里77号')"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插入数据</span></span><br><span class="line"><span class="string">"""insert into user(name, sex, id_card, phone, address)</span></span><br><span class="line"><span class="string">        values (%s, %s, %s, %s, %s)"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------查询数据--------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># order by 对查询结果进行排序 select 字段1,字段2,字段3 from 表名 order by 字段 desc(降序)||asc(升序)</span></span><br><span class="line"><span class="string">"select address,id from user order by id desc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重复查询 select distinct 字段 from 表名</span></span><br><span class="line"><span class="string">"select distinct address from user"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查询 limit select 字段1，字段2 from 表名 limit 初始位置，记录数</span></span><br><span class="line"><span class="string">"select id, name, sex, id_card from user limit 3,6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准查询 in 只查找括号内的数据； not in 则相反</span></span><br><span class="line"><span class="string">"select * from user where ID in (1001,1003)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准查询 between and 查找1001-1003范围内的数据；not between and 相反</span></span><br><span class="line"><span class="string">"select * from user where ID between 1001 and 1003"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊查询 like (% 代表任意字符 _ 代表单个字符)；not like相反</span></span><br><span class="line"><span class="string">"select * from user where name like '_麻%'"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件查询 and 关键字</span></span><br><span class="line"><span class="string">"select * from user where sex='女' and address='太古里77号'"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件查询 or 关键字 只需满足一个条件</span></span><br><span class="line"><span class="string">"select * from user where name='王麻子子' or address='太古里77号' "</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多表查询，两个表comment，movie</span></span><br><span class="line"><span class="comment"># 语法：select * from 表1(左表) left join 表2(右表) on 表2.字段 = 表1.字段</span></span><br><span class="line"><span class="string">"select * from comment left join movie on movie.id = comment.movieid"</span></span><br><span class="line"><span class="comment"># inner join / join单独用   返回所有匹配的行</span></span><br><span class="line"><span class="comment"># left join     不论是否匹配会返回“left join”左边表所有的行，匹配不上的字段为null</span></span><br><span class="line"><span class="comment"># right join    和left join相反，会返回右边表的所有的行</span></span><br><span class="line"><span class="comment"># full join     只要存在一条匹配就会返回两个表所有的行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------删除数据和更新数据 or,and,between and,like等关键字可以查询到多条数据然后批量删除或者更新-------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line"><span class="comment">#delete [from] 表名 where 条件</span></span><br><span class="line"><span class="string">"delete from user where name='王麻子子' or address='太古里77号'"</span></span><br><span class="line"><span class="comment"># 数据库清空</span></span><br><span class="line"><span class="string">"truncate table user"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line"><span class="string">"update user set name = '更新' where ID in (1005,1006)"</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/esofar/p/6185210.html" target="_blank" rel="noopener">https://www.cnblogs.com/esofar/p/6185210.html</a> 史上最全的MSSQL复习笔记</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nodejs之接收formdata表单</title>
      <link href="/2018/10/09/node_fromdata/"/>
      <url>/2018/10/09/node_fromdata/</url>
      <content type="html"><![CDATA[<p>最近在学习express，写一个vue+express+mysql的小demo，需要上传一张封面图和一些其他的表单字段….</p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>formdata主要用于发送表单数据，将数据编译成键值对的形式使用XMLHttpRequest来发送，一般的请求通常使用序列化的方法发送formdata格式的数据，所以formdata对象比较常见的应用场景是发送文件或者通过HTML表单创建的formdata对象用以发送表单<br><strong> 那么使用express搭建的nodejs的后台如何获取前台发送的formdata格式的数据 </strong></p><h1 id="Multer中间件"><a href="#Multer中间件" class="headerlink" title="Multer中间件"></a>Multer中间件</h1><p>Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据</p><p>首先安装并存储在packjson中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Multer 需要接受一个 options 对象，用于对文件上传时做一些控制，比如文件存储，大小限制等<br>所以在路由文件中除了引入 multer 模块还要设置 options 对象</p><ul><li><p>dest or storage: 在哪里存储文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况下只要设置 dest 属性设置文件存储的位置</span></span><br><span class="line"><span class="keyword">var</span> multer  = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">dest</span>: <span class="string">'uploads/'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">"但如果你想要设置更多,那么需要使用storage代替dest"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> storage = multer.diskStorage(&#123;<span class="comment">// 磁盘存储引擎可以让你控制文件的存储</span></span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">'/tmp/my-uploads'</span>) <span class="comment">// 文件存储路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, file.fieldname + <span class="string">'-'</span> + <span class="built_in">Date</span>.now()) <span class="comment">// 文件名称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;)</span><br></pre></td></tr></table></figure></li><li><p>fileFilter: 文件过滤器，控制哪些文件可以被接受,接收一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileFilter</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 你可以通过判断file的参数来判断这个文件是否跳过或者上传以及报错</span></span><br><span class="line">  <span class="comment">// 拒绝这个文件</span></span><br><span class="line">  cb(<span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 接受这个文件</span></span><br><span class="line">  cb(<span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 发送一个错误:</span></span><br><span class="line">  cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I don\'t have a clue!'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>limits: 限制上传的数据，接受一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"fieldNameSize"</span><span class="comment">// field 名字最大长度100 bytes</span></span><br><span class="line">  <span class="string">"fieldSize"</span><span class="comment">// field 值的最大长度1MB</span></span><br><span class="line">  <span class="string">"fields"</span><span class="comment">// 非文件 field 的最大数量无限</span></span><br><span class="line">  <span class="string">"fileSize"</span><span class="comment">// 在 multipart 表单中，文件最大长度 (字节单位)无限</span></span><br><span class="line">  <span class="string">"files"</span><span class="comment">// 在 multipart 表单中，文件最大数量无限</span></span><br><span class="line">  <span class="string">"parts"</span><span class="comment">// 在 multipart 表单中，part 传输的最大数量(fields + files)无限</span></span><br><span class="line">  <span class="string">"headerPairs"</span><span class="comment">// 在 multipart 表单中，键值对最大组数2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>.single(fieldname)接受一个参数名为fieldname的文件<br>应用场景：单个文件上传 + 一些其他的表单字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/profile'</span>, upload.single(<span class="string">'avatar'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.file 是 `avatar` 文件的信息</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据，如果存在的话</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>.array(fieldname, maxCount) 接受一个参数名为fieldname的文件数组, 可选参数maxcount限制上传的最大数量<br>应用场景：适合参数名相同的多文件上传 + 一些其他的表单字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/photos/upload'</span>, upload.array(<span class="string">'photos'</span>, <span class="number">12</span>), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.files 是 `photos` 文件数组的信息</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据，如果存在的话</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>.fields(fields) 接受一个对象数组<code>[{name:&quot;&quot;,maxCount: 1},]</code>，每个对象应该具有 name 和可选的 maxCount 属性,<br>应用场景：适合参数名不同的多文件上传 + 一些其他的表单字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cpUpload = upload.fields([&#123; <span class="attr">name</span>: <span class="string">'avatar'</span>, <span class="attr">maxCount</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'gallery'</span>, <span class="attr">maxCount</span>: <span class="number">8</span> &#125;])</span><br><span class="line">app.post(<span class="string">'/cool-profile'</span>, cpUpload, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.files 是一个对象 (String -&gt; Array) 键是文件名，值是文件数组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 例如：</span></span><br><span class="line">  <span class="comment">//  req.files['avatar'][0] -&gt; File</span></span><br><span class="line">  <span class="comment">//  req.files['gallery'] -&gt; Array</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据，如果存在的话</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>.none() 只接受文本域</p></li><li><p>.any() 接受一切。文件数组将保存在 req.files。</p></li></ul><h1 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h1><p>在demo中的应用场景，很简单的单张图片上传+其他表单字段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">"multer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> storage = multer.diskStorage(&#123; </span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span>(<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">"img"</span>); </span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span>(<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// Multer 不会为你添加任何扩展名，所以完整的名字需要我们自己拼接</span></span><br><span class="line">    cb(<span class="literal">null</span>, <span class="built_in">Date</span>.now() + <span class="string">"."</span> + file.originalname.split(<span class="string">"."</span>)[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> limits = &#123; </span><br><span class="line">  files: <span class="number">1</span>, <span class="comment">// 只接收一个文件</span></span><br><span class="line">  fileSize: <span class="number">2097152</span> <span class="comment">// 文件大小不超过2m </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileFilter</span>(<span class="params">req, file, cb</span>) </span>&#123; <span class="comment">// 文件类型判断</span></span><br><span class="line">  file.mimetype.split(<span class="string">"/"</span>)[<span class="number">0</span>] === <span class="string">"image"</span> ? cb(<span class="literal">null</span>, <span class="literal">true</span>) : cb(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> upload = multer(&#123;</span><br><span class="line">  storage: storage,</span><br><span class="line">  fileFilter: fileFilter,</span><br><span class="line">  limits: limits</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/insert"</span>, upload.single(<span class="string">"img"</span>), (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    res.json(req.body);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>req.file获取到的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fieldname: <span class="string">'img'</span>,  <span class="comment">// 表单字段名称</span></span><br><span class="line">originalname: <span class="string">'1.png'</span>, <span class="comment">// 上传时在用户电脑上的名称</span></span><br><span class="line">encoding: <span class="string">'7bit'</span>, <span class="comment">// 文件编码</span></span><br><span class="line">mimetype: <span class="string">'image/png'</span>, <span class="comment">// 文件类型</span></span><br><span class="line">destination: <span class="string">'/'</span>, <span class="comment">// 接受后的保存路径</span></span><br><span class="line">filename: <span class="string">'img-1539066538986'</span>, <span class="comment">// 保存在 destination 中的文件名</span></span><br><span class="line">path: <span class="string">'\\img-1539066538986'</span>, <span class="comment">// 已上传文件的完整路径</span></span><br><span class="line">size: <span class="number">80419</span>  <span class="comment">// size</span></span><br></pre></td></tr></table></figure></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>express文档 <a href="http://www.expressjs.com.cn/4x/api.html#req.body" target="_blank" rel="noopener">http://www.expressjs.com.cn/4x/api.html#req.body</a><br>multer文档 <a href="https://github.com/expressjs/multer/blob/master/README.md" target="_blank" rel="noopener">https://github.com/expressjs/multer/blob/master/README.md</a></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nodejs使用cors跨域</title>
      <link href="/2018/09/28/node_cors/"/>
      <url>/2018/09/28/node_cors/</url>
      <content type="html"><![CDATA[<p>相关文章：<a href="https://tong-h.github.io/2017/12/01/Nginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F/" target="_blank" rel="noopener">Nginx的反向代理跨域</a></p><p>最近在学习express，遇到了跨域问题….</p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）<br>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><h1 id="预检请求？"><a href="#预检请求？" class="headerlink" title="预检请求？"></a>预检请求？</h1><p>我自己在设置跨域的时候碰到的很多报错其实都是因为预检请求</p><p><strong> cors将请求场景分为 简单请求 和 非简单请求 </strong></p><p>简单请求：</p><ul><li>使用的方法是GET，HEAD，POST这三种之一</li><li>Content-Type 的值是text/plain、 multipart/form-data、 application/x-www-form-urlencoded 这三种之一</li></ul><p>那么浏览器检测到该请求非简单请求，会先发送一个预检请求到服务器，以获知服务器是否允许该实际请求</p><p>服务器会从预检请求拿到的以下3个信息去和服务器的Response的header对比，来决定是否允许该请求</p><ul><li>Access-Control-Request-Method ：实际请求的方法</li><li>Access-Control-Request-Headers：实际请求所携带的请求header字段</li><li>origin：实际请求的源站，域名</li></ul><h1 id="服务器header使用字段"><a href="#服务器header使用字段" class="headerlink" title="服务器header使用字段"></a>服务器header使用字段</h1><h2 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h2><p><strong> 必填字段，值：一个域名， *(表示接受任意域名的请求)，也可以读取请求headers中的origin字段 </strong></p><p>如果请求的源与该字段不符合服务器会返回一个正常的HTTP回应，状态码可能为200，但不会包含Access-Control-开头的Origin、Credentials、Headers3个字段，浏览器发现，回应的头信息没有包含Access-Control-Allow-Origin字段就会抛出一个错误，会被XMLHttpRequest的onerror回调函数捕获</p><h2 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a>Access-Control-Request-Method</h2><p><strong> 可选字段，表明服务器支持的所有跨域请求的方法 </strong></p><p>如果你用到除了HEAD，GET，POST之外的方法那么这个字段为必填</p><h2 id="Access-Control-Allow-Credentials-可选字段"><a href="#Access-Control-Allow-Credentials-可选字段" class="headerlink" title="Access-Control-Allow-Credentials 可选字段"></a>Access-Control-Allow-Credentials 可选字段</h2><p><strong> 该字段若存在便只能为true，表示服务器许可Cookie可以包含在请求中一起发给服务器 </strong></p><p>对于某些浏览器即使服务器为true，有时候也需要前端设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>若为true Access-Control-Allow-Origin字段便不能为*，必须明确指定域名，Cookie遵循同源政策，只有用服务器域名设置的Cookie才会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h2 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h2><p><strong> 可选字段，设置Response的额外发送的header字段 </strong></p><p>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</p><p>如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p><h2 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h2><p><strong> 设置预警请求的结果能够被缓存多久，单位为秒 </strong></p><h1 id="express如何使用cors跨域"><a href="#express如何使用cors跨域" class="headerlink" title="express如何使用cors跨域"></a>express如何使用cors跨域</h1><p>在express种使用cors跨域是需要使用第三方模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save cors</span><br></pre></td></tr></table></figure></p><p>在app.js中写入以下设置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例代码</span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>,<span class="string">"Origin, X-Requested-With, Content-Type, Accept"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, req.headers.origin);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>HTTP访问控制（CORS） <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue cli 3.0初体验</title>
      <link href="/2018/09/20/vue3.0/"/>
      <url>/2018/09/20/vue3.0/</url>
      <content type="html"><![CDATA[<p><a href="https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf" target="_blank" rel="noopener">尤雨溪：Vue 3.0 计划</a> 原文需翻墙<br><a href="https://juejin.im/post/5bb719b9f265da0ab915dbdd" target="_blank" rel="noopener">尤雨溪：Vue 3.0 计划</a> 掘金译文</p><h1 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h1><p>Vue CLI 的包名称由 vue-cli 改成了 @vue/cli<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">安装完成后查看版本</span><br><span class="line">vue --V</span><br></pre></td></tr></table></figure></p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>关于项目创建，除了命令创建3.x还增加了<strong>图形化界面创建以及管理vue项目</strong><br>在创建新项目时还可以<strong>混合选用多种集成</strong></p><ul><li>TypeScript</li><li>PWA</li><li>Vue Router &amp; Vuex</li><li>ESLint / TSLint / Prettier</li><li>用 Jest 或 Mocha 进行单元测试</li><li>用 Cypress 或者 Nightwatch 进行 E2E 测试</li></ul><h2 id="使用命令创建"><a href="#使用命令创建" class="headerlink" title="使用命令创建"></a>使用命令创建</h2><p>命令：vue create vueapp</p><p>1、使用上下箭头选择默认设置还是手动选择功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.0.3</span><br><span class="line">? Please pick a preset:</span><br><span class="line">  default (babel, eslint)</span><br><span class="line">&gt; Manually select features</span><br></pre></td></tr></table></figure></p><p>2、按空格键选择你需要的功能，选完后按回车<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">babel：javascript转译器，将最新版的js语法（es6、es7）转换为现阶段浏览器可以兼容的js代码</span><br><span class="line">typescript：使用 TypeScript 书写源码</span><br><span class="line">PWA：渐进式WEB应用</span><br><span class="line">Router：使用vue-router</span><br><span class="line">Vuex：使用vuex</span><br><span class="line">CSS Pre-processors：css预处理器</span><br><span class="line">Linter / Formatter：代码规范标准</span><br><span class="line">Unit Testing：单元测试</span><br><span class="line">E2E Testing：e2e测试</span><br><span class="line">Vue CLI v3.0.3</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project:</span><br><span class="line"> (*) Babel</span><br><span class="line"> ( ) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> (*) Router</span><br><span class="line"> (*) Vuex</span><br><span class="line">&gt;(*) CSS Pre-processors</span><br><span class="line"> (*) Linter / Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing</span><br></pre></td></tr></table></figure></p><p>3、router是否使用history模式，history需要服务器支持详，情请看这儿<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a><br>这里我就选no</p><p>4、css预处理器的选择，我习惯用sass</p><p>5、代码格式化检测选择，我用的是ide是vscode个人感觉搭配插件用着很舒服，所以我选Prettier</p><p>6、是否保存刚才的配置，下一次就不用重新配置了，我就直接回车</p><p>7、关于Babel, PostCSS, ESLint, etc.这些配置文件你是想放在package.json里面还是单独放在外面<br>编辑器一般默认会在项目根目录下寻找配置文件，这里我就直接回车选择In dedicated config files</p><p>8、是否保存为未来项目的预配置吗，我也是直接回车</p><p>最后配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3.0.3</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter</span><br><span class="line">? Use history mode for router? (Requires proper server setup for index fallback in production) No</span><br><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS</span><br><span class="line">? Pick a linter / formatter config: Prettier</span><br><span class="line">? Pick additional lint features: Lint on save</span><br><span class="line">? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files</span><br><span class="line">? Save this as a preset for future projects? Yes</span><br></pre></td></tr></table></figure></p><h2 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h2><p>图形化操作非常方便，我就不一步步演示了，主要懒得贴图 (°ー°〃)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行npm命令</span><br><span class="line">vue ui</span><br><span class="line">访问 http://localhost:8000 你就可以创建，管理，导入项目</span><br></pre></td></tr></table></figure></p><h1 id="实用新功能"><a href="#实用新功能" class="headerlink" title="实用新功能"></a>实用新功能</h1><ul><li>node_modules</li><li>public</li><li>src</li><li>.browserslistrc</li><li>.eslintrc.js</li><li>.gitignore</li><li>babel.config.js</li><li>package.json</li><li>postcss.config.js</li><li>README.md</li></ul><p>以上是项目根目录，3.x对比2.x文件结构明显精简了不少，多了一个public文件夹用于存放静态文件少了config、build等一系列的配置文件，这些配置文件都被放在了node_modules\@vue文件下</p><h2 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h2><p>根目录中多了一个.browserslist文件，可以指定项目的目标浏览器的范围<br>用于转译的 JavaScript 特性和添加CSS 浏览器前缀，可以减少兼容代码提高代码质量<br>如果想少一个文件，你也可以在package.json中添加browserslist字段，参数是一个数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是默认设置，兼容所有最新版本，不支持ie8以下</span><br><span class="line">&gt; 1%</span><br><span class="line">last 2 versions</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure></p><p>使用 npx browserslist 可以查看项目的浏览器兼容情况<br>将需要支持的目标浏览器参数放在文件中就好</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&gt; 1%</td><td style="text-align:center">全球超过1%人使用的浏览器</td></tr><tr><td style="text-align:center">&gt; 5% in US</td><td style="text-align:center">使用美国使用情况统计，接受两个字母的<a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements" target="_blank" rel="noopener">国家/地区代码</a></td></tr><tr><td style="text-align:center">&gt; 5% in my stats</td><td style="text-align:center">使用<a href="https://github.com/browserslist/browserslist#custom-usage-data" target="_blank" rel="noopener">自定义使用数据</a></td></tr><tr><td style="text-align:center">last 2 versions</td><td style="text-align:center">所有浏览器兼容到最后两个版本根据CanIUse.com追踪的版本</td></tr><tr><td style="text-align:center">Firefox ESR</td><td style="text-align:center">火狐最新版本</td></tr><tr><td style="text-align:center">Firefox &gt; 20</td><td style="text-align:center">指定版本范围</td></tr><tr><td style="text-align:center">not ie &lt;=8</td><td style="text-align:center">方向排除部分版本</td></tr><tr><td style="text-align:center">Firefox 12.1</td><td style="text-align:center">指定浏览器版本</td></tr><tr><td style="text-align:center">since 2013</td><td style="text-align:center">2013年之后发布的所有版本</td></tr></tbody></table><p>更多请查看官方文档</p><h2 id="vue-cli服务"><a href="#vue-cli服务" class="headerlink" title="vue-cli服务"></a>vue-cli服务</h2><p>在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。<br>你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令<br> Vue CLI 项目有三个模式： development 模式用于启动，production 模式用于打包和e2e测试，test 模式用于unit测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">serve:vue-cli-service serve</span><br><span class="line"></span><br><span class="line">  --open    在服务器启动时打开浏览器</span><br><span class="line"></span><br><span class="line">  --copy    在服务器启动时将 URL 复制到剪切版</span><br><span class="line"></span><br><span class="line">  --mode    指定环境模式 (默认值：development)</span><br><span class="line"></span><br><span class="line">  --host    指定 host (默认值：0.0.0.0)</span><br><span class="line"></span><br><span class="line">  --port    指定 port (默认值：8080)</span><br><span class="line"></span><br><span class="line">  --https   使用 https (默认值：false)</span><br><span class="line"></span><br><span class="line">打包</span><br><span class="line">build:vue-cli-service build</span><br><span class="line"></span><br><span class="line">  --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。</span><br><span class="line"></span><br><span class="line">  --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。</span><br><span class="line"></span><br><span class="line">  --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">   test: vue-cli-service test:e2e  端到端测试</span><br><span class="line">         vue-cli-service test:unit  单元测试</span><br></pre></td></tr></table></figure></p><h2 id="现代模式"><a href="#现代模式" class="headerlink" title="现代模式"></a>现代模式</h2><p>为了兼容那些不支持js新特性的浏览器我们需要Babel转译，但转译后的代码笨重冗长，这次3.x提供了一个现代模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx vue-cli-service build --modern</span><br></pre></td></tr></table></figure></p><p>这个命令会产生两个应用的版本：一个现代版的包，面向支持 ES modules 的现代浏览器，另一个旧版的包，面向不支持的旧浏览器<br>而且不需要我们手动去部署和设置什么，简直很贴心</p><ul><li>现代版的包会通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 在被支持的浏览器中加载；它们还会使用 <code>&lt;link rel=&quot;modulepreload&quot;&gt;</code> 进行预加载</li><li>旧版的包会通过 <code>&lt;script nomodule&gt;</code> 加载，并会被支持 ES modules 的浏览器忽略</li><li>一个针对 Safari 10 中 <code>&lt;script nomodule&gt;</code> 的修复会被自动注入<h2 id="插件的添加"><a href="#插件的添加" class="headerlink" title="插件的添加"></a>插件的添加</h2>在一个已经被创建好的项目中安装一个插件,使用vue add命令<h2 id="CLI-插件安装"><a href="#CLI-插件安装" class="headerlink" title="CLI 插件安装"></a>CLI 插件安装</h2>每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件<br>对于这种cli插件需要加入@vue的前缀，这个命令将 @vue/eslint 解析为完整的包名 @vue/cli-plugin-eslint，然后从 npm 安装它，调用它的生成器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">插件添加</span><br><span class="line">vue add @vue/eslint</span><br><span class="line"></span><br><span class="line">向被安装的插件传递生成器选项 (这样做会跳过命令提示)</span><br><span class="line">vue add @vue/eslint --config airbnb --lintOn save</span><br></pre></td></tr></table></figure></li></ul><h2 id="第三方插件安装"><a href="#第三方插件安装" class="headerlink" title="第三方插件安装"></a>第三方插件安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装并调用 vue-cli-plugin-apollo，不带 @vue 前缀，该命令会换作解析一个 unscoped 的包</span><br><span class="line">执行此命令后src里会创建一个plugins文件夹，里面会自动生成关于插件的配置文件</span><br><span class="line">vue add axios</span><br><span class="line"></span><br><span class="line">基于一个指定的 scope 使用第三方插件，如果一个插件名为 @foo/vue-cli-plugin-bar，你可以这样添加它：</span><br><span class="line">vue add @foo/bar</span><br></pre></td></tr></table></figure><h1 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h1><p>例：向所有 Sass 样式传入共享的全局变量<br>在根目录新建一个vue.config.js，加入以下配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      <span class="comment">// 给 sass-loader 传递选项</span></span><br><span class="line">      sass: &#123;</span><br><span class="line">        <span class="comment">// @/ 是 src/ 的别名</span></span><br><span class="line">        <span class="comment">// 所以这里假设你有 `src/variables.scss` 这个文件</span></span><br><span class="line">        data: <span class="string">`@import "@/variables.scss";`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="打包后路径问题"><a href="#打包后路径问题" class="headerlink" title="打包后路径问题"></a>打包后路径问题</h1><p>在vue.config.js文件种加入’baseUrl: ‘./‘’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    baseUrl: &apos;./&apos;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然官方说这个文件会被 @vue/cli-service 自动加载，但如果你启动项目用的是npm run serve，那么你最好使用npx vue-cli-service serve重启一下</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>官方文档 <a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/</a><br>browserslist的github <a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">https://github.com/browserslist/browserslist</a><br><a href="https://mp.weixin.qq.com/s/hfr2Q3FXZFIdqM_r8HrLwQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hfr2Q3FXZFIdqM_r8HrLwQ</a></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cordova之HybirdApp热更新</title>
      <link href="/2018/08/30/cordova_%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/08/30/cordova_%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h1 id="关于热更新"><a href="#关于热更新" class="headerlink" title="关于热更新"></a>关于热更新</h1><p>热更新App常用的更新方式。简单来说，就是在用户通过App Store下载App之后，打开App时遇到的即时更新</p><p>热更新就是动态下发代码，它可以使开发者在不发布新版本的情况下，修复 BUG 和发布功能，也可以绕开App Store和各种商店的审核机制，避免长时间的审核等待以及多次被拒造成的成本，也能针对顽固用户进行强制更新</p><h1 id="关于插件"><a href="#关于插件" class="headerlink" title="关于插件"></a>关于插件</h1><p>cordova插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova plugin add cordova-hot-code-push-plugin --save</span><br></pre></td></tr></table></figure></p><p>添加Cordova Hot Code Push Plugin CLI客户端<a href="https://github.com/nordnet/cordova-hot-code-push-cli" target="_blank" rel="noopener">github文档链接</a><br>用处：自动生成Hot Code Push插件（chcp.json和chcp.manifest）所需的配置文件<br>&emsp;运行本地服务器检测内容变更部署到服务器（关于自动部署看到有大佬说因为国内网络问题。。。但是我没试过因为没有aws服务器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cordova-hot-code-push-cli</span><br></pre></td></tr></table></figure></p><h1 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h1><p>1、根据Update method的设置（后面会提到改配置，假设是resume）恢复应用程序（从后台移动到前台状态）或启动时</p><p>2、插件初始化，在后台加载更新模块（Update loader）</p><p>3、Update loader 从cordova项目配置文件config.xml中获取config-file也就是插件配置文件chcp.json 的加载路径，然后加载chcp.json获取到release 版本号，对比当前的版本号，若二者不同，说明有新版本</p><p>4、有新版本时Update loader会从chcp.json中获取rcontent_url并从中下载web静态文件</p><h1 id="自动化更新"><a href="#自动化更新" class="headerlink" title="自动化更新"></a>自动化更新</h1><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><p>插件添加成功后在项目根目录执行init命令进行初始化生成配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova-hcp init</span><br></pre></td></tr></table></figure></p><p>执行时会需要填写一些首选项除了第一个project name项目名称和最后一个为必填以外其他都可以回车<br><strong> 最后一个参数 </strong> “Enter full URL to directory where cordova-hcp build result will be uploaded:”这个是服务器的url，也就是更新时app从服务器下载资源的路径</p><p><strong> 关于倒数第二个参数 </strong> ：Update method - 何时执行更新，默认为resume</p><ul><li>start - 启动应用程序时安装更新</li><li>resume - 恢复应用程序（从后台移动到前台状态）或启动时安装更新</li><li>now - 从服务器加载后立即安装更新</li></ul><p>执行成功后可以看到项目根目录多出一个cordova-hcp.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;dzbp&quot;,   // 项目名称</span><br><span class="line">  &quot;ios_identifier&quot;: &quot;&quot;,   // android</span><br><span class="line">  &quot;android_identifier&quot;: &quot;&quot;,   //  App Store上的应用程序ID。用于将用户重定向到商店的应用程序页面。</span><br><span class="line">  &quot;update&quot;: &quot;resume&quot;, // 在Google Play上引用应用的应用包名称</span><br><span class="line">  &quot;content_url&quot;: &quot;https：//www&quot;  // web静态资源在服务器的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、构建命令"><a href="#2、构建命令" class="headerlink" title="2、构建命令"></a>2、构建命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova-hcp build [Web项目路径不指定默认为www目录]</span><br></pre></td></tr></table></figure><p>执行完成后会在你的web目录下会生成两个配置文件</p><ul><li>chcp.json : 持有发布相关信息</li><li>chcp.manifest : 保存有关Web项目文件的信息：它们的名称（相对路径）和哈希值, 根据它插件查知道文件的增删改</li></ul><h2 id="3、修改配置"><a href="#3、修改配置" class="headerlink" title="3、修改配置"></a>3、修改配置</h2><p>在config配置中加入chcp.json文件在服务器的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;chcp&gt;</span><br><span class="line">    &lt;config-file url=&quot;http://www/chcp.json&quot;/&gt;</span><br><span class="line">&lt;/chcp&gt;</span><br></pre></td></tr></table></figure></p><p>最后使用<code>cordova build</code>打包</p><p>app的配置就完成了，每次代码修改后只需要把代码放到服务器上，app会自动检测</p><h1 id="用户选择性进行更新？"><a href="#用户选择性进行更新？" class="headerlink" title="用户选择性进行更新？"></a>用户选择性进行更新？</h1><p>在项目配置文件config.xml中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">chcp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auto-download</span> <span class="attr">enabled</span>=<span class="string">"false"</span> /&gt;</span> // 取消自动下载</span><br><span class="line">    <span class="tag">&lt;<span class="name">auto-install</span> <span class="attr">enabled</span>=<span class="string">"false"</span> /&gt;</span>  // 取消自动安装</span><br><span class="line">    <span class="tag">&lt;<span class="name">config-file</span> <span class="attr">url</span>=<span class="string">"http://120.24.77.175:8080/ehospital/views/MSUI/chcp.json"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">chcp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="下面是一个完整的代码示例，用到了3个api"><a href="#下面是一个完整的代码示例，用到了3个api" class="headerlink" title="下面是一个完整的代码示例，用到了3个api"></a>下面是一个完整的代码示例，用到了3个api</h2><p><strong> chcp.fetchUpdate(Callback，options)  检查更新 </strong></p><ul><li>Callback接收两个参数：<br>&emsp;error：若存在不为null表示没有更新版本，或者在更新检查期间发生错误<br>&emsp;data：从本机端发送的其他数据</li><li>options：请求的其他选项。如果未设置 - 使用首选项config.xml</li></ul><p><strong> chcp.isUpdateAvailableForInstallation(Callback) 检查是否已加载更新并可以安装 </strong></p><ul><li>Callback接收两个参数：<br>&emsp;&emsp;error：若存在不为null表示没有加载更新或者无需安装<br>&emsp;&emsp;data：{<br>&emsp;&emsp;&emsp;&emsp;CURRENTVERSION：当前版本<br>&emsp;&emsp;&emsp;&emsp;readyToInstallVersion：准备安装版本<br>&emsp;&emsp;}</li></ul><p><strong> chcp.installUpdate(Callback) 检查是否已加载更新并可以安装 </strong></p><ul><li>Callback只有一个参数那就是error，若不为null表示安装失败包含失败信息否则便是成功</li></ul><p><a href="https://github.com/nordnet/cordova-hot-code-push/wiki/Error-codes" target="_blank" rel="noopener">错误代码详情</a>&emsp;&emsp;<a href="https://github.com/nordnet/cordova-hot-code-push/wiki/JavaScript-module" target="_blank" rel="noopener">jsAPI</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"deviceready"</span>, onDeviceReady, <span class="literal">false</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onDeviceReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chcp = <span class="built_in">window</span>.chcp</span><br><span class="line">    chcp.fetchUpdate(<span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123; <span class="comment">// 检查更新</span></span><br><span class="line">    alert(data)</span><br><span class="line">    <span class="keyword">if</span> (error) &#123; </span><br><span class="line">      alert(<span class="string">'error'</span>, error.code, error.description) <span class="comment">// 表示没有更新版本，或者其他错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> chcp.isUpdateAvailableForInstallation(<span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123; <span class="comment">// 检查是否已加载更新并准备安装</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          alert(<span class="string">'No update was loaded =&gt; nothing to install'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">window</span>.confirm(<span class="string">'检测到新版本，是否更新'</span>) ) &#123;</span><br><span class="line">            chcp.installUpdate(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;  <span class="comment">// 安装更新</span></span><br><span class="line">              <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                alert(<span class="string">'Failed to install the update with error code: '</span> + error.code)</span><br><span class="line">                alert(error.description)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">'Update installed!'</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.alert(<span class="string">'您已拒绝更新'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          alert(<span class="string">'Current content version: '</span> + data.currentVersion)</span><br><span class="line">          alert(<span class="string">'Ready to be installed:'</span> + data.readyToInstallVersion)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>Cordova Hot Code Push Plugin CLI client <a href="https://github.com/nordnet/cordova-hot-code-push-cli" target="_blank" rel="noopener">https://github.com/nordnet/cordova-hot-code-push-cli</a></p><p>cordova-hot-code-push wiki <a href="https://github.com/nordnet/cordova-hot-code-push/wiki/Update-workflow" target="_blank" rel="noopener">https://github.com/nordnet/cordova-hot-code-push/wiki/Update-workflow</a></p><p>Cordova 代码热更新 <a href="https://www.jianshu.com/p/55fd5e9f96ea" target="_blank" rel="noopener">https://www.jianshu.com/p/55fd5e9f96ea</a></p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cordova之相机拍照以及本地图片获取上传</title>
      <link href="/2018/08/27/cordova_%E5%9B%BE%E7%89%87%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0/"/>
      <url>/2018/08/27/cordova_%E5%9B%BE%E7%89%87%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">图片获取</span><br><span class="line">此插件定义了一个全局navigator.camera对象，该对象提供用于拍摄照片和从系统图像库中选择图像的API</span><br><span class="line">支持平台：Android、BlackBerry、Browser、Firefox、FireOS、iOS、Windows、WP8、Ubuntu</span><br><span class="line">cordova plugin add cordova-plugin-camera</span><br><span class="line"></span><br><span class="line">图片上传</span><br><span class="line">这个插件定义了全局FileTransfer，FileUploadOptions构造函数，用于传输文件</span><br><span class="line">看你上传的方式如果你使用bs64就可以不用这个插件</span><br><span class="line">支持平台：Amazon Fire OS、Android、BlackBerry 10、Browser、Firefox OS**、iOS、Windows Phone 7 and 8*、Windows</span><br><span class="line">cordova plugin add cordova-plugin-file-transfer</span><br></pre></td></tr></table></figure><h1 id="camera-getPicture官方文档"><a href="#camera-getPicture官方文档" class="headerlink" title="camera.getPicture官方文档"></a>camera.getPicture<a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-camera/index.html" target="_blank" rel="noopener">官方文档</a></h1><p>camera.getPicture 功能打开设备的默认相机应用程序接受三个参数：调用成功的回调，失败的回调，以及调用方法需要设置的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">navigator.camera.getPicture(Success, <span class="built_in">Error</span>, Options)</span><br><span class="line">imageFile () &#123;</span><br><span class="line">  navigator.camera.getPicture(success, error, &#123; <span class="attr">quality</span>: <span class="number">50</span>,</span><br><span class="line">    destinationType: Camera.DestinationType.DATA_URL, <span class="attr">sourceType</span>:<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">imageURI</span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">JSON</span>.stringify(imageURI))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">JSON</span>.stringify(message))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h2><p>这里只列举了一些常用的 api，而且某些参数在不同平台表现会有差异，建议你去官方文档查看更详细的参数</p><p>quality：默认 50，保存图像的质量，表示为 0-100 的范围，其中 100 通常为全分辨率，不会因文件压缩而丢失。</p><p>destinationType：调用成功的返回值格式</p><p>DATA_URL（返回 base64 编码的字符串）、FILE_URI（文件 url）、NATIVE_URI（原生 url）</p><p>sourceType：图片来源</p><p>PHOTOLIBRARY(从图片库中选择图片（与 SAVEDPHOTOALBUM for Android 相同）)</p><p>CAMERA(相机拍照)</p><p>SAVEDPHOTOALBUM(从图片库中选择图片（与 Android 的 PHOTOLIBRARY 相同）)</p><p>Direction: 摄像头是前置还是后置，这个当然是 PictureSourceType 等于 CAMERA 时有效</p><p>BACK（前置） FRONT（后置）</p><p>saveToPhotoAlbum：拍照后将图像是否保存到设备上的相册中，返回 boolean</p><p>correctOrientation：拍照时是否旋转图像以校正设备的方向，返回 boolean</p><p>EncodingType：图片格式，可选 JPEG 或者 JPEG</p><p>MediaType：能否选择视频或者其他媒体类型，默认只能选择图片</p><p>popoverOptions：仅限 iOS 的选项，用于在从 iPad 的库或相册中选择图像时指定弹出框的锚元素位置和箭头方向</p><h1 id="FileTransfer官方文档"><a href="#FileTransfer官方文档" class="headerlink" title="FileTransfer官方文档"></a>FileTransfer<a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-file-transfer/index.html" target="_blank" rel="noopener">官方文档</a></h1><p>分为上传和下载</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>options：可选参数（Object）<br>  fileKey：表单元素的名称。默认为file<br>  fileName：在服务器上保存文件时使用的文件名。默认为image.jpg<br>  httpMethod：要使用的HTTP方法 - PUT或者POST。默认为POST<br>  mimeType：要上载的数据的mime类型。默认为image/jpeg<br>  params：一组可选的键/值对，用于传递HTTP请求。（对象，键/值 - DOMString）<br>  chunkedMode：是否以分块流模式上传数据。默认为true。（布尔）<br>  headers：标题名称/标题值的映射。使用数组指定多个值。在iOS，FireOS和Android上，如果存在名为Content-Type的标题，则不会使用多部分表单数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ft = <span class="keyword">new</span> FileTransfer()</span><br><span class="line">ft.upload(fileURL,<span class="built_in">encodeURI</span>(<span class="string">"http://some.server.com/upload.php"</span>), successCallback, errorCallback, options)</span><br><span class="line">参数：文件地址，上传接口，成功回调，失败回调，上传需设置的可选参数</span><br></pre></td></tr></table></figure></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ft = <span class="keyword">new</span> FileTransfer();</span><br><span class="line">fileTransfer.download(uri, fileURL,successCallback successCallback, errorCallback,<span class="literal">false</span>,&#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Authorization"</span>: <span class="string">"Basic dGVzdHVzZXJuYW1lOnRlc3RwYXNzd29yZA=="</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">参数：服务器url，设备上文件的文件系统URL，成功回调，失败回调，上传需设置的可选参数，是否接受所有安全证书，可选参数目前只支持header</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cordova获取设备信息以及sim卡MSISDN等信息</title>
      <link href="/2018/08/24/cordova_%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
      <url>/2018/08/24/cordova_%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/</url>
      <content type="html"><![CDATA[<p><img src="http://cordova.axuer.com/static/img/cordova_bot.png" alt="示例图片"></p><h1 id="设备信息获取"><a href="#设备信息获取" class="headerlink" title="设备信息获取"></a>设备信息获取</h1><p>支持平台：Android、Browser、iOS、Windows、OSX<br>这是cordova官方插件，附上<a href="https://www.npmjs.com/package/cordova-plugin-sim" target="_blank" rel="noopener">官方文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插件安装</span><br><span class="line">cordova plugin add cordova-plugin-device</span><br></pre></td></tr></table></figure></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"deviceready"</span>, onDeviceReady, <span class="literal">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onDeviceReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(device.cordova) <span class="comment">// 当前cordova的版本</span></span><br><span class="line">        alert(device.model) <span class="comment">// 设备的模型或产品名称</span></span><br><span class="line">        alert(device.platform)  <span class="comment">// 获取操作系统</span></span><br><span class="line">        alert(device.uuid) <span class="comment">// 设备通用唯一标识uuid</span></span><br><span class="line">        alert(device.version) <span class="comment">// 操作系统版本</span></span><br><span class="line">        alert(device.isVirtual) <span class="comment">// 判断设备是否在虚拟机上运行,返回Boolean</span></span><br><span class="line">        alert(device.serial)  <span class="comment">// 设备序列号</span></span><br><span class="line">        alert(device.serial)  <span class="comment">// 设备制造商</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="sim卡信息获取"><a href="#sim卡信息获取" class="headerlink" title="sim卡信息获取"></a>sim卡信息获取</h1><p>支持平台：Android、iOS、Windows Phone 7 and 8<br>附上<a href="https://www.npmjs.com/package/cordova-plugin-sim" target="_blank" rel="noopener">npm文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插件安装</span><br><span class="line">cordova plugin add cordova-plugin-sim</span><br></pre></td></tr></table></figure></p><h2 id="使用方法，更多参数查看文档"><a href="#使用方法，更多参数查看文档" class="headerlink" title="使用方法，更多参数查看文档"></a>使用方法，更多参数查看文档</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"deviceready"</span>, onDeviceReady, <span class="literal">false</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onDeviceReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.plugins.sim.getSimInfo(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        alert(res.carrierName) <span class="comment">// 供应商 (SPN)</span></span><br><span class="line">        alert(res.countryCode) <span class="comment">// ISO 国家代码[中国是CN]</span></span><br><span class="line">        alert(res.mcc) <span class="comment">// 移动信号国家码</span></span><br><span class="line">        alert(res.mnc) <span class="comment">// 移动网络号码</span></span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'error'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="关于MSISDN获取"><a href="#关于MSISDN获取" class="headerlink" title="关于MSISDN获取"></a>关于MSISDN获取</h2><p>sim插件的phoneNumber这个获取MSISDN（手机号码）的参数还有deviceId、simSerialNumber、subscriptionId等等，官方文档表示了有时只能拿到一个空字符串</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>MSISDN可以存储在SIM卡上，但大部分电话运营商都不会将MSISDN存储在SIM卡上，有以下一些原因：<br>  动态MSISDN分配：首次使用预付费SIM时，有时会为其分配MSISDN。这意味着网络具有可用的MSISDN池，并在新的预付费SIM上线时分配它们。这意味着当SIM卡出厂时，它们还没有MSISDN，这意味着在发送SIM卡之前无法存储MSISDN。有些网络在一段时间不活动后会过期’MSISDN分配，特别是当它们的可用数量不足时，并将这些数字返回到可用池。<br>  移动号码可携带性：一些国家/地区允许移动用户保留其MSISDN但更改网络。这意味着MSISDN将从用于1个网络的SIM移动到用于另一个网络的SIM。</p><p>因此SIM上的MSISDN条目通常为空，用户可以在SIM卡上存储MSISDN或者任意数字<br>所以MSISDN通常为空，但如果你获取到了也是因为用户在设备中设置“我的电话号码”什么的所以也并不保证一定正确</p><p>可能的方法：通过WAP / WEB，当移动运营商在标题中包含MSISDN时（你可以做一些webview技巧来查看标题是通过的 - 但是你只看到这些如果是网络支持它，如果用户在移动数据上 - 即如果用户在WiFi上，它将无法工作</p><p>来源:<a href="https://stackoverflow.com/questions/10695601/msisdn-is-it-a-sim-card-data-why-all-the-provided-function-from-blackberry-a" target="_blank" rel="noopener">https://stackoverflow.com/questions/10695601/msisdn-is-it-a-sim-card-data-why-all-the-provided-function-from-blackberry-a</a></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown语法(备忘)</title>
      <link href="/2018/08/23/markdown/"/>
      <url>/2018/08/23/markdown/</url>
      <content type="html"><![CDATA[<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特殊符号使用 \ 转义，例 \* \# \&gt;</span><br></pre></td></tr></table></figure><h2 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h2><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#bb1509" size="4" face="黑体">color=#0099ff size=72 face=”黑体”</font><br><font color="#bb1509" size="72">color=#00ffff</font><br><font color="gray" size="72">color=gray</font><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>我是黑体字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span>我是微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span>我是华文彩云<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff size=72 face="黑体"<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=#00ffff<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span>color=gray<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535269125851&amp;di=5b30256aeac0e1016d165ded3ccaa568&amp;imgtype=0&amp;src=http%3A%2F%2Fnote.youdao.com%2Fiyoudao%2Fwp-content%2Fuploads%2F2016%2F09%2F8881.jpg" alt="示例图片"></p><p><a href="https://www.appinn.com/markdown/index.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>半方大的空白&ensp;或&#8194;<br>全方大的空白&emsp;或&#8195;<br>不断行的空白格&nbsp;或&#160;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半方大的空白&amp;ensp;或&amp;#8194;</span><br><span class="line">全方大的空白&amp;emsp;或&amp;#8195;</span><br><span class="line">不断行的空白格&amp;nbsp;或&amp;#160;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">少量代码使用 ` 一个反引号包裹</span><br><span class="line">多行代码使用三个反引号包裹</span><br></pre></td></tr></table></figure><p>使用三个反引号包裹并指定语言</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><h1 id="1号"><a href="#1号" class="headerlink" title="1号"></a>1号</h1><h2 id="2号"><a href="#2号" class="headerlink" title="2号"></a>2号</h2><h3 id="3号"><a href="#3号" class="headerlink" title="3号"></a>3号</h3><h4 id="4号"><a href="#4号" class="headerlink" title="4号"></a>4号</h4><h5 id="5号"><a href="#5号" class="headerlink" title="5号"></a>5号</h5><h6 id="6号"><a href="#6号" class="headerlink" title="6号"></a>6号</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1号</span><br><span class="line">## 2号</span><br><span class="line">### 3号</span><br><span class="line">#### 4号</span><br><span class="line">##### 5号</span><br><span class="line">###### 6号</span><br></pre></td></tr></table></figure><h2 id="字体着重"><a href="#字体着重" class="headerlink" title="字体着重"></a>字体着重</h2><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h2 id="字体缩进"><a href="#字体缩进" class="headerlink" title="字体缩进"></a>字体缩进</h2><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三个以上的 - 或者 * ,效果一样</span><br><span class="line">***</span><br></pre></td></tr></table></figure><hr><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 图片引用</span><br><span class="line"></span><br><span class="line">``` text</span><br><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表</li></ul><p>1.列表内容<br>2.列表内容<br>3.列表内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无序列表，使用- + *效果一样</span><br><span class="line">- 列表</span><br><span class="line">+ 列表</span><br><span class="line">* 列表</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：符号跟内容之间要有一个空格</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>表头</th><th style="text-align:center">表头</th><th style="text-align:right">表头</th></tr></thead><tbody><tr><td>内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr><tr><td>内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">| 左对齐标题 | 右对齐标题 | 居中对齐标题 |</span><br><span class="line">| :------| ------: | :------: |</span><br><span class="line"></span><br><span class="line">表格内换行使用 &lt;/br&gt; 标签</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于hexo的常用命令(备忘)</title>
      <link href="/2018/08/22/hexo/"/>
      <url>/2018/08/22/hexo/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://hexo.io/zh-cn/api/" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &apos;远程仓库&apos; themes/ &apos;本地文件名称&apos;</span><br><span class="line">hexo s 启动服务</span><br><span class="line">hexo clean  清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo g  部署之前预先生成静态文件</span><br><span class="line">hexo d  部署</span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; 新建一篇文章</span><br><span class="line">hexo new draft &lt;title&gt;  新建一篇草稿</span><br><span class="line">hexo publish &lt;title&gt; 将草稿移入posts文件夹</span><br><span class="line"></span><br><span class="line">图片上传插件</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line"></span><br><span class="line">代码上传到github所需要的依赖包</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>hexo部署报错：The file will have its original line endings in your working directory.</p><ul><li>删除.deploy_git文件夹</li><li>运行 git config –global core.autocrlf false</li><li>正常流程 hexo clean / hexo g / hexo d</li></ul>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫之selenium自动化测试让你爬虫更像用户</title>
      <link href="/2018/08/22/python_selenium/"/>
      <url>/2018/08/22/python_selenium/</url>
      <content type="html"><![CDATA[<p>全程序自动化操作<br><img src="/2018/08/22/python_selenium/selenium.gif" alt="demo效果"></p><p>先科普一下selenium，这是一个用于Web应用程序测试的工具，支持多种浏览器多种语言</p><p>框架底层使用JavaScript模拟真实用户对浏览器进行操作，Selenium测试直接运行在浏览器中，代码执行时，可以自动打开浏览器/表单输入/按钮点击，就像真实用户在操作的一样</p><p>真真是反爬虫的一大神器啊</p><p>先附上文档了解一些基础知识：<a href="https://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">官方文档</a><a href="https://selenium-python-zh.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">中文文档</a></p><h1 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd命令：pip3 install selenium</span><br></pre></td></tr></table></figure><p>下载谷歌驱动安装：<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a> </p><p>放在谷歌文件夹C:\Program Files (x86)\Google\Chrome\Application下再把这路径加入环境变量</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><em>Xpath是非常强大的元素查找方式，它可以定位到页面上的任意元素</em></p><p>我这里只介绍了一些今天这个实例会用到的</p><h2 id="首先先了解一下它的一些语法"><a href="#首先先了解一下它的一些语法" class="headerlink" title="首先先了解一下它的一些语法"></a><em>首先先了解一下它的一些语法</em></h2><p>// ： 相对路径，以这个开头表示从寻找文档的根节点开始查找元素，若出现在xpath路径中则表示寻找父节点下任意符合条件的子节点，不管嵌套了多少层级<br>/：绝对路径，表示寻找父节点下的第一层子元素也就是直接子元素<br>“//标签名[@属性名=’属性值’]”：表示从根目录查找和标签名、属性值相匹配的元素<br>几乎所有的Xpath路径都是以上面3种方法来组合的</p><h2 id="精准定位"><a href="#精准定位" class="headerlink" title="精准定位"></a>精准定位</h2><p>以下面这个百度文库这段html举例</p><p><img src="http://pe5zctnu4.bkt.clouddn.com/selenium.PNG" alt="shili"></p><p>要获取输入框怎么写，写法不只一种哈，这地方你也可以直接使用input的id获取元素（一个页面正常来讲不会有相同的id）</p><p>input = browser.find_element(By.XPATH, “//form[@name=’ftop’]//input[@id=’kw’]”)</p><p>上面这行是用的是find_element是查找单个元素，api在下面可以先看下</p><p>表示从根目录查找第一个匹配路径 name为flop的form标签 ，找到这个元素之后再去他所有子元素里面查找id为kw的input框</p><p>假设这个页面有两个name为ftop的form标签（name一样的form标签讲道理一个页面是不会有两个现在只是假设，有可能你会遇到class名一样的div标签）</p><p>那么获取第二个form标签：”//form[@name=’ftop’][2]//input[@id=’kw’]”, 就在大括号后面加上他的索引，索引是从1开始的</p><h2 id="模糊定位"><a href="#模糊定位" class="headerlink" title="模糊定位"></a>模糊定位</h2><p>contains关键字：input = browser.find_element(By.XPATH, “//input[contains(@id, ‘kw’)]”)<br>表示寻找页面中id属性值包含kw所有input元素</p><p>text关键字：input = browser.find_element(By.XPATH, “//button[contains(text(), ‘搜索’)]”)<br>表示寻找页面中文字中包含有搜索的所有button元素</p><p>starts-with关键字：input = browser.find_element(By.XPATH, “//a[starts-with(@href,’http://‘)]”)<br>表示寻找页面中href属性以http://开头的a标签</p><p>ends-with关键字：input = browser.find_element(By.XPATH, “//a[ends-with(@href,’com’)]”)<br>表示寻找页面中href属性以’com’结尾的a标签<br>关于ends-widh我在使用的时候会报错提示语法不正确而且网上关于ends-with介绍也很少所以我没有找到原因如果大家知道欢迎留言告诉我不胜感激 (´▽`ʃ♡ƪ)</p><p><em>这是一个简单的关于用selenium和xpath来做模糊查询的小实例</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()</span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开百度网址</span></span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个http链接</span></span><br><span class="line"></span><br><span class="line">element_contains = browser.find_element(By.XPATH, <span class="string">"//a[contains(@href, 'http://')]"</span>)</span><br><span class="line"></span><br><span class="line">print(element_contains.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个包含文字中包含'地图'的a标签</span></span><br><span class="line">element_text = browser.find_element(By.XPATH, <span class="string">"//a[contains(text(), '地图')]"</span>)</span><br><span class="line"></span><br><span class="line">print(element_text.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个文字以'贴'开头的a标签</span></span><br><span class="line">element_starts = browser.find_element(By.XPATH, <span class="string">"//a[starts-with(text(), '贴')]"</span>)</span><br><span class="line"></span><br><span class="line">print(element_starts.text)</span><br><span class="line"></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><h2 id="selenium的一些常用api"><a href="#selenium的一些常用api" class="headerlink" title="selenium的一些常用api"></a>selenium的一些常用api</h2><p><em>find_element和find_elements的使用</em></p><p>browser.find_element(By.XPATH, ‘//button[text()=”Some text”]’)  //单个元素获取</p><p>browser.find_elements(By.XPATH, ‘//button’) //多个元素获取</p><p>ID = “id”<br>XPATH = “xpath”<br>LINK_TEXT = “link text”<br>PARTIAL_LINK_TEXT = “partial link text”<br>NAME = “name”<br>TAG_NAME = “tag name”<br>CLASS_NAME = “class name”<br>CSS_SELECTOR = “css selector”</p><p><em>单个元素选取（多个元素选取：就是在element后面加一个s，比如find_elements_by_id）：</em></p><p>find_element_by_id<br>find_element_by_name<br>find_element_by_xpath<br>find_element_by_link_text<br>find_element_by_partial_link_text<br>find_element_by_tag_name<br>find_element_by_class_name<br>find_element_by_css_selector</p><p><em>获取到标签之后的界面交互：</em></p><p>input.send_keys(“输入中”)<br>input.clear()  清空输入框<br>button.click()  按钮点击</p><p><em>常用的控制浏览器的api：</em></p><p>browser.back() 浏览器后退<br>browser.forward() 浏览器前进<br>browser.get(“<a href="https://www.zhihu.com/explore&quot;" target="_blank" rel="noopener">https://www.zhihu.com/explore&quot;</a>) 打开页面<br>browser.execute_script(“alert(‘To Button’)”)  执行js代码<br>print(browser.window_handles) 所有的标签<br>browser.switch_to_window(browser.window_handles[1]) 切换到指定标签页<br>browser.close() 关闭当前标签页</p><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><h2 id="关于页面模块引入"><a href="#关于页面模块引入" class="headerlink" title="关于页面模块引入"></a>关于页面模块引入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入浏览器驱动</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们需要引入浏览器内核才可以使用浏览器的无头模式，这里我引入的是chrome</span></span><br><span class="line"><span class="comment"># Gecko：是Firefox浏览器的内核</span></span><br><span class="line"><span class="comment"># Trident：是IE浏览器的内核</span></span><br><span class="line"><span class="comment"># Blink：是webkit的一个分支版本，由google开发</span></span><br><span class="line"><span class="comment"># 关于什么是无头模式：即headless browser，是一种没有界面的浏览器，主要是用作爬虫，用以捕捉Web上的各类数据</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要用于使用两个私有方法find_element和find_elements</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用键盘api</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于时间延迟</span></span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><h2 id="功能代码"><a href="#功能代码" class="headerlink" title="功能代码"></a>功能代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()</span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开页面</span></span><br><span class="line">browser.get(<span class="string">"https://wenku.baidu.com/"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取搜索输入框</span></span><br><span class="line">input = browser.find_element(ID, <span class="string">'kw'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入内容</span></span><br><span class="line">input.send_keys(<span class="string">"IT/计算机"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟回车</span></span><br><span class="line">input.send_keys(Keys.ENTER) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取'我知道了'按钮</span></span><br><span class="line">btn = browser.find_element(By.XPATH, <span class="string">"//div[@class='new-filter-box fc5']//span[@class='btn-know']"</span>)</span><br><span class="line"></span><br><span class="line">btn.click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 时间延迟</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击列表的第一条数据</span></span><br><span class="line">btn = browser.find_element(By.XPATH, <span class="string">"//div[@class='main']//dl[1]//a[1]"</span>)</span><br><span class="line"></span><br><span class="line">btn.click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将browser页面切换至当前页面</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭当前页面</span></span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换至第一个页面</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击列表的第二条数据</span></span><br><span class="line">btn = browser.find_element(By.XPATH, <span class="string">"//div[@class='main']//dl[2]//a[1]"</span>)</span><br><span class="line"></span><br><span class="line">btn.click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图切换至第一个页面</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去往百度页面</span></span><br><span class="line">browser.get(<span class="string">"https://baidu.com/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有标签</span></span><br><span class="line">print(browser.window_handles)</span><br></pre></td></tr></table></figure><p>开启无头模式<br>只需要修改一行代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cordova定位 + 仿钉钉打卡功能</title>
      <link href="/2018/08/20/cordova_%E5%AE%9A%E4%BD%8D/"/>
      <url>/2018/08/20/cordova_%E5%AE%9A%E4%BD%8D/</url>
      <content type="html"><![CDATA[<p>最近在研究hybridApp，使用vue+cordova，现在需要实现一个钉钉打卡的功能<br>大致要实现这4个需求：地图显示、定位、地图覆盖效果、距离测量</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>定位相对而言比较复杂所以优先考虑，关于定位，我尝试了3种办法</p><p>第一个尝试了cordova自带的插件，结果是报错：code：2，message：network provider is not available，原因是新版的插件已经删掉了关于Android版定位的代码，改为基于系统浏览器(chrome内核)进行定位，但经测试发现因为国内网络原因根本无法定位</p><p>第二个是用的高德地图的JavaScript API，定位虽然成功但是定位和实际位置有几百米的误差这个肯定不行</p><p>第三个是用的cordova的baidumaplocation插件，误差在几十米之间还可以接受</p><p>首先附上<a href="https://github.com/aruis/cordova-plugin-baidumaplocation" target="_blank" rel="noopener">插件github的连接</a></p><p>第一步你得先去<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="noopener">百度</a>创建一个应用</p><h2 id="创建android应用签名文件-查看SHA1"><a href="#创建android应用签名文件-查看SHA1" class="headerlink" title="创建android应用签名文件/查看SHA1"></a>创建android应用签名文件/查看SHA1</h2><p>开发版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .android 进入  C:\Users\FLTD-Y01\.android&gt;</span><br><span class="line"></span><br><span class="line">调试版本使用debug.keystore，命令为：keytool -list -v -keystore debug.keystore。</span><br><span class="line"></span><br><span class="line">提示输入密钥库密码，调试版本默认密码是: android</span><br></pre></td></tr></table></figure></p><p>发布版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立签名文件</span><br><span class="line">$ keytool -genkey -v -keystore key.keystore -alias key -keyalg RSA -validity 365</span><br></pre></td></tr></table></figure></p><p>回车后会让你输入名字公司什么的，按照提示继续就好</p><p>执行完成后会在文件夹内创建一个key.keystore的签名文件</p><p>然后就能够看到md5、SHA1什么的了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看签名信息</span><br><span class="line">$ keytool -list -v -keystore key.keystore</span><br></pre></td></tr></table></figure><h2 id="安装baidumaplocation插件"><a href="#安装baidumaplocation插件" class="headerlink" title="安装baidumaplocation插件"></a>安装baidumaplocation插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装baidumaplocation插件</span><br><span class="line">$ cordova plugin add cordova-plugin-baidumaplocation --variable ANDROID_KEY=&quot;你的key&quot; --variable IOS_KEY=&quot;value&quot; --save</span><br><span class="line"> 只需要Android端或者IOS端，可以只填写一个相应的key，另外一个你还是得填点什么，不然你懂的</span><br></pre></td></tr></table></figure><h2 id="炒鸡简单的用法上代码"><a href="#炒鸡简单的用法上代码" class="headerlink" title="炒鸡简单的用法上代码"></a>炒鸡简单的用法上代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ baidumap_location.getCurrentPosition (<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">$   <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result))</span><br><span class="line">$ &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">$   <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(error))</span><br><span class="line">$ &#125;)</span><br></pre></td></tr></table></figure><p>温馨提示：只有在手机上才能获取比较准确的信息，所以最好真机测试</p><h2 id="地图显示、覆盖物效果、距离计算"><a href="#地图显示、覆盖物效果、距离计算" class="headerlink" title="地图显示、覆盖物效果、距离计算"></a>地图显示、覆盖物效果、距离计算</h2><p>除了定位以外的其他功能我都用的是JavaScript API</p><p>那么第一步是去<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="noopener">百度</a>创建一个浏览器端类型的应用</p><p>然后你会得到一个key，然后在index引用百度地图API文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=您的密钥"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="最后上代码"><a href="#最后上代码" class="headerlink" title="最后上代码"></a>最后上代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">that.bmap = <span class="keyword">new</span> BMap.Map(<span class="string">"allmap"</span>) <span class="comment">// 新建地图实例</span></span><br><span class="line"><span class="keyword">let</span> location = <span class="keyword">new</span> BMap.Point(enterprise1, enterprise2) <span class="comment">// 新建坐标，参数为企业坐标</span></span><br><span class="line">that.bmap.centerAndZoom(location, <span class="number">16</span>) <span class="comment">//设置企业坐标为中心点坐标</span></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> BMap.Circle(location, <span class="number">500</span>, &#123;<span class="attr">strokeColor</span>:<span class="string">"blue"</span>, <span class="attr">strokeWeight</span>:<span class="number">2</span>, <span class="attr">strokeOpacity</span>:<span class="number">0.5</span>&#125;) <span class="comment">// 创建地图圆形覆盖效果</span></span><br><span class="line">that.bmap.addOverlay(circle)  <span class="comment">// 增加效果 </span></span><br><span class="line"><span class="keyword">let</span> pointB = <span class="keyword">new</span> BMap.Point(result.longitude, result.latitude) <span class="comment">// 新建点坐标，参数为定位获取到的坐标</span></span><br><span class="line"><span class="built_in">console</span>.log((that.bmap.getDistance(location, pointB)).toFixed(<span class="number">2</span>)) <span class="comment">// 计算距离，小于500可以打卡，反之则是超出范围</span></span><br></pre></td></tr></table></figure><h2 id="关于报错"><a href="#关于报错" class="headerlink" title="关于报错"></a>关于报错</h2><p>如果Android版获取到的信息是：<br>{<br>    “locType”: 505,<br>    “locTypeDescription”: “NetWork location failed because baidu location service check the key is unlegal, please check the key in AndroidManifest.xml !”,<br>    “latitude”: 5e-324,<br>    “longitude”: 5e-324,<br>    “radius”: 0,<br>    “userIndoorState”: -1,<br>    “direction”: -1<br>}<br>这个坑我是踩了，不管你信息是否获取成功过，只要出现了上面的信息就说明Key有问题</p><ul><li>检查第一步创建的百度Android应用</li><li>检查下生成的AndroidManifest.xml文件里面是否有如下信息<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:enabled=<span class="string">"true"</span> android:name=<span class="string">"com.baidu.location.f"</span> android:process=<span class="string">":remote"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/service&gt;</span></span><br><span class="line"><span class="regexp">&lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="abcdefghijklmn" /</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><p>然后重新安装</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue+ECharts4.x地图下钻/散点分布以及热力图</title>
      <link href="/2018/08/15/vue_ECharts4-x/"/>
      <url>/2018/08/15/vue_ECharts4-x/</url>
      <content type="html"><![CDATA[<p>最近用到了echarts，实现三个功能国家到省级的地图下钻和散点分布以及热力图显示</p><p>网上资料蛮少的，记录一个给后面的小伙伴一些参考</p><h1 id="demo效果如下"><a href="#demo效果如下" class="headerlink" title="demo效果如下"></a>demo效果如下</h1><p>中国地图下显示为热力图，显示精确分布点只是demo所以数据是自己写的假数据只有几条<br>点击进入省份地图，在地图之外还有那个小箭头是数据的原因不是bug改下数据就好<br><img src="/2018/08/15/vue_ECharts4-x/map.gif" alt="demo效果"></p><p>先上官网<a href="http://echarts.baidu.com/option.html#title，表白echarts，文档真的很详细，良心官网" target="_blank" rel="noopener">http://echarts.baidu.com/option.html#title，表白echarts，文档真的很详细，良心官网</a></p><p>demo代码如下<br>下钻到市级县级道理也是如此<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">mapfun(name)&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.chartNum)</span><br><span class="line">      <span class="comment">// 注意文件路径 </span></span><br><span class="line">      <span class="keyword">this</span>.$http.get(<span class="string">'static/province/'</span>+name+<span class="string">'.json'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; </span><br><span class="line">        echarts.registerMap(name, res.body)</span><br><span class="line">        <span class="keyword">let</span> data = [];</span><br><span class="line">        res.body.features.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            data.push(&#123;</span><br><span class="line">                name:item.properties.name</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.chartNum !== <span class="number">1</span> ? <span class="keyword">this</span>.myChart.dispose() : <span class="string">''</span>  <span class="comment">// 创建新实例之前一定要销毁上一个实例，否则重复多次点击无数的实例导致内存爆满</span></span><br><span class="line">        <span class="keyword">this</span>.chartNum++</span><br><span class="line">        <span class="keyword">this</span>.myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'myChart'</span>))</span><br><span class="line">        <span class="keyword">this</span>.myChart.showLoading()</span><br><span class="line">        <span class="keyword">this</span>.myChart.setOption(&#123;</span><br><span class="line">          title: &#123; <span class="comment">// 标题</span></span><br><span class="line">            text: <span class="string">"分布图"</span>,</span><br><span class="line">            left: <span class="string">"center"</span>,</span><br><span class="line">            padding: <span class="number">30</span>,</span><br><span class="line">            textStyle: &#123;</span><br><span class="line">              color: <span class="string">"#fff"</span>,</span><br><span class="line">              fontSize: <span class="string">"30"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          visualMap: &#123; <span class="comment">// 热力图颜色显示</span></span><br><span class="line">            <span class="keyword">default</span>:<span class="string">'piecewise '</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">5</span>,</span><br><span class="line">            calculable:<span class="literal">true</span>,</span><br><span class="line">            textStyle:&#123;</span><br><span class="line">              color: <span class="string">'#fef420'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            inRange: &#123;</span><br><span class="line">                color: [<span class="string">'#fef420'</span>, <span class="string">'#df383e'</span>,<span class="string">'#379fdf'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          geo: [&#123; <span class="comment">// 地图</span></span><br><span class="line">            type: <span class="string">'map'</span>,  </span><br><span class="line">            map: name,  <span class="comment">// 地区名字，重要参数</span></span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                areaColor: <span class="string">"#d7bed9"</span>,</span><br><span class="line">                borderColor: <span class="string">"#111"</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            emphasis: &#123;</span><br><span class="line">              label:&#123;</span><br><span class="line">                show: <span class="literal">false</span></span><br><span class="line">              &#125;,</span><br><span class="line">              itemStyle: &#123;</span><br><span class="line">                areaColor: <span class="string">"#f5d4f8"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: data,  <span class="comment">// 数据，重要参数</span></span><br><span class="line">            label: &#123;    <span class="comment">// 标签的显示</span></span><br><span class="line">              normal: &#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">              emphasis: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;],</span><br><span class="line">          series: [&#123; <span class="comment">// 散点分布</span></span><br><span class="line">              roam: <span class="literal">true</span>,</span><br><span class="line">              type: name === <span class="string">'china'</span> ? <span class="string">"heatmap"</span> : <span class="string">"scatter"</span>, <span class="comment">// 中国地图下显示热力图，省级地图下显示精确分布点</span></span><br><span class="line">              coordinateSystem: <span class="string">"geo"</span>,</span><br><span class="line">              data: [[<span class="string">'116.347927'</span>, <span class="string">'39.948795'</span>, <span class="number">100</span>],</span><br><span class="line">                    [<span class="string">'100.06376'</span>, <span class="string">'30.554698'</span>, <span class="number">75</span>],</span><br><span class="line">                    [<span class="string">'104.05325'</span>, <span class="string">'29.646273'</span>, <span class="number">50</span>],[<span class="string">'104.05325'</span>, <span class="string">'25.646273'</span>, <span class="number">25</span>],[<span class="string">'94.05325'</span>, <span class="string">'30.646273'</span>, <span class="number">1</span>]],</span><br><span class="line">              blurSize: <span class="number">20</span>,</span><br><span class="line">              symbolSize: <span class="number">20</span>,</span><br><span class="line">              symbol: <span class="string">'arrow'</span>,  </span><br><span class="line">              minOpacity: <span class="number">0.1</span>,</span><br><span class="line">              maxOpacity: <span class="number">1</span>,</span><br><span class="line">          &#125;]</span><br><span class="line">          </span><br><span class="line">        &#125;) </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">           <span class="keyword">this</span>.myChart.hideLoading()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">this</span>.myChart.on(<span class="string">'click'</span>, params =&gt; &#123; <span class="comment">// 点击函数</span></span><br><span class="line">          name === <span class="string">'china'</span> ? <span class="keyword">this</span>.mapfun(params.name) : <span class="keyword">this</span>.mapfun(<span class="string">'china'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python操作mysql/mysql增删查改语句</title>
      <link href="/2018/08/09/python_mysql/"/>
      <url>/2018/08/09/python_mysql/</url>
      <content type="html"><![CDATA[<h1 id="PyMySQL安装-方法介绍"><a href="#PyMySQL安装-方法介绍" class="headerlink" title="PyMySQL安装/方法介绍"></a>PyMySQL安装/方法介绍</h1><p>PyMySQL是由python编写的，速度上比不上 MySQLdb，但是他安装非常方便同时也兼容 MySQL-python</p><p>pip install pymssql</p><h1 id="基本方法介绍"><a href="#基本方法介绍" class="headerlink" title="基本方法介绍"></a>基本方法介绍</h1><p>close():关闭此connect对象<br>commit():提交当前事务<br>rollback():取消当前事务<br>cursor():创建游标对象</p><h2 id="关于游标"><a href="#关于游标" class="headerlink" title="关于游标"></a>关于游标</h2><p>游标是一段私有的SQL工作区,也就是一段内存区域,用于暂时存放受SQL语句影响到的数据。通俗理解就是将受影响的数据暂时放到了一个内存区域的虚表中，而这个虚表就是游标。</p><p>也就是说在commit之前你操作的都是这个游标，操作错误你可以使用rollback()方法回滚，如果在增删改之后没有commit所有操作都是白搭</p><h2 id="操作游标的方法"><a href="#操作游标的方法" class="headerlink" title="操作游标的方法"></a>操作游标的方法</h2><p>close():关闭此游标对象<br>fetchone():得到结果集的下一行<br>fetchmany([size = cursor.arraysize]):得到结果集的下几行<br>fetchall():得到结果集中剩下的所有行<br>excute(sql[, args]):执行一个数据库查询或命令<br>excutemany(sql, args):执行多个数据库查询或命令</p><h1 id="现在上代码"><a href="#现在上代码" class="headerlink" title="现在上代码"></a>现在上代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="comment"># 连接mysql</span></span><br><span class="line"><span class="comment"># host为数据库的主机IP地址, port为MySQL的默认端口号, user为数据的用户名, password为数据库的登录密码, db为数据库的名称</span></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'root'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    <span class="string">'database'</span>: <span class="string">'reptiledata'</span></span><br><span class="line">&#125;</span><br><span class="line">db = pymysql.connect(**config)</span><br><span class="line">cursor = db.cursor() <span class="comment"># 建立游标对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------表操作----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 如果存在就删除表</span></span><br><span class="line">cursor.execute(<span class="string">"drop table if exists user"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增表</span></span><br><span class="line">cursor.execute(<span class="string">"""create table if not exists user(</span></span><br><span class="line"><span class="string">                  id int auto_increment primary key,</span></span><br><span class="line"><span class="string">                  name varchar(5),</span></span><br><span class="line"><span class="string">                  sex  char(1),</span></span><br><span class="line"><span class="string">                  id_card  char(18),</span></span><br><span class="line"><span class="string">                  phone  varchar(14),</span></span><br><span class="line"><span class="string">                  address  varchar(12),</span></span><br><span class="line"><span class="string">                  create_time time)"""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改自增长Id,数据库新增的数据会从1000开始但是原来的数据不会改变</span></span><br><span class="line">cursor.execute(<span class="string">'alter table user AUTO_INCREMENT=1000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增数据库表字段</span></span><br><span class="line">cursor.execute(<span class="string">'alter table user add plus varchar(8)'</span>)</span><br><span class="line"><span class="comment"># --------------------------插入数据-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 批量插入数据</span></span><br><span class="line">cursor.execute(<span class="string">'alter table user drop plus'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入单条数据但因为后面用了db.rollback()回滚，所以此条数据不会被添加</span></span><br><span class="line">cursor.execute(<span class="string">"""insert into user(name, sex, id_card, phone, address)</span></span><br><span class="line"><span class="string">        values ('李四', '女', '511569845612354879', '10086', '数据不会被添加')"""</span>)</span><br><span class="line">db.rollback() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插入数据，如果不列出字段名mysql会按照顺序添加</span></span><br><span class="line">sql = <span class="string">"""insert into user(name, sex, id_card, phone, address)</span></span><br><span class="line"><span class="string">        values (%s, %s, %s, %s, %s)"""</span></span><br><span class="line">sql_data = [[<span class="string">'张三'</span>, <span class="string">'女'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里77号'</span>],</span><br><span class="line">            [<span class="string">'李四'</span>, <span class="string">'男'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里77号'</span>],</span><br><span class="line">            [<span class="string">'王麻子子'</span>, <span class="string">'男'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里66号'</span>],</span><br><span class="line">            [<span class="string">'张二'</span>, <span class="string">'女'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里77号'</span>],</span><br><span class="line">            [<span class="string">'李五'</span>, <span class="string">'男'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里88号'</span>],</span><br><span class="line">            [<span class="string">'王麻子'</span>, <span class="string">'女'</span>, <span class="string">'511569845612354879'</span>, <span class="string">'10086'</span>, <span class="string">'太古里99号'</span>]]</span><br><span class="line">cursor.executemany(sql, sql_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------查询数据-----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># order by 对查询结果进行排序 select 字段1,字段2,字段3 from 表名 order by 字段 desc(降序)||asc(升序)</span></span><br><span class="line">cursor.execute(<span class="string">"select address,id from user order by id desc"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重复查询 select distinct 字段 from 表名</span></span><br><span class="line">cursor.execute(<span class="string">"select distinct address from user"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查询 limit select 字段1，字段2 from 表名 limit 初始位置，记录数</span></span><br><span class="line">cursor.execute(<span class="string">"select id, name, sex, id_card from user limit 3,6"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准查询 in 只查找括号内的数据； not in 则相反</span></span><br><span class="line">cursor.execute(<span class="string">"select * from user where ID in (1001,1003)"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准查询 between and 查找1001-1003范围内的数据；not between and 相反</span></span><br><span class="line">cursor.execute(<span class="string">"select * from user where ID between 1001 and 1003"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊查询 like (% 代表任意字符 _ 代表单个字符)；not like相反</span></span><br><span class="line">cursor.execute(<span class="string">"select * from user where name like '_麻%'"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件查询 and 关键字</span></span><br><span class="line">cursor.execute(<span class="string">"select * from user where sex='女' and address='太古里77号'"</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件查询 or 关键字 只需满足一个条件</span></span><br><span class="line">cursor.execute(<span class="string">"select * from user where name='王麻子子' or address='太古里77号' "</span>)</span><br><span class="line">select = cursor.fetchall()</span><br><span class="line">print(select)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------删除数据和更新数据 or,and,between and,like等关键字可以查询到多条数据然后批量删除或者更新-----------------------------------</span></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">cursor.execute(<span class="string">"delete from user where name='王麻子子' or address='太古里77号'"</span>)</span><br><span class="line"><span class="comment"># 数据库清空</span></span><br><span class="line">cursor.execute(<span class="string">"truncate table user"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line">cursor.execute(<span class="string">"update user set name = '更新' where ID in (1005,1006)"</span>)</span><br><span class="line"></span><br><span class="line">cursor.close()  <span class="comment"># 关闭游标对象</span></span><br><span class="line">db.commit()  <span class="comment"># 提交操作</span></span><br><span class="line">db.close()  <span class="comment"># 关闭数据库</span></span><br></pre></td></tr></table></figure><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mpvue小程序以及微信直播踩坑总结</title>
      <link href="/2018/08/07/mpvue/"/>
      <url>/2018/08/07/mpvue/</url>
      <content type="html"><![CDATA[<p>前段时间刚写完一个mpvue的小程序，现在得闲必须赶紧记录和总结一下，不然很多东西又要忘了</p><p>我是比较熟悉vue的语法，但是也犹豫过是用原生还是用mpvue，因为那时候原生小程序已经相当成熟而mpvue才刚出来（踩坑和填坑的前人还很少）</p><p>所以我学习了几天原生的框架和语法，果断选择了mpvue，真的是没有对比就没有伤害，对比原生体验不要太好</p><p>mpvue是一个使用 Vue.js 开发小程序的前端框架，他是将我们写的vue文件重新编译成wxml等文件，最后的底层实现还是用的小程序语法，所以原生小程序语法也是比较重要的，而且像很多下拉刷新，到底部请求下一页什么的等等很多地方也是要用到小程序api的，所以建议大家在入坑之前还是了解一些小程序语法比较好</p><p>附上<a href="http://mpvue.com/#_1" target="_blank" rel="noopener">官方文档</a></p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>使用官方的5分钟上手，生成一个基本框架，后来开发也没有手动修改过他的配置</p><p>用到了4个插件</p><h2 id="mpvue-weui-ui库，相当方便轻量好使"><a href="#mpvue-weui-ui库，相当方便轻量好使" class="headerlink" title="mpvue-weui    ui库，相当方便轻量好使"></a>mpvue-weui    ui库，相当方便轻量好使</h2><p>官网地址：<a href="http://kuangpf.com/mpvue-weui/#/" target="_blank" rel="noopener">http://kuangpf.com/mpvue-weui/#/</a></p><h2 id="mpvue-toast-一个基于mpvue的简单弹窗组件"><a href="#mpvue-toast-一个基于mpvue的简单弹窗组件" class="headerlink" title="mpvue-toast  一个基于mpvue的简单弹窗组件"></a>mpvue-toast  一个基于mpvue的简单弹窗组件</h2><p>因为mpvue目前还不支持全局的组件，所以没有办法像vue组件引入一次就能在所有页面使用，但是mpvue团队已经在考虑新增全局组件功能了</p><p>github地址：<a href="https://github.com/linrui1994/mpvue-toast" target="_blank" rel="noopener">https://github.com/linrui1994/mpvue-toast</a> </p><h2 id="sass-不多介绍"><a href="#sass-不多介绍" class="headerlink" title="sass  不多介绍"></a>sass  不多介绍</h2><p>全局安装：npm install sass-loader node-sass –save-dev </p><p>在style节点加上lang=”scss”，这样就可以愉快地使用sass进行开发了</p><h2 id="mpvue-router-patch-在mpvue-中使用-vue-router-兼容的路由写法"><a href="#mpvue-router-patch-在mpvue-中使用-vue-router-兼容的路由写法" class="headerlink" title="mpvue-router-patch   在mpvue 中使用 vue-router 兼容的路由写法"></a>mpvue-router-patch   在mpvue 中使用 vue-router 兼容的路由写法</h2><p>当知道mpvue不支持vue-router的时候我还是非常难受，还好mpvue团队后面发布了这个插件，非常简单好用</p><p>github地址：<a href="https://github.com/F-loat/mpvue-router-patch" target="_blank" rel="noopener">https://github.com/F-loat/mpvue-router-patch</a></p><p>接下来的3个插件我没有用过但是和mpvue-router-patch一样是mpvue团队发布的，感觉应该也不差，也推荐给大家如果需要可以花时间了解一下</p><h2 id="mpvue-echarts-适用于-Mpvue-的-ECharts-组件"><a href="#mpvue-echarts-适用于-Mpvue-的-ECharts-组件" class="headerlink" title="mpvue-echarts    适用于 Mpvue 的 ECharts 组件"></a>mpvue-echarts    适用于 Mpvue 的 ECharts 组件</h2><p>github地址：<a href="https://github.com/F-loat/mpvue-echarts" target="_blank" rel="noopener">https://github.com/F-loat/mpvue-echarts</a></p><h2 id="微信小程序富文本解析组件-适用于-Mpvue-的微信小程序富文本解析自定义组件"><a href="#微信小程序富文本解析组件-适用于-Mpvue-的微信小程序富文本解析自定义组件" class="headerlink" title="微信小程序富文本解析组件  适用于 Mpvue 的微信小程序富文本解析自定义组件"></a>微信小程序富文本解析组件  适用于 Mpvue 的微信小程序富文本解析自定义组件</h2><p>github地址：<a href="https://github.com/F-loat/mpvue-wxParse" target="_blank" rel="noopener">https://github.com/F-loat/mpvue-wxParse</a></p><h2 id="mpvue-entry自动生成各页面的入口文件-集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新"><a href="#mpvue-entry自动生成各页面的入口文件-集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新" class="headerlink" title="mpvue-entry自动生成各页面的入口文件  集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新"></a>mpvue-entry自动生成各页面的入口文件  集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新</h2><p>github地址：<a href="https://github.com/F-loat/mpvue-entry" target="_blank" rel="noopener">https://github.com/F-loat/mpvue-entry</a></p><h2 id="关于ajax请求封装，拿走不谢"><a href="#关于ajax请求封装，拿走不谢" class="headerlink" title="关于ajax请求封装，拿走不谢"></a>关于ajax请求封装，拿走不谢</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urlPath = <span class="string">''</span> <span class="comment">// 项目的域名</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  wx.showLoading(&#123;</span><br><span class="line">    title: <span class="string">'努力加载中'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 由于微信不会保存后端用于登陆验证的cookie，这里需要自己从登陆返回的数据里取到cookie，然后本地缓存，请求时在header里带上cookie</span></span><br><span class="line">  <span class="keyword">let</span> header = &#123;&#125; </span><br><span class="line">  url === <span class="string">'user/loginworker'</span> <span class="comment">// 通过传进来的url判断是否是登陆页</span></span><br><span class="line">    ? header = &#123;&#125; </span><br><span class="line">    : header = &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">      <span class="string">'cookie'</span>: wx.getStorageSync(<span class="string">"sessionid"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: urlPath + url,</span><br><span class="line">      data: data,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      header: header, success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.data === <span class="number">9999</span>) &#123; <span class="comment">// 后端返回9999表示cookie失效</span></span><br><span class="line">            wx.showModal(&#123;</span><br><span class="line">              content: <span class="string">'登陆超时请重新登陆'</span>,</span><br><span class="line">              showCancel: <span class="literal">false</span>,</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">                  wx.navigateTo(&#123;</span><br><span class="line">                    url: <span class="string">'../../pages/login/main'</span>,</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.data.code &amp;&amp; res.data.code !== <span class="number">200</span>) &#123; <span class="comment">// 若返回coode码且不等于200表示传入参数有问题</span></span><br><span class="line">            res.message = res.data.message, reject(res)</span><br><span class="line">          &#125; <span class="keyword">else</span> resolve(res)</span><br><span class="line">            <span class="comment">// 存储cookie</span></span><br><span class="line">          res.data.message === <span class="string">'登录成功。'</span> ? wx.setStorageSync(<span class="string">"sessionid"</span>, res.header[<span class="string">"Set-Cookie"</span>]) : <span class="string">""</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          res.message = <span class="string">'服务器错误请求失败'</span></span><br><span class="line">          reject(res)</span><br><span class="line">        &#125;</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">      &#125;, fail(err) &#123;</span><br><span class="line">        err.message = <span class="string">'请求超时请稍后再试'</span></span><br><span class="line">        reject (err)</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>created是vue的生命周期在mpvue里所有页面的created函数会在项目加载的时候被一起调用，可用性不大，可以使用onShow()代替，但是onShow()只有在隐藏又显示后才会显示,也就是第一次加载不会执行</p><p> created() {<br>    console.log(‘created’)<br>  },<br>  mounted() {<br>    console.log(‘mounted’)<br>  },<br>  onLoad() {<br>    console.log(‘onLoad’)<br>  },<br>  onShow() {<br>    console.log(‘onShow’)<br>  },<br>  onUnload() {<br>    console.log(‘onUnload’)<br>  },<br>  onHide() {<br>    console.log(‘onHide’)<br>  },</p><h2 id="页面跳转后并没有销毁页面实例"><a href="#页面跳转后并没有销毁页面实例" class="headerlink" title="页面跳转后并没有销毁页面实例"></a>页面跳转后并没有销毁页面实例</h2><p>比如一个搜索页面，页面第一次进来所有的数据都是空的，但你搜索一次之后，input框就有值了，这个时候再跳转到其他页面或者返回之后再进入这个页面那个值依然存在，页面跳转后并没有销毁页面实例，而是将其推入页面栈中，所以会保存之前的旧的数据，目前为止看到的比较统一的解决办法就是：在onShow()或者onLoad()手动清空</p><h2 id="关于微信直播"><a href="#关于微信直播" class="headerlink" title="关于微信直播"></a>关于微信直播</h2><p>这个小程序需要引入监控相当于是直播功能，这个组件也是有点坑</p><p>Live-player组件本身只能播放，如果想要在组件上加功能，像什么全屏静音播放暂停之类的功能需要使用wx.createLivePlayerContext()方法，而且由于live-player层级是最高的，如果你需要在组件上加功能比如点一下全屏再点下退出全屏或者加css样式，你必须写在 cover-view cover-image上面，直接加在live-player上是没用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;live-player id=<span class="string">'liveInfo'</span> src=<span class="string">""</span> mode=<span class="string">"live"</span> autoplay=<span class="string">'false'</span> @bindstatechange=<span class="string">"statechange"</span> binderror=<span class="string">"error"</span>&gt;</span><br><span class="line">    &lt;cover-image @click=<span class="string">"requestFullScreen"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">cover-image</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">live-player</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>你以为这样就完了嘛，不，如果你有一个直播列表，比如一个屏幕同时有一个以上的live-player组件那么你全屏的时候就会发现其余的组件因为层级的原因全部覆盖在你全屏的那个组件之上</p><p>解决办法：全屏是v-if隐藏其余的组件，退出时再显示</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python爬虫之爬取掘金网首页存入mysql数据库</title>
      <link href="/2018/08/07/python_%E7%88%AC%E8%99%AB/"/>
      <url>/2018/08/07/python_%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<p>博主是个前端小白，最近在学习爬虫，写个实战系列也是想记录自己学习的过程，以便后续回顾</p><p>欢迎大家一起交流学习、共同进步</p><p>这篇文章达成的效果是爬掘金网的首页的数据存到mysql数据库里</p><p><img src="https://img-blog.csdn.net/2018080714283577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"><br><img src="https://img-blog.csdn.net/20180807143043893?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"></p><p>做这个实战你需要具有一点点python的基础知识，当然没有也行可以复制代码先跑一跑感受一下会有动力一点</p><p>爬取的网站：<a href="https://juejin.im/timeline" target="_blank" rel="noopener">https://juejin.im/timeline</a></p><p>系统：win10</p><p>python版本:3.7</p><p>MYSQL安装包下载：<a href="https://dev.mysql.com/downloads/windows/installer/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/windows/installer/</a> </p><p><img src="https://img-blog.csdn.net/20180802145942417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"></p><p>mysql-installer-web-community  15.9M那个是在线安装</p><p>mysql-installer-community 推荐下载第二个离线安装</p><p>现在这个安装包好像不分32位还是64位，我是64位的安装成功，MSI安装版安装挺简单的我就不赘述了（其实我安装蛮久了没记录下来）</p><p>安装完成可以通过·mysql -u root -p查看</p><p>mysql安装成功后你还需要一个python操作mysql的库，cmd执行使用pip安装pymysql:</p><p>pip install pymysql<br>环境准备好后就开始愉快的学习吧</p><p>网站分析<br>我们进入网站<a href="https://juejin.im/，然后打开f12（博主用的是chrome浏览器，在前端眼里chrome是最好浏览器没有之一）" target="_blank" rel="noopener">https://juejin.im/，然后打开f12（博主用的是chrome浏览器，在前端眼里chrome是最好浏览器没有之一）</a></p><p>掘金网是个动态网站，即客户端（浏览器）根据服务端（服务器）返回的数据动态渲染网页</p><p>那么数据从哪儿来，服务端会根据客户端不同的请求或者请求参数的差异来返回数据</p><p>这里我们需要登陆下，我们登陆成功即通过服务端验证后服务器会签发一个 Token发送给客户端，你可以理解为一个验证身份的令牌，客户端收到 Token 以后把它存储起来，每次向服务端请求资源的时候都需要带着这个token，服务端收到请求，去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p><p><img src="https://img-blog.csdn.net/20180807120526739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"></p><p>我们可以看到有很多请求，什么图片、脚本资源、svg很多</p><p>点击XHR按钮过滤请求只显示XMLHttpRequest方法发送的请求</p><p><img src="https://img-blog.csdn.net/20180807120941504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"></p><p>过滤之后现在挨着查看，找到返回文章数据的那条请求</p><p>大部分数据都是页面或者服务器做判断用的，我们提取这些参数就好</p><p>[‘category’][‘name’] 文章分类<br>[‘title’] 文章标题<br>[‘content’] 文章概要<br>[‘originalUrl’] 文章链接<br>[’tags’] 文章标签<br>[‘user’][‘username’] 文章作者</p><p><img src="https://img-blog.csdn.net/20180807124337750?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="效果"></p><p>然后我们查看他的Headers，滑到底部可以看到uery string params是由客户端发给服务器时请求携带的参数</p><p><img src="https://img-blog.csdn.net/20180807130603595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="参数"></p><p>这些参数里面有个limit是请求的条数，就是你请求多少条就会返回多少条数据</p><p>现在上代码<br>需要3个库，除了第一个pymsql以为都是python自带的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pymysql # 操作mysql的库</span><br><span class="line">from urllib import request, parse #请求需要的库</span><br><span class="line">import json # 处理参数需要的库</span><br></pre></td></tr></table></figure></p><p>我们先发送请求获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def juejin_req(data_num): # data_num是请求的条数</span><br><span class="line">    url = &apos;https://timeline-merger-ms.juejin.im/v1/get_entry_by_rank&apos; # 请求的url</span><br><span class="line">    req_data = &#123;  # 请求需要携带的参数</span><br><span class="line">        &apos;src&apos;: &apos;web&apos;,</span><br><span class="line">        &apos;uid&apos;: &apos;5b5ebcd1f265da0f60132076&apos;,</span><br><span class="line">        &apos;device_id&apos;: 1533608440568,</span><br><span class="line">        &apos;token&apos;: &apos;你的token&apos;,</span><br><span class="line">        &apos;limit&apos;: data_num,</span><br><span class="line">        &apos;category&apos;: &apos;all&apos;,</span><br><span class="line">        &apos;recomment&apos;: 1</span><br><span class="line">    &#125;</span><br><span class="line">    req_data = str(parse.urlencode(req_data, &apos;utf-8&apos;)) # 由于是get请求所以我们在使用parse.urlencode()方法转换编码格式后还需要使用str()方法转换为字符串</span><br><span class="line">    json_data = request.urlopen(url+&apos;?&apos;+req_data) # 拼凑url发送请求</span><br><span class="line">    print(&apos;数据请求成功&apos;)</span><br><span class="line">    json_data = json_data.read().decode(&apos;utf-8&apos;)  # 拿到数据转换编码格式</span><br><span class="line">    json_data = json.loads(json_data)  # 使用json.loads()将字符串序列化</span><br><span class="line">    json_data = json_data[&apos;d&apos;][&apos;entrylist&apos;] # 获取到数据列表</span><br><span class="line">    sql_data = [] # 最后储存到数据的变量</span><br><span class="line">    for item in json_data: # 循环遍历列表提取需要的数据</span><br><span class="line">        tag = [] </span><br><span class="line">        for aa in item[&apos;tags&apos;]: # 提取标签</span><br><span class="line">            tag.append(aa[&apos;title&apos;])</span><br><span class="line">        sql_data.append((item[&apos;category&apos;][&apos;name&apos;],  item[&apos;title&apos;], item[&apos;content&apos;], item[&apos;originalUrl&apos;], str(tag), item[&apos;user&apos;][&apos;username&apos;],))</span><br><span class="line">    print(&apos;一共有%s条数据&apos; % len(sql_data))</span><br><span class="line">    return sql_data</span><br></pre></td></tr></table></figure></p><p>打开workbench，这是自带的一款可视化的sql操作工具</p><p><img src="https://img-blog.csdn.net/20180802151203471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="参数"></p><p>首先我们先新建一个连接<br>点击新建一个连接—–填上连接名字hellosql—–点击ok—–在弹出的弹框中输入你的密码–点击ok</p><p><img src="https://img-blog.csdn.net/20180803104853455?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="参数"></p><p>连接建立后我们新建一个数据库，在左侧红圈空白地方右键—create scheme（新建一个数据库），这地方我已经建了</p><p><img src="https://img-blog.csdn.net/20180807133227686?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="参数"></p><p>输入数据库名字reptiledata—点击apply—出现一个弹框继续点击apply，这样我们就新建了一个数据库</p><p><img src="https://img-blog.csdn.net/20180807133445579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvbmdfMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="参数"></p><p>这是操作数据库的代码，获取到请求的数据后将数据return处理在传给juejin_sql函数，所以把这段代码放在上面那段代码后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def juejin_sql(sql_data):</span><br><span class="line">    print(&apos;连接数据库&apos;)</span><br><span class="line">    db = pymysql.connect(host=&apos;localhost&apos;,</span><br><span class="line">                        port=3306, # 端口号</span><br><span class="line">                        user=&apos;root&apos;, </span><br><span class="line">                        password=&apos;123456&apos;, # 密码</span><br><span class="line">                        database=&apos;reptiledata&apos;) # 数据库</span><br><span class="line">    cursor = db.cursor() # 建立一个游标对象</span><br><span class="line">    try:</span><br><span class="line">        #判断表是否存在，若不存在则新建</span><br><span class="line">        cursor.execute(&quot;&quot;&quot;CREATE TABLE IF NOT EXISTS juejin(</span><br><span class="line">                    category  TEXT,</span><br><span class="line">                    title  TEXT,</span><br><span class="line">                    content  TEXT,</span><br><span class="line">                    originalUrl  TEXT,</span><br><span class="line">                    tags  TEXT,</span><br><span class="line">                    username TEXT)&quot;&quot;&quot;)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;Table &apos;juejin&apos; already exists&quot;)</span><br><span class="line">        return False</span><br><span class="line">    sql = &quot;&quot;&quot;insert into juejin(category, title, content, originalUrl, tags, username)</span><br><span class="line">            values (%s, %s, %s, %s, %s, %s)&quot;&quot;&quot; # sql语句</span><br><span class="line">    print(&apos;正在批量添加&apos;)</span><br><span class="line">    cursor.executemany(sql, sql_data) # 批量添加</span><br><span class="line">    cursor.execute(&apos;select count(*) from juejin&apos;)</span><br><span class="line">    results = cursor.fetchall() # 查询全部总条数</span><br><span class="line">    print(&apos;数据库目前有%d条数据&apos; % results[0][0])</span><br><span class="line">    db.commit()  # 对于数据增删改之后一定要提交操作</span><br><span class="line">    cursor.close()  # 关闭游标</span><br><span class="line">    print(&apos;操作完成关闭数据库关闭游标&apos;)</span><br><span class="line">    db.close()  # 关闭数据库连接</span><br><span class="line"></span><br><span class="line">juejin_sql(juejin_req(100))</span><br></pre></td></tr></table></figure></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UI和平面设计的区别</title>
      <link href="/2018/06/24/%E5%B9%B3%E9%9D%A2&amp;&amp;ui/"/>
      <url>/2018/06/24/%E5%B9%B3%E9%9D%A2&amp;&amp;ui/</url>
      <content type="html"><![CDATA[<p>前段时间自告奋勇的给新项目做UI设计，项目包括一个网站一个app还有一个后台，后台没有设计套用以前的模板主要是将就前端也就是我还有我的小伙伴们,总的花费时间共一周左右</p><p>作为曾经的一只平面设计狗，这是我UI处女作  哈哈哈哈！！！</p><p>在没做前端之前一直觉得平面和UI都是根据客户的需求设计画图嘛也都是平面图也没什么太大的区别，而且UI还不用像平面设计海报那样做一些复杂抓人眼球的效果，毕竟现在的页面为了追求速度用户体验什么的都是扁平化趋于简洁</p><p>这次呢是深切感受到了UI和平面的区别</p><p>在学习css开始我就知道UI画的图都是需要前端实现的，设计的时候，除了好的创意，还应该考虑到技术上的可行性，就像这次设计页面的时候是自动把自己代入了前端这个角色所以在设计时更多的考虑到css样式布局js的特效数据渲染什么的还有组件模块的复用问题等等，设计方面远不如平面设计那么自由洒脱</p><p>大部分平面设计的作品都是以印刷的平面形式表现，这需要设计师去了解各种材料之间的区别以及不同材料所做出来的成品效果的差别，但在设计方面却是比较自由的，在符合主题的情况下怎么好看怎么漂亮怎么抓人眼球怎么来，很多时候平面设计师一个人对接一个客户就能完成一个作品，而ui除了产品客户以外还得对接前端后端需要遵守一系列的项目流程，而最后的成功也是团队协作达成的效果，这也是很大的一个不同点</p><p>UI设计的时候除了考虑前端的实现还有最重要的是用户体验和交互，毕竟网页是会”动”起来的，不管是网站还是其他什么软件都是需要用户去操作，这需要去琢磨研究用户的行为，所以好的ui设计不只是画面的美观还要让用户操作起来感觉舒适简单自由</p><p>所以总的来讲呢，平面注重视觉创意，UI却是更注重用户交互，两者在视觉传达方面是共通的，但是在难点侧重点方面却是不一样的</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> rests </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rests </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令（备忘）</title>
      <link href="/2018/05/23/git/"/>
      <url>/2018/05/23/git/</url>
      <content type="html"><![CDATA[<h1 id="克隆库到相对路径"><a href="#克隆库到相对路径" class="headerlink" title="克隆库到相对路径"></a>克隆库到相对路径</h1><p>git clone <a href="https://github.com/stiekel/hexo-theme-random.git" target="_blank" rel="noopener">https://github.com/stiekel/hexo-theme-random.git</a> themes/random</p><p><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="noopener">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</a><br>工作区：电脑里的目录，不包括隐藏的git目录<br>暂存区：add提交到暂存区<br>版本库：commit提交到版本库的分支上</p><h1 id="指定用户名和邮箱"><a href="#指定用户名和邮箱" class="headerlink" title="指定用户名和邮箱"></a>指定用户名和邮箱</h1><p>git config  –global  user.name “”<br>git config  –global  user.email “”  </p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>Cd 版本库的位置/进入文件<br>Mkdir 版本库名<br>pwd（pwd将显示版本库目录和位置）<br>git init（将这个目录变成git可以管理的版本库）</p><h1 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h1><p>将文件放在版本库目录下<br>git add files （告诉git添加了文件  可以add多个文件）<br>git add –A(如果提交一整个文件夹，add后面加上这条命令)<br>git commit –m “文件说明”（可以一次性提交多个文件）</p><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>git status (查看工作区状态)<br>git diff（查看文件具体修改内容）<br>修改文件之后要用add和commit -m重新提交</p><h1 id="回退和前进"><a href="#回退和前进" class="headerlink" title="回退和前进"></a>回退和前进</h1><p>git log(查看提交日志历史记录  时间是提交到git的时间  不会显示是哪个文件)<br>git log -pretty=oneline（查看精简的历史记录）<br>git reset –hard HEAD^^(在git中HEAD代表现在的版本，HEAD^代表上一个版本，HEAD^^代表上上个版本，在往上可以用HEAD~100)<br>git reset –hard 版本号（用于当你已经回到之前的版本，想要回到最新的版本）<br>cat files  （查看文件内容）<br>git reflog  （用于你想要回到之前之后某一个版本但不知道那个版本号）</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p>git checkout – files （两种情况 1、files还没有提交到暂存区但是已经做了修改，这个命令丢弃工作区的更改。2、files提交到暂存区后又做了修改，这个命令可以回到刚提交暂存区的状态）</p><p>注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。<br>git reset HEAD files（files已经提交到暂存区 这个命令撤销暂存区的文件，让文件回到工作区）</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>rm files (删除workspace的文件或者直接在电脑目录里删掉)<br>git add –A<br>git commit –m”修改说明”删除之后不需要复原文件执行这两个命令<br>git checkout – files(用repository里的files替换工作区的files，前提是files已经提交到repository)<br>git rm files(delete the repository files)<br>github删除文件操作    </p><h1 id="远程库提交"><a href="#远程库提交" class="headerlink" title="远程库提交"></a>远程库提交</h1><p>ssh-keygen –t rsa –C “email address”(查看sshkey)<br>git remote add origin 远程库地址（绑定远程仓库）<br>git remote rm origin  （用于上一个命令远程仓库填错了，之后重新绑定远程仓库）<br>git push –u origin master（把本地库的内容推送到远程仓库）<br>git push origin master（本地做了提交  用这个命令把最新修改推送到远程库）<br>git oush –u origin +master  (强行更新)<br>git push origin 分支名字  （提交分支修改的内容）</p><h1 id="远程库克隆到本地"><a href="#远程库克隆到本地" class="headerlink" title="远程库克隆到本地"></a>远程库克隆到本地</h1><p>git clone远程库地址<br>创建分支与合并分支<br>查看分支：git branch（查看当前分支，会列出所有分支，当前分支前面会添加一个星号）<br>创建分支：git branch name<br>切换分支：git checkout name<br>创建+切换分支：git checkout –b name<br>合并某分支到当前分支：git merge name(在当前分支选择需要合并的分支)</p><p>删除分支：git branch –d name<br>分支冲突<br>你在两个分支上修改了内容最后要合并到主分支，照常合并之后查看工作区，在查看文件内容，文件已经更改</p><p> git merge –no-ff  -m “注释” name<br>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</p><p>查看远程库的信息 git remote<br>查看远程库的详细信息  git remote –v</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cordova add android 报错4种解决方法</title>
      <link href="/2018/05/16/Cordova%20add%20android%20%E6%8A%A5%E9%94%99/"/>
      <url>/2018/05/16/Cordova%20add%20android%20%E6%8A%A5%E9%94%99/</url>
      <content type="html"><![CDATA[<h2 id="方法一：可能网络有问题，换一个源（对我没有用）"><a href="#方法一：可能网络有问题，换一个源（对我没有用）" class="headerlink" title="方法一：可能网络有问题，换一个源（对我没有用）"></a>方法一：可能网络有问题，换一个源（对我没有用）</h2><p>npm i nrm -g 安装nrm</p><p>nrm ls 查看当前nrm内置的npm源</p><p>nrm use cnpm 切换源</p><h2 id="方法二：可能版本有问题（对我没有用）"><a href="#方法二：可能版本有问题（对我没有用）" class="headerlink" title="方法二：可能版本有问题（对我没有用）"></a>方法二：可能版本有问题（对我没有用）</h2><p>npm view cordova-android   查看可选版本</p><p>cordova platform add <a href="mailto:android@7.0.0" target="_blank" rel="noopener">android@7.0.0</a>  切换版本</p><h2 id="方法三：卸载cordva重新安装（对我没有用）"><a href="#方法三：卸载cordva重新安装（对我没有用）" class="headerlink" title="方法三：卸载cordva重新安装（对我没有用）"></a>方法三：卸载cordva重新安装（对我没有用）</h2><p>运行命令：npm uninstall cordova -g<br>删除文件夹：C：\ Users \ your-name \ .cordova<br>重新安装cordova：npm install -g cordova<br>现在转到项目文件夹，然后再试一次：cordova platform add android<br>方法四：修改环境变量（解决）<br>在环境变量path内加入C:\Windows\System32</p><h1 id="如果以上方法对你没有用，可以用cordova-d-platform-add-android调试看下提示信息"><a href="#如果以上方法对你没有用，可以用cordova-d-platform-add-android调试看下提示信息" class="headerlink" title="如果以上方法对你没有用，可以用cordova -d platform add android调试看下提示信息"></a>如果以上方法对你没有用，可以用cordova -d platform add android调试看下提示信息</h1><p>相关博文：Android SDK 环境配置/Cordova环境搭建打包apk各种踩坑报错系列</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里云服务器</title>
      <link href="/2018/05/13/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/05/13/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>新手入门弄了一个阿里云服务器自己学习使用</p><p>在官网上点击远程链接出现了终端管理的画面，安装官网的步骤一步一步的在本机尝试远程连接（系统win7），输入ip地址，用户名，点击确定，弹框输密码</p><p>然后就告诉我：你的凭据不工作，之前用于链接到***的凭据无法工作，请输入新凭据</p><p>之后各种百度，尝试各种方法</p><p>可能导致此故障的原因</p><p>1、客户端本地网络异常 [出现概率：3%]</p><p>这个就…</p><p>2、重置实例密码，未重启实例 [出现概率：7%] 找到原因，自己手贱改了密码不知道要重启<br>故障现象：有实例密码修改记录，但无重启实例记录。</p><p>可能原因：您修改了实例密码，但是未重启 ECS 实例。</p><p>解决方法：</p><p>登录云服务器管理控制台。<br>单击左侧导航栏中的 实例。<br>单击页面顶部的地域。<br>选择需要的实例。单击 重启。<br>在弹出的提示框中，选择 重启，单击 确定。</p><p>3、防火墙配置异常（Windows 2008&amp;2012）[出现概率：10%]</p><p>前提条件：您只有在已授权可关闭防火墙的情况下，才能做该项排查。<br>故障现象：远程无法连接，关闭 防火墙 后连接恢复。<br>解决方法：调整防火墙配置策略，具体操作详见官网：ECS Windows 远程连接之防火墙设置。<br>完成操作后，请再进行远程连接。</p><p>4、安全组公网规则 [出现概率：8%]</p><p>故障现象：ECS 服务器无法ping通，排查防火墙、网卡 IP 配置无误，回滚系统后仍然无法ping通。<br>可能原因：ECS 实例安全组默认的公网规则被删除。<br>解决方法：重新配置 ECS 实例的安全组公网规则，具体操作详见 ECS实例安全组默认的公网规则被删除导致无法ping通。</p><p>5、远程访问端口配置异常 [出现概率：10%]</p><p>故障现象：远程无法连接，远程访问端口非默认端口。<br>解决方法：<br>运行注册表，然后查看此文档<a href="https://yq.aliyun.com/articles/33712" target="_blank" rel="noopener">https://yq.aliyun.com/articles/33712</a></p><p>6、CPU 负载过高 [出现概率：9%]</p><p>故障现象：CPU 负载过高导致系统无法进行远程连接。</p><p>附上官网关于连接失败的的文档：</p><p><a href="https://help.aliyun.com/knowledge_detail/40849.html?spm=a2c4g.11186623.4.1.zfSNDN" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/40849.html?spm=a2c4g.11186623.4.1.zfSNDN</a></p><p><a href="https://help.aliyun.com/knowledge_detail/50982.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/50982.html</a></p><p>其他楼主遇到的这格问题的一些解决方法，百度搜来大多都是差不多，这个楼主的方法蛮全的</p><p><a href="https://blog.csdn.net/sun15732621550/article/details/50444398" target="_blank" rel="noopener">https://blog.csdn.net/sun15732621550/article/details/50444398</a></p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular之constant和filter</title>
      <link href="/2018/01/31/angular_constant&amp;filter/"/>
      <url>/2018/01/31/angular_constant&amp;filter/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>angular是什么：AngularJS最初由Misko Hevery和Adam Abrons于2009年开发，后来成为了Google公司的项目。AngularJS弥补了HTML在构建应用方面的不足，其通过使用标识符（directives）结构，来扩展Web应用中的HTML词汇，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。</p><p>constant，可以算作angular的全局数据，想要使用的话，只需要在控制器注入即可。</p><p>$filter，angular的过滤器，如果想要在控制器里面使用，也是注入，然后调用，而html中的数据过滤，直接键入过滤器名称和对应值即可。</p><h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><p>每当搜索constant时候，总会连带出现value的说明。</p><p>两者都可以作为全局变量使用，但是有两点不同：</p><p>1.value不可以在config里注入，但是constant可以。</p><p>2.value可以修改，但是constant不可以修改，一般直接用constant配置一些需要经常使用的数据。</p><p>下面是简单的应用例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'myApp'</span>, [])</span><br><span class="line">.constant(<span class="string">'apiKey'</span>, <span class="string">'123123123'</span>)</span><br><span class="line">.value(<span class="string">'FBid'</span>,<span class="string">'231231231'</span>)</span><br><span class="line">.controller(<span class="string">'myController'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope,apiKey,FBid</span>)</span>&#123;</span><br><span class="line">$scope.a = apiKey;</span><br><span class="line">$scope.b = FBid;</span><br><span class="line">&#125;)</span><br><span class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">apiKey</span>) </span>&#123;</span><br><span class="line"><span class="comment">//在这里apiKey将被赋值为123123123</span></span><br><span class="line"><span class="comment">//就像上面设置的那样</span></span><br><span class="line">&#125;)</span><br><span class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">FBid</span>) </span>&#123;</span><br><span class="line"><span class="comment">//这将抛出一个错误，未知的provider: FBid</span></span><br><span class="line"><span class="comment">//因为在config函数内部无法访问这个值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>filter是用来格式化数据用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本原型：&#123;&#123;expression | filter&#125;&#125;</span><br><span class="line"></span><br><span class="line">多个filter连用版：&#123;&#123;expression | filter1 | filter2&#125;&#125;</span><br><span class="line"></span><br><span class="line">传入参数版：&#123;&#123;expression | filter:1:2&#125;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>如何使用angular中constant和$filter？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>4.1 AngularJS内建了一些常用的filter：</p><p>1、格式化货币：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 12 | currency&#125;&#125;  //将12格式化为货币，默认单位符号为&apos;$&apos;,小数默认2位</span><br><span class="line"></span><br><span class="line">&#123;&#123; 12.45 | currency:&apos;￥&apos;&#125;&#125; //将12.45格式化为货币，使用自定义单位符号为&apos;￥&apos;,小数默认2位</span><br><span class="line"></span><br><span class="line">&#123;&#123; 12.45 | currency:&apos;CHY￥&apos;:1&#125;&#125; //将12.45格式化为货币，使用自定义单位符号为&apos;CHY￥&apos;,小数指定1位,会执行四舍五入操作</span><br><span class="line"></span><br><span class="line">&#123;&#123; 12.55 | currency:undefined:0&#125;&#125; //将12.55格式化为货币， 不改变单位符号， 小数部分将四舍五入</span><br></pre></td></tr></table></figure></p><p>2、格式化日期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 1304375948024 | date:&apos;medium&apos;&#125;&#125;//May 03, 2011 06:39:08 PM</span><br><span class="line"></span><br><span class="line">&#123;&#123; 1304375948024 | date &#125;&#125;//结果：May 3, 2011</span><br><span class="line"></span><br><span class="line">&#123;&#123; 1304375948024 | date:&quot;MM/dd/yyyy @ h:mma&quot; &#125;&#125;//结果：05/03/2011 @ 6:39AM</span><br><span class="line"></span><br><span class="line">&#123;&#123; 1304375948024 | date:&quot;yyyy-MM-dd hh:mm:ss&quot; &#125;&#125;//结果：2011-05-03 06:39:08</span><br></pre></td></tr></table></figure></p><p>3、过滤数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scope.arr = [&#123;&quot;age&quot;: 20,&quot;id&quot;: 10,&quot;name&quot;: &quot;iphone&quot;&#125;, &#123;&quot;age&quot;: 12,&quot;id&quot;: 11,&quot;name&quot;: &quot;sunm xing&quot;&#125;, &#123;&quot;age&quot;: 44,&quot;id&quot;: 12,&quot;name&quot;: &quot;test abc&quot;&#125; ]</span><br><span class="line"></span><br><span class="line">&#123;&#123;arr | filter:&apos;s&apos;&#125;&#125;  //查找含有有s的行//上例结果：[&#123;&quot;age&quot;:12,&quot;id&quot;:11,&quot;name&quot;:&quot;sunm xing&quot;&#125;,&#123;&quot;age&quot;:44,&quot;id&quot;:12,&quot;name&quot;:&quot;test abc&quot;&#125;]</span><br><span class="line"></span><br><span class="line">&#123;&#123;arr | filter:&#123;&apos;name&apos;:&apos;ip&apos;&#125; &#125;&#125;//查找name like ip的行//上例结果:[&#123;&quot;age&quot;:20,&quot;id&quot;:10,&quot;name&quot;:&quot;iphone&quot;&#125;]</span><br></pre></td></tr></table></figure></p><p>4、将对象格式化成标准的JSON格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &#123;name:&apos;Jack&apos;, age: 21&#125; | json&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>5、字符串，对象截取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &quot;i love tank&quot; | limitTo:6 &#125;&#125;//结果：i love</span><br><span class="line"></span><br><span class="line">&#123;&#123; &quot;i love tank&quot; | limitTo:-4 &#125;&#125;//结果：tank</span><br><span class="line"></span><br><span class="line">&#123;&#123; [&#123;&quot;age&quot;: 20,&quot;id&quot;: 10,&quot;name&quot;: &quot;iphone&quot;&#125;, &#123;&quot;age&quot;: 12,&quot;id&quot;: 11,&quot;name&quot;: &quot;sunm xing&quot;&#125;, &#123;&quot;age&quot;: 44,&quot;id&quot;: 12,&quot;name&quot;: &quot;test abc&quot;&#125; ] | limitTo:1 &#125;&#125;//结果：[&#123;&quot;age&quot;:20,&quot;id&quot;:10,&quot;name&quot;:&quot;iphone&quot;&#125;]</span><br></pre></td></tr></table></figure></p><p>6、大小写转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">China has joined the &#123;&#123; &quot;wto&quot; | uppercase &#125;&#125;.</span><br><span class="line">We all need &#123;&#123; &quot;MONEY&quot; | lowercase &#125;&#125;.</span><br></pre></td></tr></table></figure></p><p>7、数值类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 1.234567 | number:1 &#125;&#125;  //结果：1.2</span><br><span class="line">&#123;&#123; 1234567 | number &#125;&#125;    //结果：1,234,567</span><br></pre></td></tr></table></figure></p><p>8、对象排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.arr = [&#123;&quot;age&quot;: 20,&quot;id&quot;: 10,&quot;name&quot;: &quot;iphone&quot;&#125;, &#123;&quot;age&quot;: 12,&quot;id&quot;: 11,&quot;name&quot;: &quot;sunm xing&quot;&#125;, &#123;&quot;age&quot;: 44,&quot;id&quot;: 12,&quot;name&quot;: &quot;test abc&quot;&#125; ]</span><br><span class="line">&#123;&#123;arr | orderBy:&apos;id&apos;:true &#125;&#125;//根id降序排</span><br><span class="line">&#123;&#123;arr | orderBy:&apos;id&apos; &#125;&#125;//根据id升序排</span><br></pre></td></tr></table></figure></p><h2 id="自定义filter方法"><a href="#自定义filter方法" class="headerlink" title="自定义filter方法"></a>自定义filter方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">我们来自定义选择省份和职位</span><br><span class="line"></span><br><span class="line">HTML代码：</span><br><span class="line">&#123;&#123;<span class="number">1</span> | provinceFilter&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="number">6</span> | fMes:<span class="string">'positionList'</span>:<span class="string">'type'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">app.js:</span><br><span class="line">angular.module(<span class="string">'myApp'</span>,[])</span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line">.controller(<span class="string">'personCtrl'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  $scope.arr=[</span><br><span class="line">    &#123;<span class="string">"age"</span>:<span class="number">20</span>,<span class="string">"id"</span>:<span class="number">10</span>,<span class="string">"name"</span>:<span class="string">"iphone"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"age"</span>:<span class="number">12</span>,<span class="string">"id"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"sunm xing"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"age"</span>:<span class="number">44</span>,<span class="string">"id"</span>:<span class="number">12</span>,<span class="string">"name"</span>:<span class="string">"test abc"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//自定义选择省份</span></span><br><span class="line">.filter(<span class="string">'provinceFilter'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">PROVINCE</span>)</span>&#123;<span class="comment">//省</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id!=<span class="literal">undefined</span>&amp;&amp;id!=<span class="string">''</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span>  name;</span><br><span class="line">      angular.forEach(PROVINCE,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.ProID==id)&#123;</span><br><span class="line">              name=data.ProName;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="keyword">return</span>  name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义选择职位</span></span><br><span class="line"></span><br><span class="line">.filter(<span class="string">'fMes'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">con</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">input,field,str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(input&gt;=<span class="number">0</span>) &#123;<span class="comment">//input != undefined &amp;&amp;</span></span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">var</span> aMes=con[field];</span><br><span class="line">    angular.forEach(aMes,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(data[str]==input)&#123;</span><br><span class="line">          name=data.name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="built_in">console</span>.log(<span class="string">'false'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">constant.js</span><br><span class="line">angular.module(<span class="string">"myApp"</span>) .value(<span class="string">'val'</span>,&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//公司编辑常量组</span></span><br><span class="line">.constant(<span class="string">'con'</span>,&#123;</span><br><span class="line"><span class="comment">//职业分类</span></span><br><span class="line">positionList:[</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">0</span>,<span class="attr">name</span>:<span class="string">'ui设计师'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'运维工程师'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'产品'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'Java工程师'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">'IOS工程师'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">5</span>,<span class="attr">name</span>:<span class="string">'Android工程师'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="number">6</span>,<span class="attr">name</span>:<span class="string">'Web前端工程师'</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显示的结果是：Web前端工程师，改变type值，显示相应的职位。</p><h1 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h1><p>AngularJS的内置过滤器有哪些？</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>参考一：angularJS constant和value<br>参考二：AngularJS的Filter用法详解</p><h1 id="更多提问"><a href="#更多提问" class="headerlink" title="更多提问"></a>更多提问</h1><p>1、constant函数取值，和直接用常量名有什么区别</p><p>答：大多数情况直接用常量名，但是在angular中，使用constant的字段约定与后台进行数据交互的时候很方便，结构更加清晰。constant()函数和直接使用常量名输出的效果是一样的，但函数可以动态的输出不同的常量，在使用上要灵活、方便。</p><p>2、filter怎么去掉时间的秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：&#123;&#123;date | date : &apos;yyyy-MM-dd hh:mm:ss EEEE&apos;&#125;&#125;</span><br><span class="line">参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们</span><br></pre></td></tr></table></figure></p><p>3、什么情况下使用filter</p><p>答：常用的就是一个date的格式转换，表格中进行排序、还有大量的一些约定字段，使用自定义的filter。</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何使用NPM？CNPM又是什么？</title>
      <link href="/2018/01/18/NPM&amp;CNPM/"/>
      <url>/2018/01/18/NPM&amp;CNPM/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>什么是npm</p><p>npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）, NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，它是 Node 获得成功的重要原因之一。常见的使用场景有以下几种：</p><p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p><p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p><p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p><p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装</p><p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p><p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p><p>什么是cnpm?</p><p>因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p><h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><p>NPM常用指令</p><p>1、npm install moduleNames：安装Node模块</p><p>安装完毕后会产生一个node_modules目录，其目录下就是安装的各个node模块。</p><p>node的安装分为全局模式和本地模式。</p><p>一般情况下会以本地模式运行，包会被安装到和你的应用程序代码的本地node_modules目录下。</p><p>在全局模式下，Node包会被安装到Node的安装目录下的node_modules下</p><p>一些npm的简单命令就不多说了</p><p>为什么要保存至PACKAGE.JSON？</p><p>因为node插件包非常大，版本庞杂，所以不加入package信息，模块间的依赖变得非常困难，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包）。 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>PACKAGE.JSON 属性说明：</p><p>name - 包名。（不要把node或者js放在名字中）</p><p>version - 包的版本号。</p><p>dependencies - 项目运行所依赖的模块</p><p>devDependencies - 项目开发所需要的模块</p><p>bin - 这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/</p><p>使用npm卸载插件：npm uninstall &lt; name &gt; [-g] [–save-dev] PS：不要直接删除本地插件包</p><p>使用npm更新插件：npm update &lt; name &gt; [-g] [–save-dev] </p><p>更新全部插件：npm update [–save-dev] </p><p>查看npm帮助：npm help </p><p>查看当前目录已安装插件：npm list </p><p>PS：npm安装插件过程：从<a href="http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法就是cnpm" target="_blank" rel="noopener">http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法就是cnpm</a></p><p>CNPM介绍：</p><p>官方网址：<a href="http://npm.taobao.org" target="_blank" rel="noopener">http://npm.taobao.org</a></p><p>安装：命令提示符执行npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 </p><p>PS：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>bower 和 npm有什么区别</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>npm 是伴随 Node.js 出现的一个包管理器，最开始只能支持 Node.js 的模块管理，但是后来， npm 官网经过一次改版，打出的口号是，javascript 的包管理器，所以，其已经不在局限于是 Node.js 的模块管理了，已经通用到了所有 js 的包管理工具了，可以说，前后通吃了。</p><p>bower 的话，从一开始，就是专门为前端表现设计的包管理器，一切全部为前端考虑的。npm 和 bower 的最大区别，就是 npm 支持嵌套地依赖管理，而 bower只能支持扁平的依赖（嵌套的依赖，由 程序员自己解决）。</p><p>嵌套依赖，指的就是，你依赖的软件包，还有它自己的依赖，好像摘葡萄，一摘一大串。在服务器环境的时候，这并没什么关系，因为存储空间够大，一切代码都是本地运行，只要解决完依赖就行了， 但是到了用户产品的浏览器里，就很成问题了，你不能让用户去下载好几M的js代码，那就太糟糕了。在这个情况下，就需要程序员自己手动解决用到的类库的嵌套依赖问题。比如确保各种各样的插件 都依赖同一个版本的jQuery。</p><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>cnpm有哪些问题？</p><p>1.cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以你用 cnpm publish 命令会执行失败的</p><p>2.不仅是 publish 会执行失败，其它的需要注册用户(npm adduser)、或者修改 package 状态等命令都无法用 cnpm</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><p>npm 模块安装机制简介</p></li><li><p>开发者对 npm 公司不满，unpublish 了自己的所有模块</p></li><li><p>npm的一些常用命令</p></li><li><p>bower 和 npm 的区别详细介绍</p></li></ul><h1 id="更多提问"><a href="#更多提问" class="headerlink" title="更多提问"></a>更多提问</h1><p>Q:全局安装和本地安装的区别？</p><p>A:因为全局模式安装,包可以供所有的程序使用。本地安装则不可以。 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如 果把包安装到全局,可以提高程序的重复利用程度,避免同样的内容的多 份副本,但坏处是难以处理不同的版本依赖。如果把包安装到当前目录, 或者说本地,则不会有不同程序依赖不同版本的包的冲突问题,同时还减 轻了包作者的 API 兼容性压力,但缺陷则是同一个包可能会被安装许多次。</p><p>Q:为什么进行了全局安装还要进行本地安装</p><p>A:为什么进行了全局安装还要进行本地安装</p><p> 1、在js实例代码中，默认下node.js会在NODE_PATH和目前js所在项目下的node_modules文件夹下去寻找模块，因此，如果只是全局安装，不能直接通过require()的方式去引用模块，需要手动解决包路径的配置问题，当然你也可以复制全局安装的node_modules文件夹到项目下，还有办法可以选择将环境变量的NODE_PATH设置为C:\Program Files\nodejs。 2.对于包的更新不好管理，可能你需要为每个包重新命名，如<a href="mailto:gulp@3.8.1" target="_blank" rel="noopener">gulp@3.8.1</a>、<a href="mailto:gulp@3.9.1" target="_blank" rel="noopener">gulp@3.9.1</a>…，为了区别不同项目使用指定的包，保证模块之间的相互依赖，区别每个项目正常运行</p><p>Q：如何在package.JSON的dependencies和devDependencies写入信息</p><p>A:npm install –save babel-cli和npm install -dev babel-cli使用这两个命令安装后可自动写入文件</p><p>npm install –save-dev babel-cli也可以在一起用</p>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSON是什么，如何处理转义？</title>
      <link href="/2018/01/04/JSON/"/>
      <url>/2018/01/04/JSON/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>JSON一种数据交换格式。在JSON出现之前， 大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是， 加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，即使你努力钻研几个月，也未必搞得清楚XML的规范。</p><p>终于，在2002年的一天，道格拉斯·克罗克福特发明了JSON这种超轻量级的数据交换格式。</p><p>由于JSON非常简单，很快就风靡Web世界。而在JavaScript中，我们可 以直接使用JSON，因为JavaScript内置了JSON的解析。把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON 格式的字符串，这样才能够通过网络传递给其他计算机。如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaS cript对象，就可以在JavaScript中直接使用这个对象了。</p><h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><p>JSON语法</p><p>数据在名称/值对中</p><p>数据由逗号分隔</p><p>大括号保存对象</p><p>中括号保存数组</p><p>JSON值</p><p>数字(整数/浮点数)</p><p>字符串(双引号)</p><p>布尔值(true/false)</p><p>数组(中括号中)</p><p>对象(大括号中)</p><p>null</p><p>实例</p><p>JSON 数据的书写格式是：名称/值对。</p><p>名称/值对组合中的名称写在前面（在双引号中），值对写在后面，中间用冒号隔开，</p><p>其中 值 可以是：数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true或false）、数组（在方括号中）、对象（在花括号中）、null</p><p>使用方式：</p><p>varjson= {“name”:”myname”,”password”:123456}</p><p>或者是嵌套使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  myObj = &#123;</span><br><span class="line"></span><br><span class="line">      &quot;name&quot;:&quot;runoob&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;alexa&quot;:10000,</span><br><span class="line"></span><br><span class="line">      &quot;sites&quot;: &#123;</span><br><span class="line"></span><br><span class="line">          &quot;site1&quot;:&quot;www.runoob.com&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;site2&quot;:&quot;m.runoob.com&quot;,</span><br><span class="line"></span><br><span class="line">          &quot;site3&quot;:&quot;c.runoob.com&quot;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(myObj)</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line"></span><br><span class="line">Object &#123;name: &quot;runoob&quot;, alexa: 10000, sites: Object&#125;</span><br></pre></td></tr></table></figure></p><p>转义概述</p><p>为什么需要转义？在js中我们使用的js对象进行处理，但是在与后端数据交换的时候，我们发送规定的json格式的字符串，所以在给后端发送或接受数据的时候，需要</p><p>{name:”myname”,password:123456} &lt;–&gt; “{“name”:”myname”,”password”:123456}”</p><p>其中json字符串转js对象，调用parse方法：</p><p>js对象 = JSON.parse(json字符串);</p><p>js对象转json字符串，调用stringify方法：</p><p>json字符串 = JSON.stringify(js对象);</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>除了以上两种方法还有什么可以转化</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用eval_r(&apos;(&apos;+json字符串+&apos;)&apos;)这个方法可以实现json计算</span><br><span class="line"></span><br><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var js = &apos;&#123;&quot;data1&quot;:&quot;hello&quot;,&quot;data2&quot;:value++&#125;&apos;;</span><br><span class="line"></span><br><span class="line">console.log(js);</span><br><span class="line"></span><br><span class="line">var data1 = eval(&quot;(&quot;+js+&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">console.log(data1);</span><br><span class="line"></span><br><span class="line">var data2=JSON.stringify(js);</span><br><span class="line"></span><br><span class="line">console.log(data2);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>eval_r获取的json对象的值中，如果有执行代码，也将照样执行！所以若不能保证数据的安全性，不要使用eval_r方法进行转义。</p><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>我们常看到{name:”myname”,password:123456}和{“name”:”myname”,”password”:123456}这样两种格式，即js对象和json，然而js对象和json有什么不一样的地方？</p><p>一个栗子大家可以自己在浏览器上运行一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">var jso1=&#123;</span><br><span class="line"></span><br><span class="line">a:&quot;name&quot;,&quot;b&quot;:&quot;age&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var jso2=&#123;</span><br><span class="line"></span><br><span class="line">&quot;a&quot;:&quot;name&quot;,&quot;b&quot;:&quot;age&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(jso1.a === jso2.a);</span><br><span class="line"></span><br><span class="line">console.log(jso1.b === jso2.b);</span><br><span class="line"></span><br><span class="line">console.log(jso1 === jso2);</span><br><span class="line"></span><br><span class="line">console.log(jso1);</span><br><span class="line"></span><br><span class="line">console.log(jso2);</span><br><span class="line"></span><br><span class="line">var jso3=JSON.stringify(jso1);</span><br><span class="line"></span><br><span class="line">console.log(jso3);</span><br><span class="line"></span><br><span class="line">var jso4=JSON.parse(&#123;</span><br><span class="line"></span><br><span class="line">&apos;a&apos;:&quot;name&quot;,&quot;b&quot;:&quot;age&quot;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var jso4=JSON.parse(&apos;&#123;\&quot;a\&quot;:\&quot;name\&quot;, \&quot;b\&quot;:\&quot;age\&quot;&#125;&apos;);</span><br><span class="line"></span><br><span class="line">console.log(jso4);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>参考一：百度百科</p><p>参考二：Json对象和Json字符串的区别</p><p>参考三：json属性名必须加引号的讨论</p><h1 id="更多讨论"><a href="#更多讨论" class="headerlink" title="更多讨论"></a>更多讨论</h1><p>Q：JSON对象有什么遍历方法，如何做</p><p>A：用jq方法$.each遍历json对象</p><p>Q：angularjs如何转换字符串和对象</p><p>A：angular.fromJson( );</p><pre><code>angular.toJson();</code></pre><p>Q：json和jisonp有什么区别</p><p>A：json返回的是一串数据；而jsonp返回的是脚本代码（包含一个函数调用）</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的原型链是什么？</title>
      <link href="/2017/12/26/JS_%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2017/12/26/JS_%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>JS中万物皆对象，但是分为两大类，函数对象，普通对象</p><p>所有的函数对象都有一个prototype属性，这个属性引用了一个对象，即原型对象，也称原型。 然而普通对象是没有prototype属性，只有<em>proto</em>属性</p><h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><p>vara = {};console.log(a.prototype);//undefined</p><p>console.log(a.<strong>proto</strong>);//Object {}</p><p>var b =function(){}</p><p>console.log(b.prototype);//b {}</p><p>console.log(b.<strong>proto</strong>);//function() {}</p><p>/<em>1、字面量方式</em>/</p><p> var a = {};</p><p>console.log(a.<strong>proto</strong>);  //Object {}</p><p>console.log(a.<strong>proto</strong> === a.constructor.prototype); //true</p><p> /<em>2、构造器方式</em>/</p><p>var A = function(){};</p><p>var a = new A();</p><p> console.log(a.<strong>proto</strong>); //A {}</p><p>console.log(a.<strong>proto</strong> === a.constructor.prototype); //true</p><p> /<em>3、Object.create()方式</em>/</p><p>var a1 = {a:1}</p><p> var a2 = Object.create(a1);</p><p>console.log(a2.<strong>proto</strong>); //Object {a: 1}</p><p>console.log(a.<strong>proto</strong> === a.constructor.prototype); //false</p><p>constructor 属性返回对创建此对象的数组函数的引用</p><p><em>proto</em>的指向取决于对象创建时的实现方式</p><p>大多数情况下，<em>proto</em>可以理解为构造器的原型，即：<em>proto</em> === constructor.prototype</p><p>但是通过Object.create()创建的对象不使用此等式</p><p>functionFoo1(){this.name1 =’1’;}</p><p>functionFoo2(){this.name2 =’2’;}</p><p>Foo2.prototype =newFoo1();</p><p>functionFoo3(){this.name =’3’;}</p><p>Foo3.prototype =newFoo2();</p><p>varfoo3 =newFoo3();</p><p>console.log(foo3);</p><p>当我们「读取」 foo3的某个属性得时候，jS 引擎会做下面的事情：</p><ol><li><p>看看 foo3 对象本身有没有这个属性。没有就走到下一步。</p></li><li><p>看看 foo3.<strong>proto</strong> 对象有没有这个属性，发现 foo3.<strong>proto</strong> 有这个属性，于是找到了</p></li><li><p>如果 foo3.<strong>proto</strong> 没有，那么浏览器会继续查看 foo3.<strong>proto</strong>.<strong>proto</strong></p></li><li><p>如果 foo3.<strong>proto</strong>.<strong>proto</strong> 也没有，那么浏览器会继续查看 foo3.<strong>proto</strong>.<strong>proto</strong>.proto__</p></li><li><p>直到找到 或者 <strong>proto</strong> 为 null。</p></li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>若想访问一个对象的原型，应该使用什么方法？</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>1、使用<em>proto</em>属性</p><p>每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法。</p><p>对象<strong>proto</strong>属性的值就是它所对应的原型对象；</p><p>使用<strong>proto</strong>是有争议的，而且是不鼓励的。 它从来没有被包括在EcmaScript语言规范中，但是现代浏览器实现了它, 无论如何。<strong>proto</strong>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 建议使用Object.getPrototyOf()</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>参考一： JS重点整理之JS原型链彻底搞清楚</p><p>参考二： 三张图搞懂JavaScript的原型对象与原型链</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Q：prototype和<em>proto</em>区别</p><p>A：所有的函数对象都有一个prototype属性，这个属性引用了一个对象，即原型对象，也称原型。 然而普通对象是没有prototype属性，只有<em>proto</em>属性</p><p>Q：constructor 代表什么</p><p>A：constructor 属性返回对创建此对象的数组函数的引用</p><p>Q:<em>proto</em>的指向哪里</p><p>A:<em>proto</em>的指向取决于对象创建时的实现方式</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angularjs双向绑定后，发生了什么事情？view层和controller层是如何进行绑定的？</title>
      <link href="/2017/12/19/angular_%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2017/12/19/angular_%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>双向绑定，是从界面的操作能实时反映到数据，数据的变更也能</p><p>实时展现到界面</p><h2 id="如何绑定"><a href="#如何绑定" class="headerlink" title="如何绑定"></a>如何绑定</h2><p>如果我们自己实现双向数据绑定该怎么写？</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>angular是一个MVVM（Model-View，View-Model）模式的框架。</p><p>MVC:View传送指令到Controller；Controller完成业务逻辑后，要求Model改变状态；</p><p>Model将新的数据发送到View；所有通信都是单向的</p><p>MVVM它采用双向绑定：View的变动，自动反映在ViewModel，反之亦然。</p><p>View是angularjs编译html后呈现出来的，需要编译的是controller中的定义的属性和方法以及directive中定义的指令。</p><p>View和controller是独立开来的，他们之间的纽带就是scope。Controller负责向scope中提供属性和方法，</p><p>便于和view层面的html进行交互。</p><p>Angular双向绑定通过$watch,$digest，$apply实现的。</p><blockquote><p>watch序列</p></blockquote><p>watch监控model中是否有变化，会记录last值，也就是改变后的值，每一个model都会增加一个watch到watch队列中。</p><blockquote><p>digest循环</p></blockquote><p>当浏览器接收到可以被angular context处理的事件时，$digest循环就会触发，这个循环有两个子循环，</p><p>一个处理evalAsync队列，另一个处理watch队列，$digest会遍历$watch</p><p>既然所有的$watch都检查完了，那就要问了：有没有$watch更新过？如果有至少一个更新过，这个循环就会再次触发，</p><p>直到所有的$watch都没有变化。这样就能够保证每个model都已经不会再变化。记住如果循环超过10次的话，</p><p>它将会抛出一个异常，防止无限循环。 当$digest循环结束时，DOM相应地变化。</p><p>每一个进入angular context的事件都会执行一个$digest循环，也就是说每次我们输入一个字母循环都会检查整个页面的所有$watch。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>$digest和$apply有何区别？干嘛不直接使用$digest?</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>这里值虽然改变了，但是没有强制执行$degest,watch根本没有执行</p><p>一般带ng的事件angular都会给你自动添加好了apply，但是你要操纵事件的时候加上apply才能实现数据输出到view层中。</p><p>为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行，</p><p>而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了</p><p>当你传入一个function到$apply()中的时候，这个function会被包装到一个try…catch块中，所以一旦有异常发生，</p><p>该异常会被$exceptionHandler service处理。</p><p>1.$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。</p><p>2.当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p><h1 id="更多讨论"><a href="#更多讨论" class="headerlink" title="更多讨论"></a>更多讨论</h1><p>Q、angular是什么框架</p><p>A、angular是一个MVVM（Model-View，View-Model）模式的框架</p><p>Q、为什么在ng-click里面调用$digest的话，会报错呢</p><p>A、因为Angular的设计，同一时间只允许一个$digest运行，</p><p>而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了</p><p>Q、$digest和$apply有何区别</p><p>A、1.$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。</p><p>2.当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p><p>7.参考文献</p><p><a href="http://www.cnblogs.com/bigdataZJ/p/AngularjsInAction2.html" target="_blank" rel="noopener">http://www.cnblogs.com/bigdataZJ/p/AngularjsInAction2.html</a> view和controller的那些事儿</p><p><a href="https://github.com/xufei/blog/issues/10" target="_blank" rel="noopener">https://github.com/xufei/blog/issues/10</a>  Angular沉思录（一）数据绑定</p><p><a href="http://www.angularjs.cn/A0a6理解$watch，$apply和$digest" target="_blank" rel="noopener">http://www.angularjs.cn/A0a6理解$watch，$apply和$digest</a> —理解数据绑定过程</p>]]></content>
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx的反向代理跨域</title>
      <link href="/2017/12/01/Nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F/"/>
      <url>/2017/12/01/Nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址， b页面为域名地址，所进行的访问行动都是跨域</p><h1 id="产生的原因？"><a href="#产生的原因？" class="headerlink" title="产生的原因？"></a>产生的原因？</h1><p>浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源</p><p>同ip（或domain）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写 本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略</p><p>现代浏览器在安全性和可用性之间选择了一个平衡点。 在遵循同源策略的基础上，选择性地为同源策略“开放了后门”。例如img script style等标签，都允许垮域引用资源,然而， 你也只能是引用这些资源而已，并不能读取这些资源的内容</p><h2 id="同源策略限制以下几种行为："><a href="#同源策略限制以下几种行为：" class="headerlink" title="同源策略限制以下几种行为："></a>同源策略限制以下几种行为：</h2><p>1.Cookie、LocalStorage 和 IndexDB 无法读取</p><p>2.DOM 和 Js对象无法获得</p><p>3.AJAX 请求不能发送</p><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><p><a href="http://www.domain.com/a.jshttp://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/a.jshttp://www.domain.com/b.js</a> 同一域名，不同文件或路径 允许<a href="http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js</a> 同一域名，不同端口 不允许<a href="http://www.domain.com/a.jshttps://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/a.jshttps://www.domain.com/b.js</a> 同一域名，不同协议 不允许<a href="http://www.domain.com/a.jshttp://192.168.4.12/b.js" target="_blank" rel="noopener">http://www.domain.com/a.jshttp://192.168.4.12/b.js</a> 域名和域名对应相同ip 不允许<a href="http://www.domain.com/a.jshttp://x.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/a.jshttp://x.domain.com/b.js</a> 主域相同，子域不同 不允许<a href="http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js" target="_blank" rel="noopener">http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js</a> 不同域名 不允许</p><h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>1、 通过jsonp跨域</p><p>2、 document.domain + iframe跨域</p><p>3、 location.hash + iframe</p><p>4、 window.name + iframe跨域</p><p>5、 postMessage跨域</p><p>6、 跨域资源共享（CORS）</p><p>7、 nginx代理跨域</p><p>8、 nodejs中间件代理跨域</p><p>9、 WebSocket协议跨域</p><h1 id="nginx反向代理解决跨域"><a href="#nginx反向代理解决跨域" class="headerlink" title="nginx反向代理解决跨域"></a>nginx反向代理解决跨域</h1><p>正向代理：代理位于网站和客户端中间， 客户端无法访问某网站，就将请求发送给代理服务器，代理从网站取回来再发送给客户端，网站并不知道为谁提供服务</p><p>反向代理：客户端访问某网站的一个页面， 但是网站并没有，就偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，用户不知道真正提供服务的是谁</p><p>对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过 检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确 处理请求，并且并不知道这个请求是来自代理服务器的。</p><p>简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实 的服务器，让它以为这个http请求是直接来自与用户浏览器的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Location/carrots-admin-ajax/&#123;</span><br><span class="line"></span><br><span class="line">  proxy_passhttp://dev.admin.carrots.ptteng.com/;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proxy-pass把请求代理到其他主机"><a href="#proxy-pass把请求代理到其他主机" class="headerlink" title="proxy_pass把请求代理到其他主机"></a>proxy_pass把请求代理到其他主机</h2><p>两种写法h<a href="http://dev.admin.carrots.ptteng.com/" target="_blank" rel="noopener">http://dev.admin.carrots.ptteng.com/</a>  和  <a href="http://dev.admin.carrots.ptteng.com" target="_blank" rel="noopener">http://dev.admin.carrots.ptteng.com</a></p><p>如果访问url=<a href="http://server/html/test.jsp，则被nginx代理后" target="_blank" rel="noopener">http://server/html/test.jsp，则被nginx代理后</a></p><p>  情况1: 将test/作为根路径，请求test/路径下的资源。</p><p>  情况2: 则被nginx代理后，请求路径会变为<a href="http://proxy_pass/test.jsp，直接访问server的根资源。" target="_blank" rel="noopener">http://proxy_pass/test.jsp，直接访问server的根资源。</a></p><h2 id="carrots-admin-ajax"><a href="#carrots-admin-ajax" class="headerlink" title="/carrots-admin-ajax/"></a>/carrots-admin-ajax/</h2><p>是一个匹配规则，用于拦截请求，匹配任何以/proxy/html/开头的地址，匹配符合以后，停止往下搜索正则。</p><p>对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。</p><p>简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实的服务器，让它以为这个http请求是直接来自与用户浏览器的。</p><h2 id="nginx-rewrite指令执行顺序："><a href="#nginx-rewrite指令执行顺序：" class="headerlink" title="nginx rewrite指令执行顺序："></a>nginx rewrite指令执行顺序：</h2><p>1.执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域，其它xx块类似)</p><p>2.执行location匹配</p><p>3.执行选定的location中的rewrite指令</p><p>如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件</p><p>如果循环超过10次，则返回500 Internal Server Error错误</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>参考一：<a href="https://www.cnblogs.com/gabrielchen/p/5066120.html" target="_blank" rel="noopener">https://www.cnblogs.com/gabrielchen/p/5066120.html</a></p><p>参考二：<a href="http://blog.csdn.net/shendl/article/details/48443299" target="_blank" rel="noopener">http://blog.csdn.net/shendl/article/details/48443299</a></p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>Q：例如img script style等标签，都允许垮域引用资源？</p><p>A：在浏览器中，并且加载的方式其实相当于一次普通的GET请求，唯一不同的是，为了安全起见，浏览器不允许这种方式下对加载到的资源的读写操作，而只能使用标签本身应当具备的能力（比如脚本执行、样式应用等等）。</p><p>Q：JSONP和nginx跨域有什么不同</p><p>JSONP和nginx是完全不同的 是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</p><p>原理：是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</p><p>script标签是可以加载异域的JavaScript并执行的，通过预先设定好的callback函数来实现和母页面的交互。它有一个大名，叫做JSONP跨域，JSONP是JSON with Padding的略称。它是一个非官方的协议，明明是加载script，为啥和JSON扯上关系呢？原来就是这个callback函数，对它的使用有一个典型的方式，就是通过JSON来传参，即将JSON数据填充进回调函数，这就是JSONP的JSON+Padding的含义。JSONP只支持GET请求。</p><p>欢迎留言交流  (´▽`ʃ♡ƪ)</p>]]></content>
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客接入 github issue 评论]]></title>
    <url>%2F2019%2F08%2F06%2Fgit_comment%2F</url>
    <content type="text"><![CDATA[更新，评论系统切换为 gitalkgitment 登录 alert 报错 [object ProgressEvent]，打开 network 这个 gh-oauth.imsun.net 请求失败，https://imsun.github.io/gitment/dist/gitment.browser.js 内向网址 https://gh-oauth.imsun.net 发送了验证请求，这个gh-oauth.imsun.net是作者自行搭建的，现在不在维护了，所以出现了问题 看了 gitment 的 issue 很多人都反应有问题，官方的 demo 也不能用 所以现在切换为 gitalk，方法差不多，只需要改下类名就好 1234567891011121314151617181920212223#comment #gitalk-container(data-gitalk=JSON.stringify(theme.Gitalk) data-date=page.date) link(rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css") script(src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js") script. function commentinit() &#123; setTimeout(()=&gt;&#123; if (this.Gitalk) &#123; let string = JSON.parse(document.getElementById('gitalk-container').dataset.gitalk) var gitalk = new Gitalk(&#123; clientID: string.client_id, clientSecret: string.client_secret, repo: string.repo, owner: string.owner, admin: string.admin, id: document.getElementById('gitalk-container').dataset.date, distractionFreeMode: string.distractionFreeMode &#125;) gitalk.render('gitalk-container') &#125; else commentinit() &#125;,200) &#125; commentinit() 配 置1.去新建 OAuth App 完成注册2.在主题配置文件 _config.yaml 中添加 1234567gitment: enable: true id: &apos;&apos; owner: Tong-H # 你的 github 用户名，可以不用太在意大小写 repo: Tong-H.github.io #存储评论的 repo client_id: 5658f62c9837c979f96f #新建 OAuth App 时的 Client ID client_secret: 36813d127f4f0918cd30231a403e09d81015e014 #新建 OAuth App 时的 Client secret 3.新建一个 comment 组件，看了一些博客，大部分都是用的 ejs，我用的是 Pug，这个区别不大注意，网上有很多文章这段代码都是不可用的，会出现初始化不了的情况，这里贴出的是可用的 引入两个文件，一个 css 和 一个 js使用 dataset 将 hexo 的变量传递给页面 新建 gitment 对象的时候要注意使用 setTimeout 轮询查看 gitment 是否存在文件加载是否完成 1234567891011121314151617181920212223242526block prepend cssFile link(rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css")#comment // 使用 data #gitment_container(data-gitment=JSON.stringify(theme.gitment) data-title=page.title) script(src="https://imsun.github.io/gitment/dist/gitment.browser.js") script. function commentinit() &#123; setTimeout(()=&gt;&#123; if (this.Gitment) &#123; let string = JSON.parse(document.getElementById('gitment_container').dataset.gitment) var gitment = new Gitment(&#123; id: document.getElementById('gitment_container').dataset.title, owner: string.owner, repo: string.repo, oauth: &#123; client_id: string.client_id, client_secret: string.client_secret, &#125;, &#125;) gitment.render('gitment_container') &#125; else commentinit() &#125;,200) &#125; commentinit() Comments Not Initialized需要你先登录下初始化，不要在本地 localhost 登录，因为localhost：4000 和你注册时填写的 Authorization Callback URL 的域名不同，点击登录会跳转到 你的 Authorization Callback URL 页面 当然你也可以再去新建一个 OAuth Application 填 http://localhost:4000/ 也可以 每新建一个文章都需要去初始化，相当于重新开一个 issue 初始化时在评论框点击登录，但是没有跳到授权页面查看页面 login 按钮的 a 标签的 href 是这样的 1&lt;a class="gitment-editor-login-link" href="https://github.com/login/oauth/authorize?scope=public_repo&amp;amp;redirect_uri=https%3A%2F%2Ftong-h.github.io%2F2019%2F08%2F05%2Fhexo_theme%2F&amp;amp;client_id=5658f62c9837c979f96f&amp;amp;client_secret=36813d127f4f0918cd30231a403e09d81015e014"&gt;Login&lt;/a&gt; 其中 redirect_uri 是当前页面的 url，url 的域名和你注册时填写的 Authorization Callback URL 的域名一定要一致，我检查才发现我填的时 http://tong-h.github.io, 但实际请求的却是https 参考文章添加Gitment评论系统踩过的坑 http://xichen.pub/2018/01/31/2018-01-31-gitment/Hexo博客框架下Gitment取代多说评论 https://zonghongyan.github.io/2017/06/29/201706292034/]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 主题制作]]></title>
    <url>%2F2019%2F08%2F05%2Fhexo_theme%2F</url>
    <content type="text"><![CDATA[背景介绍hexo 是一个免费简单的博客框架，有很多好看开源主题，但是当你看到别人的博客和你自己的博客一模一样的时候，还是有点奇怪，熟悉又陌生的感觉 Hexo 内建 Swig 模板引擎，但是可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：layout.ejs，layout.swig 我有尝试过用 Swig，毕竟不需要安装插件，但是用过之后还是果断换回了 Pug(原 jade )，如果你两种模板引擎都没接触过那推荐你用 Swig，上手简单会快些，但如果你也是 Pug 的忠实粉丝，那么还是安装插件吧 你需要安装 2 个插件，渲染 jade 页面的插件和热更新的插件，并保存在 packagejson devDependencies 是开发时需要的插件 1npm install hexo-server hexo-browsersync hexo-renderer-jade --save-dev 手动构建在…\blog\themes 新建一个文件夹，文件夹名称是你主题的名字，一个主题可能是这样的结构 12345678910111213├── languages 语言文件，用于国际化├── layout 页面模板文件├────── index 首页，url 根目录默认加载首页├────── Archive 归档页├────── Tag 标签页├────── Category 分类页├────── Post 文章页├────── Page 页面详情，像404、友链这种自定义页面都是在 page 页面├── scripts 脚本文件夹，在启动时，Hexo 会载入此文件夹内的 JavaScript 文件├── source 主题资源文件，包括页面样式，脚本，字体等├────── css├────── js├────── img 如果你的网站在二级目录可以在网站配置文件_config.yml 更改 url 每个主题都可以有一个 layout 的页面布局文件，因为像 footer、header 等都是可以做复用的，所以我们可以最大化的利用 pug 或者 swig 等模板引擎的局部模板功能比如 pug，更多详细内容可以查看官方文档 1234extends // 被继承的模板路径block // 定义一个代码块，可以被子模块填充、修改、覆盖prepend // 向块的头部添加内容append // 向块的尾部添加内容 Yeoman 生成基本框架123npm install yo -g // 全局安装 Yeomannpm install generator-hexo-theme -g // 主题生成工具yo hexo-theme // 生成主题 数据填充hexo 提供了很多辅助函数和变量在开发过程中 hexo 是服务端渲染，所以他的所有变量是 node 的全局变量，非页面的 部署后点击分类 404分类是使用辅助函数 list_categories() 生成, 本地一切正常部署后点击分类是 404,可能是因为你的分类名称是大写字母，我自己的原来分类是首字母大写，后来改成全部大写，就出现了这个问题, 可能不止分类有这个问题 解决办法：使用 toLowerCase() 将 a 标签 herf 全部改成小写字母 1234(function () &#123; let list = document.getElementsByClassName('category-list-link') for(const i of list) i.href = i.href.toLowerCase()&#125;)() 一些插件WordCount 字数统计 12345678910111213141516// 安装yarn add hexo-wordcount# ornpm i --save hexo-wordcount// 字数统计wordcount(post.content)// 阅读时长预计min2read(post.content)// 设置阅读速度min2read(post.content, &#123;cn: 300, en: 160&#125;)// 总字数统计totalcount(site) 卜蒜子 阅读量统计 12&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; gitalk, gitment 评论模板 参考文章*hexo 主题制作官方文档： https://hexo.io/zh-cn/docs/permalinks]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客折腾总结]]></title>
    <url>%2F2019%2F08%2F05%2Fabout_blog%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前看到有人说，写 Blog 的人都是这样的，从刚接触 Blog 感觉很新鲜，用的都是免费的开箱即用先搭起来再说，然后发现免费的限制总是很多，开始不安分想法开始变得有点多，开始自己购买域名和空间，搭建独立博客想怎么折腾怎么折腾，后来又觉得独立博客的管理太麻烦，只是想要个能写能看能发布的简单的，再有那么一点点的自定义，周周转转还是回来了 &emsp;&emsp;前段时间自己买了域名、服务器、搭建环境，用 koa 写接口 + mysql 管理 + pug（原 jade ） 写页面做服务器渲染，接触了很多没接触过的东西 &emsp;&emsp;但是看看这个博客其实还是用 hexo 生成，之前是用的 next 主题，很好看符合大多数人的审美，但是用的人太多了，其实再看到有一个一样的博客的时候就想换了，所以这次还是自己写了个主题，一直在犹豫要不要发布到 hexo 的主题列表，又想独一无二又想骗几个 star，还是发了万一有人喜欢呢，虽然样式方面还是被周围同志吐槽了一下，但是我自己觉得挺好看的啊，就这样，但是评论截至现在还没搞好 &emsp;&emsp;关于 koa，以前用过 express，其实已经不大记得了，所以这次用了 koa，官网很简单很短但是全英文所以我看得还是很慢，也看了阮一峰的koa的教程，上手要比当时用 express 快些，翻了翻以前的代码再看看现在 koa 的代码，感觉差别不大，自己使用场景还是太少了 &emsp;&emsp;以前写的项目都是前端写页面，后端给接口，前后端分离，做服务器渲染还是第一次，也是第一次接触 pug、ejs 这样的模板引擎，用之前也在 ejs 和 pug 之间犹豫，用ejs的人比较多，ejs 的结构更像 html 上手也更简单，pug 上手比起ejs稍微难些但是回了就很爽，我是想着学会了难的是那么简单的需要的时候再学也不会花费很多时间，所以最后用了 pug，使用感一个字 “棒”，用起来实在是太舒服了，pug 之于 html 就像 scss 之于 css 一样，jq 之于 js 一样，大大的减少了代码量，代码简单干净规范，后面写 hexo 主题的时候因为 hexo 本身不支持 pug 需要安装一些插件才行所以用了 Swig，Swig 确实更简单些，文档就那么几段话上手很快，但是写了个开头果断还是换成了 pug，后来在项目里 vue 的模板引擎也换成了 pug &emsp;&emsp;关于服务器，之前也买过但是只是一个空间，这次买了 linux 服务器，以前没用过 linux 从搭建到部署，一把血泪史，各种命令实在太多了，后面一定要把我的小笔记里关于 linux 的整理一下给以后用的时候看 &emsp;&emsp;关于 mysql，一直接触的都不多，只会一些简单的增删查改，这次接触了一些更难的吧，比如群组、多条件查询，还是要感谢旁边的后端同学 &emsp;&emsp;关于正则，之前用正则机会一直不多，都是断断续续的，时不时有那么一个场景会用到就在你快要忘了的时候，所以我的小笔记关于正则记得很详细，公司大佬对正则很熟练，成功的让我看到了正则的魅力还有强大的地方，而这次写 blog 因为需要在本地筛选文件、过滤文章内容提取文章信息，所以其实用了蛮多正则的，正则确实是很强大的工具 &emsp;&emsp;总的来说，涨了知识，也不算白折腾，但是服务器也买了、域名也买了，还是想要再弄点什么]]></content>
      <categories>
        <category>RESTS</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析]]></title>
    <url>%2F2019%2F08%2F05%2Fdomain%2F</url>
    <content type="text"><![CDATA[二级域名设置阿里云的域名解析设置页面 —&gt; 点击添加记录 —&gt; 出现弹框 @：直接解析主域名 aliyun.com **：泛解析，匹配其他所有域名 .aliyun.com mail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器 二级域名：如：abc.aliyun.com，填写abc 手机网站：如：m.aliyun.com，填写m 显性URL/隐形URL：转发的地址必须完成备案且备案接入商为阿里云 TTL：为缓存时间，数值越小，修改记录各地生效时间越快，默认为10分钟]]></content>
      <categories>
        <category>SERVER</category>
      </categories>
      <tags>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm && yarn 差异以及常用命令]]></title>
    <url>%2F2019%2F07%2F01%2Fnpm%26%26yarn%2F</url>
    <content type="text"><![CDATA[yarn 从去年vue-cli更新以来一直用，但一直都没认真了解过 yarn 背景介绍安装方法 三种安装方式Yarn 是一个包管理器，代码通过包（package） 或者模块（module）的方式来共享， 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。 yarn npm 差异 同步安装：npm 是按照队列执行每个 package，Yarn 是同步执行所有任务 离线模式：Yarn可以从缓存中获取以前安装过的安装包，而npm每次都从网络下载 安装版本统一：yarn.lock 文件记录了所有安装模块的版本号，这样使我们每次拉取同一个项目依赖时使用都是一样的版本号，而 npm 需要执行 npm shrinkwrap 才会生成一个锁定文件 npm-shrinkwrap.json npm 输出内容多长，安装慢就算了还老是失败，相较而言 yarn 真的快多了 常用命令更多命令 官网 CLI 命令 npm 命令 yarn 命令 命令介绍 npm install xxx npm i xxx yarn 安装但不写入package.json npm install –save xxx npm i -s xxx yarn add xxx 安装xxx模块，并且记录到package.json字段对应的dependency npm install –save-dev xxx npm i -D xxx yarn add xxx –dev 安装xxx模块，并且记录到package.jso字段对应的dev-dependency是开发环境必须依赖的模块 npm install –global xxx npm i -g xxx yarn global add xxx 全局安装xxx模块，如果模块里package.json有bin配置，会自动链接，作为cli命令 npm uninstall react –save yarn remove taco 安装并记录package.json中的dependency字段 npm update –save yarn upgrade 更新并记录package.json中的dependency字段 参考文章官网命令知乎文章：npm和yarn的区别，我们该如何选择？]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解浏览器缓存机制]]></title>
    <url>%2F2019%2F05%2F14%2Fbrowser_cache%2F</url>
    <content type="text"><![CDATA[有关浏览器缓存的几个疑问 浏览器缓存判断流程？ 两种分类协商缓存和强制缓存是什么？怎么判断？ 缓存的资源放在哪儿？ 不同的刷新对缓存的影响？ 浏览器缓存的流程当客户端请求某个资源，首先需要询问浏览器是否存在缓存有以下三种结果： 不存在，那么直接向服务器发起请求，就像第一次访问该网站一样 存在，通过Cache-Control、Expires判断后缓存已失效，那么则使用协商缓存，携带该资源缓存标识向服务器发起请求，服务器根据 http header 判断后决定是否使用缓存，若协商缓存失效重新拉取请求结果则状态码为 200 ，若协商缓存生效那么继续使用缓存状态码为 304 存在，通过Cache-Control、Expires判断后未失效，那么继续使用缓存状态码为 304 图示： 123456789101112131415161718 浏览器发起请求 | | 是否有缓存 ——— 是 ——— 缓存是否失效 ——— 是 ——— 协商缓存 ———— 成功 | | | | | | | | 否 否 失败 | | | | | |—————————————————————|————————————————————| | | | | 向服务器请求资源 读取缓存————————————————————————————| | | | |根据 http header 存缓存 | | | |—————————————————————| | 完成加载 所以有两种缓存类型，强制缓存和协商缓存，优先判断的不需要发 http 请求的是强制缓存当强制缓存无效时才启用协商缓存，协商缓存需要发送 http 请求交由服务器判断，可以应用于一些时常需要动态更新的资源文件 强制缓存浏览器判断强制缓存是否存在和是否失效这两个：Cache-Control、Expires Cache-Control * http/1.1的字段，控制网页缓存的主要规则，取值： public： 所有内容都将被缓存 private：默认值，所有内容只有客户端可以缓存， CDN 等中继缓存服务器不能缓存 no-cache：客户端缓存内容，但由协商缓存决定是否使用缓存 no-store：所有内容都不会被缓存 max-ag=xxx：缓存内容在xxx秒后失效 max-stale=xxx: 指定时间内，即使缓存过时依然使用资源 min-fresh=xxx：缓存的资源至上要保持指定时间的新鲜期 only-if-cached：仅仅返回已经缓存的资源，不访问网络，无缓存返回 504 no-transform：强制要求代理服务器不要对资源进行转换，禁止代理服务器对 Content-Type、Content-Encoding, Content-Range 字段进行修改 Expires * http/1.0 的字段，请求结果缓存到期时间，优先级低于 Cache-Control:max-age由于 Expires 设置的时绝对时间若 Expires 和 Cache-Control:max-age 两者都没出现浏览器默认使用启发式算法：响应头的（ Date - Last - Modified ） 10，也就是（响应时间 - 文件最后修改时间 ） 10 协商缓存Etag / If-None-Match 优先级高于Last-Modified / If-Modfied-Since，同时存在前者生效 Last-Modified / If-Modified-Since / If-Unmodified-since * Last-Modified 是服务器响应请求时返回该资源在服务器的最后修改时间 If-Modified-Since 是客户端再次发起请求时携带上次服务器返回的Last-Modified, 服务器接收到这个时间将与该资源在服务器最后修改的时间进行对比，若服务器修改的时间大于客户端发送的时间，则状态码200重新返回资源，否则返回304表示资源无更新继续使用缓存 If-Unmodified-since 同上，资源未修改正常执行更新反之返回412 Etag / If-None-Match * Etag 是资源唯一标识符，服务器响应请求时返回当前资源的唯一标识符 If-None-Match 是客户端再次发起该请求时携带上次请求时服务器返回的唯一标识符 Etag，服务器接收到该值会与该资源在服务器的 Etag 值做对比，一致状态码 304 表示无更新继续使用缓存，反之则返回资源文件状态码 200 缓存的资源在哪儿？浏览器通过 http 请求获取到资源，那么资源会缓存在哪儿 memory cache：内存缓存，会将编译解析的文件，直接存入该进程内存中，占据一定的内存资源，以便下次快速读取，进程关闭即清空 from disk cache：硬盘缓存，盘缓存是将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行i/o操作，然后解析读取，速度比内存缓存慢 浏览器读取缓存时 memory ——&gt; disk ——&gt; 两者都没有便发起网络请求 ——&gt; 获取资源缓存到硬盘和内存 在浏览器中，css 文件会存入硬盘文件中，因为 css 文件通常只在页面渲染时加载一次，而 js 和图片等文件解析执行后直接存入内存缓存中，是因为可能会频繁读取，当刷新页面时只需直接从内存缓存中读取 浏览器行为对缓存的影响 刷新网页，如果缓存没有失效，浏览器直接使用缓存，反之 http 请求数据 手动刷新 / F5，浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新 强制刷新 / Ctrl + F5，浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件 其他 其他和缓存相关的 header 头部 * date 响应生成时间 age 代理服务器生成，表示代理服务器对于请求资源的已缓存时间, 单位为秒 Pragma：no-cache: http / 1.0 作用和 Cache-Control:no-cache 一样，如果在控制台勾选 Disable cache, 浏览器自动带上该字段 vary 缓存版本，可用于区分 pc 和 移动端需要加载的资源 浏览器禁用缓存 * 1&lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/&gt; 参考文章浏览器的缓存机制小结彻底理解浏览器的缓存机制[]]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas 文字粒子特效]]></title>
    <url>%2F2019%2F04%2F23%2Fcanvas-fontparticle%2F</url>
    <content type="text"><![CDATA[一个文字粒子效果,折腾了一些时间，纯粹觉得好玩 点这里看效果 随机初始化部分粒子1、首先要明白每个粒子都是一个对象，都有自己的移动轨迹，起点，移动速度，终点 2、粒子活动轨迹：初始化 —- 聚合拼合文字形状 —- 散开 —- 再聚合 —- 散开… 3、我们需要根据动画时间调整粒子移动的速度来安排他们的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Point&#123; constructor() &#123; this.startx = Math.floor(Math.random() * docsize[0]), // 初始起点 this.starty = Math.floor(Math.random() * docsize[1]), this.speedx = (Math.random() * 2 - 1) * pointspeed, // 移动速度 this.speedy = (Math.random() * 2 - 1) * pointspeed, this.endx = 0, // 终点 this.endy = 0, this.color = Math.floor(Math.random() * 5) // 粒子颜色 &#125; endpoint(x, y) &#123; this.endx = x this.endy = y &#125; animal() &#123; this.startx += this.speedx this.starty += this.speedy // 到达边界改变粒子运动方向 this.speedx *= this.startx &gt; docsize[0] || this.startx &lt; 0 ? -1 : 1 this.speedy *= this.starty &gt; docsize[1] || this.starty &lt; 0 ? -1 : 1 // 调整点的移动速度用以聚和拼合文字 if(time === 100 || time === 600 || time === 1100) &#123; this.speedx = (this.endx - this.startx) / joinspeed this.speedy = (this.endy - this.starty) / joinspeed &#125; // 到达终点后静止不动 if(time === 100 + joinspeed || time === 600 + joinspeed || time === 1100 + joinspeed) &#123; this.speedx = 0 this.speedy = 0 &#125; // 散开 if(time === 300 || time === 800) &#123; this.speedx = (Math.random() * 2 - 1) * pointspeed this.speedy = (Math.random() * 2 - 1) * pointspeed &#125; maincontent.beginPath() maincontent.fillStyle = color[this.color] maincontent.arc(this.startx, this.starty, 7, 0, Math.PI * 2) maincontent.fill() &#125;&#125; 使用 canvas 画板生成文字12345678// 【文字面积，循环时用于判读y轴高度，粒子大小间隔， 文字宽度】let [imgdata, cyclic, size, textwith] = [&#123;&#125;, 1, 16, 0]textcontext.font = "normal 900 " + fontsize +"px Avenir, Helvetica Neue, Helvetica, Arial, sans-serif"textwith = Math.floor(textcontext.measureText(text).width)textcontext.fillStyle = '#ff0000'textcontext.fillText(text, (docsize[0] - textwith) / 2, (docsize[1]) / 2)textwith = ~~ (textwith) * size + size 遍历 imageData 获取文字区域的像素坐标不了解 imagedata 怎么用？ 看看这篇文章cannvas的imagedata对象 获取坐标这里有很多种方法，我看了一些教程好像没人像我这么写，要注意的是 imageData 4个元素为一个像素，也就是一个R G B A 值，A 是 alpha 透明度 空白的区域rgba就是 0,0,0,0 , 文字区域就是有颜色的如果你没有设置字体颜色默认是黑色 rgba 就是 0,0,0,255，通过判断第四个元素可以获取文字区域 但是我建议重新设置一个其他的颜色比如红色 255,0,0,255，用第1个和2个数字来判断这样字体边缘会圆滑些，因为在字体边缘黑色和白色的交界处可能有某几个像素不是透明的 每个坐标最后都会生成一个圆，所以这里获取的是圆心的坐标，圆之间还需要留有空隙，所以遍历的时候你要根据你的圆的大小掌握好间隔 获取文字区域粒子数量后需要判断，目前屏幕上现有的粒子是否足够拼合和文字或者是否还需再添加粒子 确定粒子数量后再将文字坐标作为粒子移动终点赋值给粒子 12345678910111213141516171819202122232425// 获取文字所在区域，尽可能减小面积imgdata = textcontext.getImageData(0,0, textwith, fontsize * 2)textcontext.clearRect(0, 0, docsize[0], docsize[1])// 粒子圆心坐标，粒子数组let [x, y, len] = [0, 0, 0]// 遍历data数据查找文字所在的坐标for (var i = 0; i &lt; imgdata.data.length; i += size * 4) &#123; if (imgdata.data[i] === 255 &amp;&amp; imgdata.data[i+3] === 255) &#123; // 判断当前粒子数量是否能够拼合文字 if (len &gt; pointarr.length - 1) pointarr.push(new Point) // 获取每个粒子聚拢的终点 pointarr[len].endpoint(i /4 % textwith, cyclic) len ++ &#125; if (i/4 == cyclic * textwith) &#123; cyclic += size i = textwith * (cyclic-1) * 4 &#125;·&#125;pointarr.length - 1 - len &gt; 0 ? pointarr.splice(len, pointarr.length - len) : '' 源码带有详细的注解点这儿更多效果开源不易，觉得还不错点个 start 吧 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker && postMessage && onMessage 使用教程]]></title>
    <url>%2F2019%2F04%2F21%2Fwebworker%2F</url>
    <content type="text"><![CDATA[最近使用 iframe 的时候想要获取 iframe 文档信息的时候遇到了跨域问题，最后使用 postmessage 做父子页面通信解决需求也顺便学习了下 webworker 的使用webWoker 使用依赖 postMessage() 和 onMessage(), 所以先说这两个吧 postMessage &amp;&amp; onMessage 提供网页文档之间互相发送和接收信息的功能，可用于解决跨域访问的问题 会在所有页面脚本执行完毕之后(包括方法之后或者之前设置的timeout 事件)再执行 挂载于window对象上 postMessage 语法： otherWindow.postMessage(message, targetOrigin, [transfer]);&emsp;&emsp;message: 发送的数据，不限类型，因为他自己会序列化&emsp;&emsp;targetOrigin：通过窗口的origin属性指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI&emsp;&emsp;transfer：可选参数；一个 Transferable 对象([什么是Transferable[(https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable))，和message 同时传递的,对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权 onMessage 语法：12window.addEventListener('message', function(event) &#123; ... &#125;)window.onmessage = function(event) &#123; ... &#125; 获取到的 event 对象包含&emsp;&emsp;data：接收的数据对象，对应 postMessage 的 message 参数&emsp;&emsp;origin：消息发送方窗口的 origin，字符串由 协议、“://“、域名、“ : 端口号”拼接而成&emsp;&emsp;source：对发送消息的窗口对象的引用 举个小栗子 父页面向子页面传值 12345678910111213141516171819// 在 iframe 加载完毕后，获取 iframe 的 window 对象，调用 postMessage 方法&lt;body&gt; &lt;div&gt;a page&lt;/div&gt; &lt;iframe src="b.html" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; var frame = document.getElementById('frame') frame.onload = function()&#123; frame.contentWindow.postMessage(&#123; name: 'a page' &#125;,'*'); &#125; &lt;/script&gt;&lt;/body&gt;// 子页面监听 message 事件设置回调打印 event&lt;body&gt; &lt;div&gt;b page&lt;/div&gt; &lt;script&gt; window.addEventListener("message", (event) =&gt; console.log('this b page', event), false); &lt;/script&gt;&lt;/body&gt; 子页面向父页面传值 1234567891011121314151617// 父页面监听 message 事件设置回调打印 event&lt;body&gt; &lt;div&gt;a page&lt;/div&gt; &lt;iframe src="b.html" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; window.addEventListener("message", (event) =&gt; console.log('this a page', event), false); &lt;/script&gt;&lt;/body&gt;// 使用 parent 获取 window 对象，调用 postMessage 方法&lt;body&gt; &lt;div&gt;b page&lt;/div&gt; &lt;script&gt; console.log(parent) parent.postMessage( &#123;name: 'b page'&#125;, '*'); &lt;/script&gt;&lt;/body&gt; Workers 我自己感觉很多比较麻烦耗内存的js逻辑操作都可以放在worker里，比如轮询服务器状态或者一些很耗时量很大的数据操作用 让脚本在浏览器后台线程中运行 在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性，window对象下可用的方法 worker 中也能再创建 worker 由于安全限制 Worker 不能读取本地文件，所以脚本必须来自网络，读取本地文件会报错 “Uncaught SecurityError: Failed to create a worker: script at ‘(path)/worker.js’ cannot be accessed from origin ‘null’.” 关于兼容性 用法在使用 worker 的 js文件里1234567// 使用 Worker() 指定脚本 url 创建一个新的 worker// 参数就是 Worker 线程所要执行的任务// Worker 使用 postMessage 和 onMessage 进行通信var myWorker = new Worker("worker.js");// 使用 postMessage() 和 onMessage() 发送和接收数据myWorker.postMessage("request"); 在 worker.js文件1234567// 消息响应onmessage = function(e) &#123; console.log(e.data); console.log(self) // 消息回传 postMessage(workerResult);&#125; 关闭/错误/加载脚本1234567891011121314// 在 main.js 文件中，强制终止worker.terminate();// 在 worker 线程中，自己关闭self.close();// error 错误代理worker.onerror(function (event) &#123;&#125;);// 发送的数据无法序列化成字符串时，会触发这个事件Worker.onmessageerror(function (event) &#123;&#125;);// worker 使用 importScripts() 加载脚本，可以加载多个importScripts('script1.js', 'script2.js'); 小栗子如果你现在没有条件加载网络上的文件，可以使用 URL.createObjectURL 方法建立缓存 URL可以试着运行一下面两个页面感受一下 可以运行一下这个页面，一个普通的 for 循环，因为数字太大运行时会有明显的卡顿1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;Test Web worker&lt;/title&gt; &lt;script type="text/JavaScript"&gt; window.onload = function()&#123; for(var num=99;num&lt;1000000000;num++)&#123; document.getElementById("numshow").innerHTML += event.data+"&lt;br/&gt;"; &#125; &#125;&lt;/script&gt;&lt;/head&gt; &lt;body id="numshow"&gt;&lt;/body&gt;&lt;/html&gt; 这个可以使用 URL.createObjectURL 方法建立缓存 URL1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt; &lt;head&gt; &lt;title&gt;Test Web worker&lt;/title&gt; &lt;script type="text/JavaScript"&gt; window.onload = function() &#123; console.log(5); var worker = new Worker(URL.createObjectURL(new Blob(["(" + webWorker.toString() + ")()"], &#123;type: 'text/javascript'&#125;))); worker.onmessage= (event) =&gt; &#123; // 数据打印 console.log(event.data); document.getElementById("numshow").innerHTML += event.data+"&lt;br/&gt;"; // 向 worker 线程发送数据 event.data === 1 ? worker.postMessage('num'):'' &#125;; &#125; function webWorker() &#123; // worker 对象 self console.log(self) // 接收来自主线程的数据 self.onmessage = function (event) &#123; console.log(event.data); &#125; for (var num = 1; num &lt; 1000000000; num++) &#123; // 当 num === 200的时候关闭 worker 线程 num === 200 ? (postMessage("worker关闭"), close()) : postMessage(num**2) &#125; &#125; &lt;/script&gt;&lt;/head&gt; &lt;body id="numshow"&gt;&lt;/body&gt;&lt;/html&gt; 参考文章postMessage：MDN https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessagewebworker：MDN https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers阮一峰：http://www.ruanyifeng.com/blog/2018/07/web-worker.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[typescript 学习之基础篇]]></title>
    <url>%2F2019%2F03%2F25%2Fts-1%2F</url>
    <content type="text"><![CDATA[vue-cli已经内置了 TypeScript 工具支持，在 Vue (3.x) 中也计划了相当多的 TypeScript 支持改进，很多大佬以及用过的人也都在推荐入坑，而且目前也比较成熟，资源也很丰富，值得入坑 ? typescript官方介绍 TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上我的理解是 TypeScript扩展了JavaScript的语法，为 js 增加了类型机制，引入类，接口，枚举，泛型，方法重载等一系列的概念和方法，丰富了js的使用，而且和 VScode 搭配写起来是真的舒服 全局安装：npm install -g typescript编译命令：tsc hello.ts TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀在报错的时候终止 js 文件的生成，在 tsconfig.json 中配置 noEmitOnError 原始数据类型声明原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。在ts中变量声明，变量或者参数都必须要声明其类型1234567891011121314151617booleanlet isDone: boolean = false;let createdByBoolean: boolean = Boolean(1);numberlet num: number = 6; // 6stringlet string = 'string'// ` 用来定义 ES6 中的模板字符串，$&#123;expr&#125; 用来在模板字符串中嵌入表达式let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; Null 和 Undefined 和 voidlet u: undefined = undefined;let n: null = null;// 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：let unusable: void = undefined; // void只能赋值为 undefined 和 null 内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量这些内置对象的定义文件可以在TypeScript 核心库的定义文件查找 ECMAScript 标准的内置对象比如Boolean、Date、RegExp等，更多内置对象MDN123let b: Boolean = new Boolean(1);let d: Date = new Date();let r: RegExp = /[a-z]/; DOM 和 BOM 的内置对象比如Document、HTMLElement、Event、NodeList等12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // ...&#125;); 赋值多个类型任意类型 any：表示允许赋值为任意类型，且能在赋值过程中改变类型12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 变量声明，赋值但未指定其类型，TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型12let a = '7' // TypeScript会推断为string类型a = 7 // 这个赋值会导致报错 变量声明，未赋值未指定其类型，会被推断成 any类型而完全不被类型检查123let a // any 类型a = '7'a = 7 联合类型：可以指定多种类型，可赋值为其中一种，使用 |` 分隔每个类型示例1234let a: string | number; // 指定类型为 string 和 numbera = '7'; // 类型推断为 numbera = 7; // 类型推断为 stringa = true; // 类型推断为 boolean 报错 使用接口定义对象类型 接口使用interface 关键字定义 接口首字母大写 对象类型的属性分为确定属性、只读属性、可选属性、任意属性 确定属性：也就是固定的属性，接口有 变量声明时就必须有, 只读属性：readonly 关键字定义，第一次赋值后无法更改，是在接口创建后只能 第一次给对象赋值的时候为只读属性赋值 ， 而不是第一次给只读属性赋值 可选属性：属性名 + ?，表示该属性可以不存在 任意属性：[propName: string]: any; 冒号前半部分表示任意属性取 string类型的值，后半部分是类型的子集 一旦定义了任意属性，那么另外三种属性的类型都必须是它的类型的子集，可将任意属性的类型的子集定义为 联合类型 或者 any 类型 一个栗子：12345678910111213interface Person &#123; readonly id: number; // 只读属性 a: string; // 确定属性 b?: number; // 可选属性 [propName: string]: string; // 任意属性&#125; // 会报错，任意属性类型的子集为 string，而 b 和 id 的类型为number，不属于任意属性类型的子集let obj: Person = &#123; // 报错 没有给只读属性 id 赋值 a: '123', b: 456, c: '789',&#125;;obj.id = 89757; // 报错 因为这不是对象第一次赋值 修改为123456789101112interface Person &#123; readonly id: number; a: string; b?: number; [propName: string]: string | number;&#125;let obj: Person = &#123; id: 8, a: '123', b: 456, c: '789',&#125;; 数组类型：类型 + 方括号， 数组的每一项元素都必须符合类型 123let a: number[] = [1, 2, 3, 5]; // 数组元素类型只能是 numberlet c: (number | string)[] = [1, '1', 2, 3, 5]; // 联合类型和数组的结合let b: any[] = [1, '2', 3, &#123;a: 1&#125;]; // any 类型 接口定义1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 函数的类型定义 函数的输入和输出为必须，且都必须定义类型 可选参数：参数名 + ? ，可选参数必须在必填参数后面 默认参数：设置了默认值的参数会被 TypeScript 识别为可选参数，但不受 “可选参数必须在必填参数后面” 这个限制 剩余参数：指除了 必选参数 和 可选参数 以外的参数，使用 … 获取剩余参数为数组格式需定义类型，剩余参数必须排在参数末尾 1234567891011// 小括号里面是输入的参数包括对参数类型的定义，花括号前面的number是输出的类型// y 设置了默认参数，为可选参数// z为可选参数// rest 为剩余参数，any 类型function sum(x: number, y: number = 6, z?: number, ...rest: any[]): number &#123; return x + y;&#125;sum(1)sum(1, 2)sum(1, 2, 3)sum(1, 2, 3, 4, 5) // 4,5 为剩余参数 函数表达式: =&gt;不是箭头函数，他表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型123let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;; 类型断言：&lt;类型&gt;值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型123456789function getLength(something: number): number &#123; // 当然这地方你也可以将他定义为any类型 return something.length; // 报错 类型“number”上不存在属性“length”&#125;```使用类型断言````tsfunction getLength(something: string): number &#123; return (&lt;string&gt;something).length; // 将参数定义为string后再去访问他的length&#125; 类型别名：使用type关键字给一个类型起个新名字，常用于联合类型12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个123456type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById('hello'), 'scroll'); handleEvent(document.getElementById('world'), 'dbclick'); // 报错，dbclick不在EventNames中 声明文件 声明文件以.d.ts为后缀 @type引入第三方声明文件：npm install @types/jquery –save-dev，可以统一管理第三方库的声明文件只需在插件名称前加上@type declare var/let/const 声明全局变量，一般全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var / let declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明全局对象（含有子属性） interface 和 type 声明全局类型 元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象123456let tup: [string, number] = ['first', 15]; // 定义，定义时也可不赋值tup = ['second', 30] // 直接赋值tup[0] = 'second' // 通过索引赋值tup = ['second'] // 报错，需要提供所有元组类型中指定的项tup.push(20); // 添加越界元素tup.push(true); // 报错，越界元素类型会被限制为元组中每个类型的联合类型 枚举：enum关键字用于限定取值在一定范围内普通枚举1234567891011121314151617// 枚举成员会被赋值为从 0 开始递增的数字enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; console.log(Days["Sun"] === 0); // trueconsole.log(Days.Sun === 0); // trueconsole.log(Days[0] === "Sun"); // true// 当我们手动赋值时，未被赋值的枚举项会接着上一个枚举项 +1 递增，手动赋值的枚举项也可以为小数或负数enum Days &#123;Sun = 7, Mon = 8, Tue, Wed, Thu = 5.5, Fri, Sat&#125;;console.log(Days.Mon === 8); // trueconsole.log(Days.Wed === 10); // trueconsole.log(Days.Fri === 6.5); // true// 手动赋值的枚举项可以不是数字，需要使用类型断言来让 tsc 无视类型检查，非数字枚举项后面不能跟未手动赋值的枚举项，因为无法获得初始值enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;"S"&#125;;// 当枚举项是计算所得项时，后面不能跟是未手动赋值的项enum Color &#123;Red, Green, Blue = "blue".length&#125;; 常数枚举：const enum关键字定义，常数枚举会在编译阶段被删除，并且不能包含计算成员1const enum Directions &#123;Up, Down, Left, Right&#125; 外部枚举：是指使用declare enum 定义的枚举类型，只会用于编译时的检查，编译结果中会被删除1declare enum Directions &#123;Up, Down, Left, Right&#125; 类：基于es6 class 和 es7 新提案的基础上添加了三种访问修饰符public：修饰的属性或方法是公有的，任何地方都能被访问 private：修饰的属性或方法是私有的，不能在声明它的类的外部访问*protected：和 private 类似，区别是它在子类中允许被访问 泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性vs code 提示：Experimental support for decorators is a feature that is subject to change in a future release. Set the ‘experimentalDecorators’ option to remove this 在 tsconfig.json 文件中修改规则 experimentalDecorators 学习资源官网 http://www.typescriptlang.org/对新手比官网更友好些 https://ts.xcatliu.com/introduction/what-is-typescript.htmlvue + ts项目实战 https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-14]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas性能优化篇]]></title>
    <url>%2F2019%2F03%2F18%2Fcanvas-3%2F</url>
    <content type="text"><![CDATA[看了很多大佬的文章，自己也对项目做了一些优化，其实有很多地方平常码代码的时候稍微注意一下就能节约很多性能开销 1.离屏渲染在离屏canvas上预渲染相似的图形或重复的对象，通俗的解释是将离屏canvas当成预渲染，在离屏canvas上绘制好一整块图形，绘制好后在放到视图canvas中，适合每一帧画图运算复杂的图形 比如你想把一张图片放到canvas上，使用drawImage()方法，有三种写法123456// 将image放到目标canvas指定位置void ctx.drawImage(image, dx, dy); // 将image放到目标canvas指定位置，指定宽高渲染void ctx.drawImage(image, dx, dy, dWidth, dHeight);// 将image裁剪之后放到目标canvas指定位置，指定宽高渲染void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 第一种只是把图片原样放到canvas里，第二章指定宽高就意味着放大或者缩小图片后再放进去，带三种是裁剪后再放大或者缩小放到canvas中，这三种写法操作依次增加，性能开销也是依次提高而离屏渲染就可以让我们先把图片裁剪成想要的尺寸内容保存起来，绘制的时候就可以使用第一种写法简单的把图片放进去就完了 123456789// 在离屏 canvas 上绘制var offscreencanvas = document.createElement('canvas');// 宽高赋值为想要的图片尺寸offscreencanvas.width = dWidth;offscreencanvas.height = dHeight;// 裁剪offscreencanvas.getContext('2d').drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);// 在视图canvas中绘制viewcontext.drawImage(canvas, x, y); 2.分层画布多个相互重叠的canvas根据变化程度分开渲染，越复杂的场景越适合 比如一个简单的游戏场景，游戏背景始终不变或者变化次数较少但是人物游戏的主体是一直在根据玩家的指挥不停的改变， 场景：最近写的一个画板，比如这样一个简单的画圆，可以看到有原来的绘画的痕迹，那就要 渲染没画圆之前的画布 -&gt; 再画圆，鼠标移动的时候不断的执行这个渲染过程 这个时候就可以使用分层画布，画画在一个上层canvas上，原来绘画痕迹在下层canvas上，那么画圆的过程就是清空 -&gt; 画圆，画好之后再放到下层canvas上，这样就不需要去渲染之前的画布，就能节约性能开销 3.一次性绘制绘制操作的性能开销较高，可以创建一个包含所有线条的路径，然后通过单个绘制路径调用进行绘制 从这样12345678for (var i = 0; i &lt; points.length - 1; i++) &#123; var p1 = points[i]; var p2 = points[i+1]; context.beginPath(); context.moveTo(p1.x, p1.y); context.lineTo(p2.x, p2.y); context.stroke();&#125; 变成这样，在绘制复杂路径时，最好将所有点都放入路径中，而不是分别呈现各个片段12345678context.beginPath();for (var i = 0; i &lt; points.length - 1; i++) &#123; var p1 = points[i]; var p2 = points[i+1]; context.moveTo(p1.x, p1.y); context.lineTo(p2.x, p2.y);&#125;context.stroke(); 4.使用requestAnimationFrame执行动画canvas动画的本质是不断地擦除和重绘，再结合一些时间控制的方法达到动画的目的显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms而requestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命 详细看这儿 5.清空画布三种方法性能，性能依次提高123context.fillRect()context.clearRect()canvas.width = canvas.width; // 一种画布专用的技巧 6.减少调用canvas的api比如像背景可以使用css属性设置或者img标签加一些定位什么的 画布的缩放可以使用CSS transforms，不要将小画布放大，而是去将大画布缩小12345678var scaleX = canvas.width / window.innerWidth;var scaleY = canvas.height / window.innerHeight;var scaleToFit = Math.min(scaleX, scaleY);var scaleToCover = Math.max(scaleX, scaleY);stage.style.transformOrigin = '0 0'; //scale from top leftstage.style.transform = 'scale(' + scaleToFit + ')'; 其他注意点 尽可能使用计算代替canvas渲染，通常情况下，渲染比计算的开销大很多（3~4 个量级） 减少改变 context 的状态以及不要赋一些乱七八糟类型的值，比如人家要一个number你要给一个string，浏览器会用一些额外时间来处理这些非法输入，可能会造成三四倍的时间开销 避免使用浮点数坐标，使用非整数的坐标绘制内容，系统会自动使用抗锯齿功能，尝试对线条进行平滑处理，这又是一种性能消耗。可以调用 Math.round 四舍五入取整 减少使用 shadowBlur 效果，和很多图像环境渲染一样，阴影渲染的性能开销通常比较高 参考文章https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvashttps://www.html5rocks.com/zh/tutorials/canvas/performance/http://taobaofed.org/blog/2016/02/22/canvas-performance/]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas动画篇]]></title>
    <url>%2F2019%2F03%2F07%2Fcanvas-2%2F</url>
    <content type="text"><![CDATA[最近用canvas蛮多的，canvas写动画也蛮好使的 canvas 由 js 来控制，但用 js 写动画通常3种方法控制时间 setInterval( function, delay ) 在指定的毫秒数下循环调用函数或表达式，直到使用clearInterval清除 setTimeout( function, delay ) 在指定的毫秒数后调用函数或计算表达式 前两个是平时会用得会比较多的，setInterval 和 setTimeout的本质是将回调函数添加到任务队列的尾部等待执行，但是前面的任务到底需要多少时间执行完是不确定的，如果前面堵塞了那么后面就无法执行尤其setInterval指定的是”开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间，下一个回调开始执行的时间 = 指定时间 - 回调函数执行的时间，因此实际上，两次执行之间的间隔会小于指定的时间 下面的写法可以确保执行时间始终是2000ms1234var timer = setTimeout(function f() &#123; // ... timer = setTimeout(f, 2000);&#125;, 2000) window.requestAnimationFrame(callback) 和 window.requestAnimationFrame(requestID)前者是告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，返回一个 requestID，该回调会在浏览器下一次重绘之前执行后者是取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求，接受一个 requestID，不需要的时候就取消掉释放内存绝对是个好习惯 显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6msrequestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命 一些canvas的小例子自己学习过程中用canvas写的一些小东西，源码带有注解给大家参考，会坚持不断更新这个目录…. 环形百分比动画粒子动画电子画板图片裁剪 本站和canvas有关的文章cannvas的imagedata对象 参考文章https://www.w3cplus.com/javascript/requestAnimationFrame.html © w3cplus.comhttps://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFramehttps://javascript.ruanyifeng.com/advanced/timer.html]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google 搜索语法]]></title>
    <url>%2F2019%2F03%2F01%2FgoogleSearch%2F</url>
    <content type="text"><![CDATA[现在越来越习惯用google了，不是我嫌弃百度，只是用了google发现百度真的让人爱不起来，没有对比就没有伤害 收集了一些google常用的语法，备忘 这些是已经被弃用的：+、~、inpostauthor:、allinpostauthor:、inposttitle:、link:、info:、daterange:、phonebook:、# 这些是在被弃用边缘，搜索结果不是非常准确的 symbol example explain .. apple 2010..2014 范围搜索，返回2010到2014，不超过2015的信息 inanchor: inanchor：apple iphone 返回锚文本中包含指定词汇的页面 allinanchor: inanchor：apple iphone 和inanchor类似，返回锚文本中包含所有指定词汇的页面 blogurl: blogurl：阮一峰 谷歌博客搜索 loc: loc:san francisco 查找给定区域的结果 以下是谷歌最新的常用搜索语法，帮助你更快找到你要的信息 symbol example explain OR或者管道符号（竖线） x OR y 返回x或者y的信息，或者和两者都相关的信息 AND x AND y 返回和两者都相关的信息 - 短横线 x -y 排除一个相似的容易造成误导的词语，返回x相关的信息而不是y，注意: 符号-和y之间没有空格 * 通配符 x * y 匹配任何信息 () 括号 (x OR y) -z 将多个款项和符号组合搜索 $ 美元符号 iphone $2000 价格搜索 define: define:china 显示谷歌内置的词典，以卡片形式展现 cache: cache:https://github.com 返回该页面最新缓存版本 filetype: 或者 ext: 个人简历 filetype:pdf 返回符合指定的文件类型的信息 site: js site:github.com 将搜索限制在某个指定的网站 related: related:github.com 查找和给定域名相关的站点 intitle: intitle:github 返回所有标题中包含“github”的信息 allintitle: allintitle:github js 和intitle类似，返回标题中包含所有单词的信息 inurl: inurl:github 和intitle类似，不同的是匹配的是url而不是标题 allinurl allinurl:github js 同上 intext: intext:github 和intitle类似，不同的是匹配的是内容而不是标题 allintext: allintext:github js 同上 AROUND(X) apple AROUND（4）iphone 间隔限制，单词“apple”和“iphone”必须出现在内容中，并且相隔不超过四个单词。 weather: weather:san francisco 查找指定位置的天气 stocks: stocks:aapl 查找指定的股票信息 map: map:silicon valley 地图搜索 movie: movie:steve jobs 电影搜索 in $329 in GBP 单位转换，前者向后者转换 source: apple source:the_verge 在google News中查找来自某个来源的新闻]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cannvas的imagedata对象]]></title>
    <url>%2F2019%2F02%2F21%2Fcanvas-1%2F</url>
    <content type="text"><![CDATA[背景介绍ImageData 是canvas的图像数据，由 ImageData() 构造函数返回一个实例化的对象， 三个可读属性 data：一个 Uint8ClampedArray 类型的一维数组，包含RGBA 顺序的数据，每4个元素表示一个RGBA 值即对应一个像素, 左上角在数组的索引0位置，像素从左到右被处理，然后往下，遍历整个数组 RGBA： R - 红色（0-255）、G - 绿色（0-255）、B - 蓝色（0-255）、A - alpha 通道（0-255; 0 是透明的，255 是完全可见的） Uint8ClampedArray（8位无符号整型固定数组）： 类型化数组表示一个由值固定在0-255区间的8位无符号整型组成的数组；如果你指定一个在 [0,255] 区间外的值，它将被替换为0或255；如果你指定一个非整数，那么它将被设置为最接近它的整数。（数组）内容被初始化为0。 width：以像素为单位的图像的宽 height：以像素为单位的图像的高 三个参数的关系是：data.length = height * width * 4 不满足这个关系的时候就会报错：” The input data length is not a multiple of (4 * width).” ，不要问我为什么知道 构建一个ImageData 对象使用canvas API createImageData(): 传入宽和高获得一个ImageData对象或者传入一个已经存在的ImageData对象渲染到画布 123var canvas = document.getElementById("canvas")var ctx = canvas.getContext("2d")console.log(ctx.createImageData(200, 200)) getImageData(): 提取一个矩形区域的图像数据，返回一个ImageData对象 ctx.getImageData(矩形区域的左上角 x 坐标, 矩形区域的左上角 y 坐标, 矩形区域的宽度, 矩形区域的高度)下面是一个简单的小例子让div背景色随着鼠标指针下的图片颜色变化而变化，思路是使用 getImageData() 获取鼠标下1像素的区域，也就是一个RGBA值赋值给div运行时注意canvas图片使用 getImageData() 的跨域问题12345678910111213let img = new Image()img.src = './static/img/1547436818106.png'let canvas = document.getElementById('canvas')let ctx = canvas.getContext('2d')img.onload = () =&gt; &#123; ctx.drawImage(img, 0, 0) img.style.display = 'none'&#125;let color = document.getElementById('color')canvas.addEventListener('mousemove', (e) =&gt;&#123; let pixel = ctx.getImageData(e.layerx, e.layery, 1, 1) color.style.background = 'rgba(' + pixel.data[0] + ',' + pixel.data[1] + ',' + pixel.data[2] + ',' + (pixel.data[3] / 255) + ')'&#125;) 直接使用ImageData()构造函数创建, data可为空当data为空时会自动按照width和height的大小，以0填充整个像素矩阵，也就是一个空白画布若需要传入data图像数据，要注意 width * height * 4 = data.length12let imagedata = new ImageData(data, width, height)// ImageData &#123; width: width, height: height, data: Uint8ClampedArray[width * height * 4] &#125; 操作像素 putImageData(): 对画布进行像素数据的写入，也就是将指定的 ImageData 对象放到画布上，7个参数，前3个为必填 ctx.putImageData(imagedata, 图像数据在目标画布中的位置X坐标, Y坐标, 在图像数据中截取一个矩形区域左上角的位置X坐标, Y坐标, 矩形区域Width, Height);一个小例子图片灰度处理，思路是使用 getImageData() 获取当前 ImageData 数据，然后遍历 data 数组改变 RGBA 的值，最后在使用 putImageData() 放回画布12345678910111213141516171819let img = new Image()img.src = './static/img/shareedu.png'let canvas = document.getElementById('canvas')let ctx = canvas.getContext('2d')img.onload = () =&gt; &#123; ctx.drawImage(img, 0, 0) img.style.display = 'none'&#125;document.getElementById('btn').addEventListener('click', ()=&gt;&#123; let pre = ctx.getImageData(0,0,canvas.width, canvas.height) let data = pre.data for (var i = 0; i &lt; data.length; i += 4) &#123; let avg = (data[i] + data[i +1] + data[i +2]) / 3 data[i] = avg data[i + 1] = avg data[i + 2] = avg &#125; ctx.putImageData(pre, 0, 0)&#125;) drawImage(): 在画布上绘制图像，9个参数，image, dx, dy为必填 image: 图像源sx: 选择需要的图像源区域，矩形选择框的左上角 X 轴坐标。sy: 矩形选择框的Y 轴坐标。sWidth: 需要绘制到目标上下文中的，image的矩形（裁剪）选择框的宽度。如果不说明，整个矩形（裁剪）从坐标的sx和sy开始，到image的右下角结束。sHeight: 需要绘制到目标上下文中的，image的矩形（裁剪）选择框的高度。dx: image的左上角在目标canvas上 X 轴坐标。dy: image的左上角在目标canvas上 Y 轴坐标。dWidth: image在目标canvas上绘制的宽度。 允许对绘制的image进行缩放dHeight: image在目标canvas上绘制的高度。 允许对绘制的image进行缩放一个小例子将图片放在鼠标指定位置12345678let canvas = document.getElementById("canvas")let ctx = canvas.getContext("2d")let img = new Image()img.src = './static/img/shareedu.png'document.getElementById('canvas').addEventListener('mousedown', (e)=&gt;&#123; ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height) ctx.drawImage(img, e.offsetX, e.offsetY, 200, 200)&#125;) imageSmoothingEnabled, 这是个属性设置图片是否平滑，只需要将他赋值为true（平滑）或者false（不平滑） canvas.toDataURL(‘image/png’, quality) 返回一个包含图片展示的 data URI , 2个参数, 图片格式默认为png, 0到1的品质选择（图片格式为 image/jpeg 或 image/webp的情况下） canvas.toBlob(callback, type, encoderOptions),创建一个Blob对像，用以展示canvas上的图片，3个参数 callback：回调函数返回一个blob对象type：图片格式，默认为’image/png’encoderOptions: 0到1的品质选择（图片格式为 image/jpeg 或 image/webp的情况下） 一些canvas的小例子自己学习过程中用canvas写的一些小东西，源码带有注解给大家参考，会坚持不断更新这个目录…. 环形百分比动画粒子动画电子画板图片裁剪 本站和canvas有关的文章canvas动画篇]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron踩坑指南不完全篇]]></title>
    <url>%2F2018%2F12%2F13%2Felectron%2F</url>
    <content type="text"><![CDATA[前段时间做了个客户端的项目，主要适用于老师教案管理、远程上课录屏、和学生互动答疑等场景，原生开发对公司来说成本有点大，基于guthub上有各种桌面打包框架so只能前端上了 Electron + vue = product 这是一篇踩坑的记录，没有太深入的原理什么的讲解，主要是码代码过程中碰到的一些暗坑你如果正在写Electron的项目那么你也可能会遇到，这篇文章会给你一些参考 为什么用Electron这是目前大家知道比较多的三种跨平台的桌面框架NWJS https://nwjs.io/HEX http://hex.youdao.com/zh-cn/tutorial/index.htmlElectron https://Electronjs.org/docs Electron nw.js hex 发布时间 2013年 2011年 2012年 开发公司 github intel 有道翻译 代表作 Atom、Visual Studio Code 、WordPress 微信web开发工具、钉钉 有道云笔记，有道词典 github start 66608 34555 1429 三个框架都是 chromium + nodejs + native api ， 不用考虑浏览器兼容性还能用nodejs，简直不要太爽 Chromium 是 Google 为发展 Chrome 浏览器而启动的开源项目，它对HTML5的支持非常优秀，其内嵌的V8引擎是业内效率最好的JavaScript脚本引擎之一，且其项目开源，又有专门的社区和团队维护，作为UI渲染引擎，它是不二之选，体验上，你可以试用下google chrome浏览器，基本一致 Node.js （或者简称 Node） 一个工具，选择Node.JS，是因为开发桌面应用，本地资源操作是必备的能力，这方面JavaScript无能为力，而Node.JS则很好的解决了这个问题，它使得JavaScript操作本地资源变的毫无障碍。另一方面，Node.JS核心也是采用V8引擎，使得其与Chromium的整合变得更顺理成章 API 应用程序接口描述了一系列可供你使用的函数库中的函数 我绝对是有道词典的忠实用户但是hex用的人较少怕遇坑爬不出来，nwjs主要优点是能兼容winXP，但是我不需要。。。而且nw和Electron是同一个大佬一前一后开发，Electron相当于是nwjs的重构升级版，官网又这么好看又那么火，还犹豫？ 简单介绍官网传送门 官方api https://Electronjs.org/docs Electron-vue文档 https://simulatedgreg.gitbooks.io/Electron-vue/content/cn/getting_started.html 中文社区文档https://Electron.org.cn/doc/index.html 常用的一些模块： 文件打开删除等操作 shell模块 https://Electronjs.org/docs/api/shell 窗口管理修改新建参数等 BrowserWindow模块 https://Electronjs.org/docs/api/browser-window 主进程和渲染进程通信 ipcRenderer 模块 https://Electronjs.org/docs/api/ipc-renderer 获取屏幕大小、鼠标位置等信息 screen 模块 https://Electronjs.org/docs/api/screen 渲染进程使用BrowserWindow 实例 remote模块 https://Electronjs.org/docs/api/remote 暗 坑Electron是个很成熟很完善的框架，所以这些也不叫暗坑，只是小白如果没有很仔细的阅读api就可能容易掉坑里，不要问我为什么知道，我是有故事的人 Q、已经引了BrowserWindow 为什么使用函数会是undefined？A、Electron分为主进程和渲染进程，Electron 运行 package.json 的 main 脚本的进程被称为主进程只有一个，而渲染进程就是你的页面一个BrowserWindow 实例，所以api也分为主进程和渲染进程以及两者通用的api，所以用api的时候得注意，在渲染进程中使用 BrowserWindow 实例需要引入 remote 模块 主进程可用的模块:app、autoUpdate、BrowserView、BrowserWindow、contentTracing、dialog、globalShortcut、inAppPurchase、ipcMain、Menu、MenuItem、net、netLog、powerMonitor、powerSaveBlocker、protocol、session、systemPreferences、Tray、webContents渲染进程（网页）可用的模块:、desktopCapturer、ipcRenderer、remote、webFrame两种进程都可用的模块:、clipboard、crashReporter、nativeImage、screen、shell Q、想在渲染进程使用主进程的api？A、有某些功能必须得在主进程才能实现，比如保存文件、选择文件路径什么的，这些操作可以使用 ipcRenderer 模块用于两个进程之间的通信，由渲染进程发出指令后在主进程进行功能操作 Q、单击PDF文件的链接时，Electron会提示下载而非直接预览？A、单击PDF文件的链接时，在普通浏览器中它会预览该文件。但在Electron中你需要尝试使用 iframe 加载，如果无效可以再试下 webview Q、动态的修改静态文件的路径会报链接404？A、使用Electron-vue框架，动态的修改静态文件的路径会报链接404但是一开始写死就没问题，所有静态文件都建议放在根目录下 static 文件夹下，然后任何页面访问 static/… 即可 Q、透明窗口无效？A、新建窗口时已经设置了frame: false,transparent: true, 为什么页面还是白色，开发模式下看透明窗口需要关掉开发者模式后刷新 Q、新建一个窗口，然后拖动该窗口，宽度和高度会小于指定值？A、 guthub上有大佬说setResizable: false下最小化且连续恢复，则窗口的高度每次都会减少一个看起来等于菜单栏的量，取消菜单后正常，设置window.setMenu(null)，但是这个方法对我不适用在 issues上翻了一圈，最后 useContentSize: true设置为true + 更改width和height属性以适应测量大小 = 解决 Q、navigator.mediaDevices.getUserMedia 使用该属性报错？A、之前使用这个属性报错还以为Electron不支持，感觉很奇怪他继承的是最新的 chromium 为什么会不支持这个属性，然后某天翻api发现 desktopCapturer 模块，这个属性被Electron封装了，需要引入 desktopCapturer 模块，所以敲黑板一定要认真看api Q、打包问题？A、前端大部分框架都封装了webpack，glup什么的都有打包功能，然后一搜 “ 某某框架 打包 ” ，出来的都是什么打包报错？ 空白？一大堆问题，感觉这个问题好像无解之前我写demo的时候打包各种报错，可能是因为写demo的时候各种实验各种乱搞把框架玩坏了，反正正式写项目的时候一个打包问题都没有碰到过只是一点第一次打包的时候很慢，因为Electron需要翻墙下载文件，这时候如果打包失败，多半就是被墙了 Q、’\’和’/‘符号路径问题A、通过Electron获取的路径这样的’d:\project...’，本来挺好的文件保存读取什么的用这个路径都挺正常的，但是使用nodejs的exec库调取cmd执行ffmpeg的命令会报错，需要把路径分隔符’\’换成’/‘ Q、关于新建窗口时的白屏A、新建窗口由于加载页面和初始化窗口会有一段时间的白屏，有个方法就是初始化程序的时候就加载的所有窗口，但是只显示主窗口,其余的窗口隐藏,这样就能有效创建窗口时的白屏]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语单词打卡记录]]></title>
    <url>%2F2018%2F11%2F16%2Fenglish-clockIn%2F</url>
    <content type="text"><![CDATA[背单词接近3个月了，作为一个朝九晚六的上班族，一般背单词的时间是早上地铁有那么半个小时作为新单词时间然后晚上地铁半个小时是新单词为主 + 少部分需要复习的单词，然后睡觉前1个小时是单词复习时间。 平时的强度是每天新单词20个这个量其实不多，但是需要复习的单词平均每天有160个左右。我背单词是用anki，个人感觉这是个相当好用的记忆软件，可以帮助你记忆生活任何知识，优点太多就不列举了。用过的小伙伴应该都知道anki根据记忆的遗忘曲线每天都会有需要复习的单词，随着每天持续的加入新单词那么每天需要复习的单词也会越来越多，但是如果每天都坚持背单词并把所有到期需要复习的单词清空掉那么每天需要复习的就不会有这么多。 但是人啊 (。_。) ，每个星期总有那么一两天各种原因理由(又出现一个大bug？、今天加班、状态不好、其他乱七八糟的事)就会忘了背或者没背完。到期的单词没有被清空就会堆积在第二天，但是第二天也会有单词到期，所以一般就是今天160没背完明天翻个番，眼看着数量越来越多就会越来越不想背然后拖到周末被一次性清空。 anki记忆卡有四个选项重来、困难、一般、简单，根据自己的记忆深度决定这个单词的到期时间，到时间就把这个单词牵出来遛一遛晃一晃加深印象。那么我一次性拖到周末虽然也背完了但非常不利于单词的记忆，这导致很多背过的单词再出现我会感觉很陌生这样效率就大大降低了。]]></content>
      <categories>
        <category>RESTS</category>
      </categories>
      <tags>
        <tag>死磕英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端使用html5、ffmpeg实现录屏摄像等功能]]></title>
    <url>%2F2018%2F11%2F06%2Fstreamcapture%2F</url>
    <content type="text"><![CDATA[前段时间做一个windows的桌面应用，vue + electron，涉及到录屏和摄像功能，网上相关的文档蛮少的给需要的人一些参考 如果文章描写有误或者还有更好的方法，请留言告诉我，笔芯 (´▽`ʃ♡ƪ) 背景介绍 涉及技术：vue、electron、ffmpeg、node 关于录屏和摄像对比了两种方法 使用HTML5的api实现 摄像：mediaDevices（获取设备）+ getUserMedia（获取流） + MediaRecorder（存储） 录屏：getDisplayMedia（获取流） + MediaRecorder（存储） ffmpeg + node：FFmpeg是一套非常强大的音视频处理的开源工具，不多介绍，而Electron基于node和chromium，它允许使用node的API以及几乎所有的node模块，这意味这着我们可以调用cmd命令来操作ffmpeg实现录屏和摄像录制，当然ffmpeg功能绝不止这点 HTML5实现mediaDevices 用于收集系统上可用的多媒体输入和输出设备的信息 该方法调用成功返回设备列表，并传入带有devceID的MediaStreamConstraints对象可以指定设备获取流媒体来源 123456navigator.mediaDevices.enumerateDevices().then(devicelist =&gt; &#123; // audiooutput 扬声器 // audioinput 麦克风 // audiooutput 摄像 console.log(devicelist)&#125;).catch(err =&gt; console.log(err)) getUserMedia 用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。 该方法返回视频流，将获取到的流赋给video标签可实现边录边看 123navigator.mediaDevices.getUserMedia(MediaStreamConstraints).then(stream =&gt; &#123; videoElement.srcObject = stream; // &#125;, error =&gt; console.log(error)); getDisplayMedia 将用户的显示或其部分用作媒体流的来源，它允许以视频流的形式获取用户的显示器或其一部分 录屏主要依靠该方法，和getUserMedia一样返回一个promise对象，调用成功返回流，将这个流赋给video 元素实现边录边看 需要注意的是 如果你做的是网页端在谷歌上使用这个元素，需要在chrome://flags/开启Experimental Web Platform features功能demo戳这儿 &emsp;&emsp;&emsp;&emsp;而Electron基于node + chromium构建，在electron需要引入desktopCapturer模块，并在基于该模块使用这个方法 1234navigator.mediaDevices.getDisplayMedia(&#123; video: true &#125;) .then(stream =&gt; &#123; videoElement.srcObject = stream; &#125;, error =&gt; console.log(error)); MediaRecorder 记录和捕获媒体，也就是视频和音频 getDisplayMedia 和 getUserMedia 获取到的流都需要使用MediaRecorder存储起来，并且可以保存成文件 1234567let herfthis.recorder = new MediaRecorder(stream);this.recorder.ondataavailable = e =&gt; &#123; herf = e.data; download.href = URL.createObjectURL(herf);&#125;;this.recorder.start(); 第二种使用ffmpeg官网安装包下载 https://ffmpeg.zeranoe.com/builds/ 一些基本参数 -formats 输出所有可用格式 -f fmt 指定格式(音频或视频格式) -i filename 指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头 -y 覆盖已有文件 -t duration 记录时长为t -fs limit_size 设置文件大小上限 -itsoffset time_off 设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss* [.xxx]的格式也支持音 频 -ab bitrate 设置音频码率 -ar freq 设置音频采样率 -ac channels 设置通道 缺省为1视 频 -b bitrate 设置比特率，缺省200kb/s -r fps 设置帧频 缺省25 -s size 设置帧大小 格式为WXH 缺省160X128.下面的简写也可以直接使用： 录屏相关命令12345列出可用的设备包括音频和摄像等等ffmpeg -list_devices true -f dshow -i dummy录屏，你也可以加入关于视频的一些基本参数来获得你想要的文件ffmpeg -f gdigrab -i desktop captrue.mkv -y node调用cd进入bin文件夹后执行录屏相关命令 关于停止录制，虽然ffmpeg按 Q 可以停止录制，但是我们通过代码调用是看不到cmd命令行的而且他在录制过程中是一直占用这个进程什么命令也无法输入所以这个地方我只想到一个办法就是强制停止该进程 参考文章 MDN https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia&emsp;https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder&emsp;https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/enumerateDevices W3C https://w3c.github.io/mediacapture-screen-share/]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端是否需要对密码进行加密传输 && HTTPS]]></title>
    <url>%2F2018%2F10%2F16%2Fhttps%2F</url>
    <content type="text"><![CDATA[最近学习node，写demo登陆和注册功能的时候因为要考虑后台的加密和安全所以也想了下前端的，前端传输密码的时候是否应该加密之后再传输呢看了一些网站的登陆，csdn、简书等是明文传输，但腾讯、百度这些一线大站是经过前端加密的，看了些大佬的文章，顺便自己搬个凳子记个笔记 前端是否需要对密码进行加密传输前端的加密本身不能对网站的安全性有任何提高功能，所有的关于网站的安全技术都应该放在后台，但是这也不是完全没有意义，可以增加攻击成本，尽可能降低攻击带来的损失，毕竟丢了密文比丢了明文要强，而且犯罪分子技术参差不齐，简单的加密能够拦截很大一部分菜鸟，至于高手。。。 最后看到比较统一的是隐秘信息传输应该使用https 什么是https? ssl证书又是什么这篇文章只是想弄懂流程和原理，不会去纠结具体的术语 HTTP协议以明文方式发送内容，不提供任何方式的数据加密，处在同一网络中的其它用户可以通过网络抓包来窃取和篡改数据包的内容，甚至运营商或者wifi提供者，有可能会篡改http报文，添加广告等信息以达到盈利的目的 可以通过和SSL(Secure Socket Layer，安全套接层)组合使用来为浏览器和服务器之间的通信加密。在这条加密线路上进行通信的http被称为HTTPS（HTTP Secure，超文本传输安全协议）。 SSL证书（Secure socket layer），就是遵守SSL协议，由受信任的数字证书颁发机构CA颁发，主要用来提供对用户浏览器和服务器的认证，对传送的数据进行加密和隐藏，确保数据在传送中不被改变保证数据的完整性，加密方式为「非对称加密」和「对称加密」。 https的工作流程1、用户连接到你的Web站点，该Web站点受服务器证书所保护 2、你的服务器进行响应，并自动传送你网站的数字证书给用户，（浏览器内置一个受信任的机构列表和这些机构的证书）用户的浏览器查看该证书是否存在于浏览器的受信任机构列表中，并且通过服务器证书中的信息与当前正在访问的网站（域名等）是否一致来鉴别你的网站，鉴别没成功会提醒用户是否继续该访问 3、鉴别成功后，用户的浏览器产生一把唯一的会话钥匙，用以跟网站之间所有的通讯过程进行加密，会话密钥是随机生成，每次都会有不一样的结果， 4、使用者的浏览器以网站的公钥对交谈钥匙码进行加密，以便只有让你的网站得以阅读此交谈钥匙码 https的优点：1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； 2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 4、谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https的缺点：1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50% 2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； 3、SSL证书需要钱，功能越强大的证书费用越高 4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名 5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 参考文章知乎各位大佬的回答 https://www.zhihu.com/question/25539382HTTP与HTTPS的区别 https://www.cnblogs.com/wqhwe/p/5407468.html]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用语句]]></title>
    <url>%2F2018%2F10%2F10%2Fmysql%2F</url>
    <content type="text"><![CDATA[sql语法特点： 没有””双引号，字符串使用’’单引号包含； 没有逻辑相等，赋值和逻辑相等都是=； 类型不再是最严格的，任何数据都可以包含在’’单引号内； 没有布尔值的概念，但是在视图中可以输入true/false； 它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; !=，返回一个布尔值； 它也有逻辑运算符：！(not) &amp;&amp;(and) ||(or)； 它不区别大小写。 以下语句，user为表名, id,name,sex,card,phone,address为字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#数据库创建#"create database""drop table if exists user"# 如果存在(if exists)就删除表# 如果没有(if not exists)就新增表，设置id为主键，address为外键关联address表的id字段"""create table if not exists user( id int auto_increment primary key, name varchar(5), sex char(1), card char(18), phone char(11), address varchar(30), foreign key(address) references address(id))"""# 修改自增长Id,数据库新增的数据会从1000开始但是原来的数据不会改变"alter table user auto_increment=1000"# 新增数据库表字段plus"alter table user add plus varchar(8)"# --------------------------插入数据----------------------------------------------------------------# 数据插入时一定要注意 类型对应，数量对应，顺序对应# 字符串值必须包含在''以内，赋值可以使用default,null# 插入单条数据，如果不列出字段名mysql会按照顺序添加"""insert into user(name, sex, id_card, phone, address) values ('李四', '女', '511569845612354879', '10086', '太古里77号')"""# 批量插入数据"""insert into user(name, sex, id_card, phone, address) values (%s, %s, %s, %s, %s)"""# ----------------------------------------查询数据--------------------------------------------------# order by 对查询结果进行排序 select 字段1,字段2,字段3 from 表名 order by 字段 desc(降序)||asc(升序)"select address,id from user order by id desc"# 去重复查询 select distinct 字段 from 表名"select distinct address from user"# 分页查询 limit select 字段1，字段2 from 表名 limit 初始位置，记录数"select id, name, sex, id_card from user limit 3,6"# 精准查询 in 只查找括号内的数据； not in 则相反"select * from user where ID in (1001,1003)"# 精准查询 between and 查找1001-1003范围内的数据；not between and 相反"select * from user where ID between 1001 and 1003"# 模糊查询 like (% 代表任意字符 _ 代表单个字符)；not like相反"select * from user where name like '_麻%'"# 多条件查询 and 关键字"select * from user where sex='女' and address='太古里77号'"# 多条件查询 or 关键字 只需满足一个条件"select * from user where name='王麻子子' or address='太古里77号' "# 多表查询，两个表comment，movie# 语法：select * from 表1(左表) left join 表2(右表) on 表2.字段 = 表1.字段"select * from comment left join movie on movie.id = comment.movieid"# inner join / join单独用 返回所有匹配的行# left join 不论是否匹配会返回“left join”左边表所有的行，匹配不上的字段为null# right join 和left join相反，会返回右边表的所有的行# full join 只要存在一条匹配就会返回两个表所有的行# ------删除数据和更新数据 or,and,between and,like等关键字可以查询到多条数据然后批量删除或者更新-------------# 删除数据#delete [from] 表名 where 条件"delete from user where name='王麻子子' or address='太古里77号'"# 数据库清空"truncate table user"# 更新数据"update user set name = '更新' where ID in (1005,1006)" 参考文章https://www.cnblogs.com/esofar/p/6185210.html 史上最全的MSSQL复习笔记]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs之接收formdata表单]]></title>
    <url>%2F2018%2F10%2F09%2Fnode_fromdata%2F</url>
    <content type="text"><![CDATA[最近在学习express，写一个vue+express+mysql的小demo，需要上传一张封面图和一些其他的表单字段…. 背景介绍formdata主要用于发送表单数据，将数据编译成键值对的形式使用XMLHttpRequest来发送，一般的请求通常使用序列化的方法发送formdata格式的数据，所以formdata对象比较常见的应用场景是发送文件或者通过HTML表单创建的formdata对象用以发送表单 那么使用express搭建的nodejs的后台如何获取前台发送的formdata格式的数据 Multer中间件Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据 首先安装并存储在packjson中1npm install --save multer 配置Multer 需要接受一个 options 对象，用于对文件上传时做一些控制，比如文件存储，大小限制等所以在路由文件中除了引入 multer 模块还要设置 options 对象 dest or storage: 在哪里存储文件 123456789101112131415// 一般情况下只要设置 dest 属性设置文件存储的位置var multer = require('multer')var upload = multer(&#123; dest: 'uploads/' &#125;)"但如果你想要设置更多,那么需要使用storage代替dest"var storage = multer.diskStorage(&#123;// 磁盘存储引擎可以让你控制文件的存储 destination: function (req, file, cb) &#123; cb(null, '/tmp/my-uploads') // 文件存储路径 &#125;, filename: function (req, file, cb) &#123; cb(null, file.fieldname + '-' + Date.now()) // 文件名称 &#125;&#125;)var upload = multer(&#123; storage: storage &#125;) fileFilter: 文件过滤器，控制哪些文件可以被接受,接收一个函数 123456789function fileFilter (req, file, cb) &#123; // 你可以通过判断file的参数来判断这个文件是否跳过或者上传以及报错 // 拒绝这个文件 cb(null, false) // 接受这个文件 cb(null, true) // 发送一个错误: cb(new Error('I don\'t have a clue!'))&#125; limits: 限制上传的数据，接受一个对象 123456789&#123; "fieldNameSize" // field 名字最大长度 100 bytes "fieldSize" // field 值的最大长度 1MB "fields" // 非文件 field 的最大数量 无限 "fileSize" // 在 multipart 表单中，文件最大长度 (字节单位) 无限 "files" // 在 multipart 表单中，文件最大数量 无限 "parts" // 在 multipart 表单中，part 传输的最大数量(fields + files) 无限 "headerPairs" // 在 multipart 表单中，键值对最大组数 2000&#125; 方法 .single(fieldname)接受一个参数名为fieldname的文件应用场景：单个文件上传 + 一些其他的表单字段 1234app.post('/profile', upload.single('avatar'), function (req, res, next) &#123; // req.file 是 `avatar` 文件的信息 // req.body 将具有文本域数据，如果存在的话&#125;) .array(fieldname, maxCount) 接受一个参数名为fieldname的文件数组, 可选参数maxcount限制上传的最大数量应用场景：适合参数名相同的多文件上传 + 一些其他的表单字段 1234app.post('/photos/upload', upload.array('photos', 12), function (req, res, next) &#123; // req.files 是 `photos` 文件数组的信息 // req.body 将具有文本域数据，如果存在的话&#125;) .fields(fields) 接受一个对象数组[{name:&quot;&quot;,maxCount: 1},]，每个对象应该具有 name 和可选的 maxCount 属性,应用场景：适合参数名不同的多文件上传 + 一些其他的表单字段 12345678910var cpUpload = upload.fields([&#123; name: 'avatar', maxCount: 1 &#125;, &#123; name: 'gallery', maxCount: 8 &#125;])app.post('/cool-profile', cpUpload, function (req, res, next) &#123; // req.files 是一个对象 (String -&gt; Array) 键是文件名，值是文件数组 // // 例如： // req.files['avatar'][0] -&gt; File // req.files['gallery'] -&gt; Array // // req.body 将具有文本域数据，如果存在的话&#125;) .none() 只接受文本域 .any() 接受一切。文件数组将保存在 req.files。 代码参考在demo中的应用场景，很简单的单张图片上传+其他表单字段1234567891011121314151617181920212223242526272829303132333435const express = require("express");const router = express.Router();var multer = require("multer");let storage = multer.diskStorage(&#123; destination: function(req, file, cb) &#123; cb(null, "img"); &#125;, filename: function(req, file, cb) &#123; // Multer 不会为你添加任何扩展名，所以完整的名字需要我们自己拼接 cb(null, Date.now() + "." + file.originalname.split(".")[1]); &#125;&#125;);let limits = &#123; files: 1, // 只接收一个文件 fileSize: 2097152 // 文件大小不超过2m &#125;;function fileFilter(req, file, cb) &#123; // 文件类型判断 file.mimetype.split("/")[0] === "image" ? cb(null, true) : cb(null, false);&#125;let upload = multer(&#123; storage: storage, fileFilter: fileFilter, limits: limits&#125;);router.post("/insert", upload.single("img"), (req, res, next) =&gt; &#123; if (err) throw err; else &#123; res.json(req.body); &#125;&#125;); req.file获取到的参数12345678fieldname: 'img', // 表单字段名称originalname: '1.png', // 上传时在用户电脑上的名称encoding: '7bit', // 文件编码mimetype: 'image/png', // 文件类型destination: '/', // 接受后的保存路径filename: 'img-1539066538986', // 保存在 destination 中的文件名 path: '\\img-1539066538986', // 已上传文件的完整路径size: 80419 // size 参考文章express文档 http://www.expressjs.com.cn/4x/api.html#req.bodymulter文档 https://github.com/expressjs/multer/blob/master/README.md]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs使用cors跨域]]></title>
    <url>%2F2018%2F09%2F28%2Fnode_cors%2F</url>
    <content type="text"><![CDATA[相关文章：Nginx的反向代理跨域 最近在学习express，遇到了跨域问题…. 背景介绍CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。 预检请求？我自己在设置跨域的时候碰到的很多报错其实都是因为预检请求 cors将请求场景分为 简单请求 和 非简单请求 简单请求： 使用的方法是GET，HEAD，POST这三种之一 Content-Type 的值是text/plain、 multipart/form-data、 application/x-www-form-urlencoded 这三种之一 那么浏览器检测到该请求非简单请求，会先发送一个预检请求到服务器，以获知服务器是否允许该实际请求 服务器会从预检请求拿到的以下3个信息去和服务器的Response的header对比，来决定是否允许该请求 Access-Control-Request-Method ：实际请求的方法 Access-Control-Request-Headers：实际请求所携带的请求header字段 origin：实际请求的源站，域名 服务器header使用字段Access-Control-Allow-Origin 必填字段，值：一个域名， *(表示接受任意域名的请求)，也可以读取请求headers中的origin字段 如果请求的源与该字段不符合服务器会返回一个正常的HTTP回应，状态码可能为200，但不会包含Access-Control-开头的Origin、Credentials、Headers3个字段，浏览器发现，回应的头信息没有包含Access-Control-Allow-Origin字段就会抛出一个错误，会被XMLHttpRequest的onerror回调函数捕获 Access-Control-Request-Method 可选字段，表明服务器支持的所有跨域请求的方法 如果你用到除了HEAD，GET，POST之外的方法那么这个字段为必填 Access-Control-Allow-Credentials 可选字段 该字段若存在便只能为true，表示服务器许可Cookie可以包含在请求中一起发给服务器 对于某些浏览器即使服务器为true，有时候也需要前端设置 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 若为true Access-Control-Allow-Origin字段便不能为*，必须明确指定域名，Cookie遵循同源政策，只有用服务器域名设置的Cookie才会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 Access-Control-Allow-Headers 可选字段，设置Response的额外发送的header字段 CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 Access-Control-Max-Age 设置预警请求的结果能够被缓存多久，单位为秒 express如何使用cors跨域在express种使用cors跨域是需要使用第三方模块1npm install --save cors 在app.js中写入以下设置12345678示例代码app.all("*", function(req, res, next) &#123; res.header("Access-Control-Allow-Credentials", "true"); res.header("Access-Control-Allow-Headers","Origin, X-Requested-With, Content-Type, Accept"); res.header("Access-Control-Allow-Origin", req.headers.origin); res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); next();&#125;); 参考文章：HTTP访问控制（CORS） https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue cli 3.0初体验]]></title>
    <url>%2F2018%2F09%2F20%2Fvue3.0%2F</url>
    <content type="text"><![CDATA[尤雨溪：Vue 3.0 计划 原文需翻墙尤雨溪：Vue 3.0 计划 掘金译文 关于安装Vue CLI 的包名称由 vue-cli 改成了 @vue/cli1234npm install -g @vue/cli安装完成后查看版本vue --V 项目创建关于项目创建，除了命令创建3.x还增加了图形化界面创建以及管理vue项目在创建新项目时还可以混合选用多种集成 TypeScript PWA Vue Router &amp; Vuex ESLint / TSLint / Prettier 用 Jest 或 Mocha 进行单元测试 用 Cypress 或者 Nightwatch 进行 E2E 测试 使用命令创建命令：vue create vueapp 1、使用上下箭头选择默认设置还是手动选择功能1234Vue CLI v3.0.3? Please pick a preset: default (babel, eslint)&gt; Manually select features 2、按空格键选择你需要的功能，选完后按回车123456789101112131415161718192021babel：javascript转译器，将最新版的js语法（es6、es7）转换为现阶段浏览器可以兼容的js代码typescript：使用 TypeScript 书写源码PWA：渐进式WEB应用Router：使用vue-routerVuex：使用vuexCSS Pre-processors：css预处理器Linter / Formatter：代码规范标准Unit Testing：单元测试E2E Testing：e2e测试Vue CLI v3.0.3? Please pick a preset: Manually select features? Check the features needed for your project: (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex&gt;(*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 3、router是否使用history模式，history需要服务器支持详，情请看这儿https://router.vuejs.org/zh/guide/essentials/history-mode.html这里我就选no 4、css预处理器的选择，我习惯用sass 5、代码格式化检测选择，我用的是ide是vscode个人感觉搭配插件用着很舒服，所以我选Prettier 6、是否保存刚才的配置，下一次就不用重新配置了，我就直接回车 7、关于Babel, PostCSS, ESLint, etc.这些配置文件你是想放在package.json里面还是单独放在外面编辑器一般默认会在项目根目录下寻找配置文件，这里我就直接回车选择In dedicated config files 8、是否保存为未来项目的预配置吗，我也是直接回车 最后配置如下123456789Vue CLI v3.0.3? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? Yes 图形化界面图形化操作非常方便，我就不一步步演示了，主要懒得贴图 (°ー°〃)123执行npm命令vue ui访问 http://localhost:8000 你就可以创建，管理，导入项目 实用新功能 node_modules public src .browserslistrc .eslintrc.js .gitignore babel.config.js package.json postcss.config.js README.md 以上是项目根目录，3.x对比2.x文件结构明显精简了不少，多了一个public文件夹用于存放静态文件少了config、build等一系列的配置文件，这些配置文件都被放在了node_modules\@vue文件下 browserslist根目录中多了一个.browserslist文件，可以指定项目的目标浏览器的范围用于转译的 JavaScript 特性和添加CSS 浏览器前缀，可以减少兼容代码提高代码质量如果想少一个文件，你也可以在package.json中添加browserslist字段，参数是一个数组1234这是默认设置，兼容所有最新版本，不支持ie8以下&gt; 1%last 2 versionsnot ie &lt;= 8 使用 npx browserslist 可以查看项目的浏览器兼容情况将需要支持的目标浏览器参数放在文件中就好 参数 说明 &gt; 1% 全球超过1%人使用的浏览器 &gt; 5% in US 使用美国使用情况统计，接受两个字母的国家/地区代码 &gt; 5% in my stats 使用自定义使用数据 last 2 versions 所有浏览器兼容到最后两个版本根据CanIUse.com追踪的版本 Firefox ESR 火狐最新版本 Firefox &gt; 20 指定版本范围 not ie &lt;=8 方向排除部分版本 Firefox 12.1 指定浏览器版本 since 2013 2013年之后发布的所有版本 更多请查看官方文档 vue-cli服务在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令 Vue CLI 项目有三个模式： development 模式用于启动，production 模式用于打包和e2e测试，test 模式用于unit测试123456789101112131415161718192021222324252627启动serve:vue-cli-service serve --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false)打包build:vue-cli-service build --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小测试 test: vue-cli-service test:e2e 端到端测试 vue-cli-service test:unit 单元测试 现代模式为了兼容那些不支持js新特性的浏览器我们需要Babel转译，但转译后的代码笨重冗长，这次3.x提供了一个现代模式1npx vue-cli-service build --modern 这个命令会产生两个应用的版本：一个现代版的包，面向支持 ES modules 的现代浏览器，另一个旧版的包，面向不支持的旧浏览器而且不需要我们手动去部署和设置什么，简直很贴心 现代版的包会通过 &lt;script type=&quot;module&quot;&gt; 在被支持的浏览器中加载；它们还会使用 &lt;link rel=&quot;modulepreload&quot;&gt; 进行预加载 旧版的包会通过 &lt;script nomodule&gt; 加载，并会被支持 ES modules 的浏览器忽略 一个针对 Safari 10 中 &lt;script nomodule&gt; 的修复会被自动注入插件的添加在一个已经被创建好的项目中安装一个插件,使用vue add命令CLI 插件安装每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件对于这种cli插件需要加入@vue的前缀，这个命令将 @vue/eslint 解析为完整的包名 @vue/cli-plugin-eslint，然后从 npm 安装它，调用它的生成器12345插件添加vue add @vue/eslint向被安装的插件传递生成器选项 (这样做会跳过命令提示)vue add @vue/eslint --config airbnb --lintOn save 第三方插件安装123456安装并调用 vue-cli-plugin-apollo，不带 @vue 前缀，该命令会换作解析一个 unscoped 的包执行此命令后src里会创建一个plugins文件夹，里面会自动生成关于插件的配置文件vue add axios基于一个指定的 scope 使用第三方插件，如果一个插件名为 @foo/vue-cli-plugin-bar，你可以这样添加它：vue add @foo/bar 配置修改例：向所有 Sass 样式传入共享的全局变量在根目录新建一个vue.config.js，加入以下配置123456789101112module.exports = &#123; css: &#123; loaderOptions: &#123; // 给 sass-loader 传递选项 sass: &#123; // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件 data: `@import "@/variables.scss";` &#125; &#125; &#125;&#125; 打包后路径问题在vue.config.js文件种加入’baseUrl: ‘./‘’12345module.exports = &#123; //... baseUrl: './' //...&#125; 虽然官方说这个文件会被 @vue/cli-service 自动加载，但如果你启动项目用的是npm run serve，那么你最好使用npx vue-cli-service serve重启一下 参考文章官方文档 https://cli.vuejs.org/zh/guide/browserslist的github https://github.com/browserslist/browserslisthttps://mp.weixin.qq.com/s/hfr2Q3FXZFIdqM_r8HrLwQ 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova之HybirdApp热更新]]></title>
    <url>%2F2018%2F08%2F30%2Fcordova_%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[关于热更新热更新App常用的更新方式。简单来说，就是在用户通过App Store下载App之后，打开App时遇到的即时更新 热更新就是动态下发代码，它可以使开发者在不发布新版本的情况下，修复 BUG 和发布功能，也可以绕开App Store和各种商店的审核机制，避免长时间的审核等待以及多次被拒造成的成本，也能针对顽固用户进行强制更新 关于插件cordova插件1cordova plugin add cordova-hot-code-push-plugin --save 添加Cordova Hot Code Push Plugin CLI客户端github文档链接用处：自动生成Hot Code Push插件（chcp.json和chcp.manifest）所需的配置文件&emsp;运行本地服务器检测内容变更部署到服务器（关于自动部署看到有大佬说因为国内网络问题。。。但是我没试过因为没有aws服务器） 1npm install -g cordova-hot-code-push-cli 更新流程1、根据Update method的设置（后面会提到改配置，假设是resume）恢复应用程序（从后台移动到前台状态）或启动时 2、插件初始化，在后台加载更新模块（Update loader） 3、Update loader 从cordova项目配置文件config.xml中获取config-file也就是插件配置文件chcp.json 的加载路径，然后加载chcp.json获取到release 版本号，对比当前的版本号，若二者不同，说明有新版本 4、有新版本时Update loader会从chcp.json中获取rcontent_url并从中下载web静态文件 自动化更新1、初始化插件添加成功后在项目根目录执行init命令进行初始化生成配置文件1cordova-hcp init 执行时会需要填写一些首选项除了第一个project name项目名称和最后一个为必填以外其他都可以回车 最后一个参数 “Enter full URL to directory where cordova-hcp build result will be uploaded:”这个是服务器的url，也就是更新时app从服务器下载资源的路径 关于倒数第二个参数 ：Update method - 何时执行更新，默认为resume start - 启动应用程序时安装更新 resume - 恢复应用程序（从后台移动到前台状态）或启动时安装更新 now - 从服务器加载后立即安装更新 执行成功后可以看到项目根目录多出一个cordova-hcp.json文件1234567&#123; "name": "dzbp", // 项目名称 "ios_identifier": "", // android "android_identifier": "", // App Store上的应用程序ID。用于将用户重定向到商店的应用程序页面。 "update": "resume", // 在Google Play上引用应用的应用包名称 "content_url": "https：//www" // web静态资源在服务器的地址&#125; 2、构建命令1cordova-hcp build [Web项目路径不指定默认为www目录] 执行完成后会在你的web目录下会生成两个配置文件 chcp.json : 持有发布相关信息 chcp.manifest : 保存有关Web项目文件的信息：它们的名称（相对路径）和哈希值, 根据它插件查知道文件的增删改 3、修改配置在config配置中加入chcp.json文件在服务器的地址123&lt;chcp&gt; &lt;config-file url="http://www/chcp.json"/&gt;&lt;/chcp&gt; 最后使用cordova build打包 app的配置就完成了，每次代码修改后只需要把代码放到服务器上，app会自动检测 用户选择性进行更新？在项目配置文件config.xml中添加12345&lt;chcp&gt; &lt;auto-download enabled="false" /&gt; // 取消自动下载 &lt;auto-install enabled="false" /&gt; // 取消自动安装 &lt;config-file url="http://120.24.77.175:8080/ehospital/views/MSUI/chcp.json" /&gt;&lt;/chcp&gt; 下面是一个完整的代码示例，用到了3个api chcp.fetchUpdate(Callback，options) 检查更新 Callback接收两个参数：&emsp;error：若存在不为null表示没有更新版本，或者在更新检查期间发生错误&emsp;data：从本机端发送的其他数据 options：请求的其他选项。如果未设置 - 使用首选项config.xml chcp.isUpdateAvailableForInstallation(Callback) 检查是否已加载更新并可以安装 Callback接收两个参数：&emsp;&emsp;error：若存在不为null表示没有加载更新或者无需安装&emsp;&emsp;data：{&emsp;&emsp;&emsp;&emsp;CURRENTVERSION：当前版本&emsp;&emsp;&emsp;&emsp;readyToInstallVersion：准备安装版本&emsp;&emsp;} chcp.installUpdate(Callback) 检查是否已加载更新并可以安装 Callback只有一个参数那就是error，若不为null表示安装失败包含失败信息否则便是成功 错误代码详情&emsp;&emsp;jsAPI 1234567891011121314151617181920212223242526272829document.addEventListener("deviceready", onDeviceReady, false) function onDeviceReady() &#123; let chcp = window.chcp chcp.fetchUpdate((error, data) =&gt; &#123; // 检查更新 alert(data) if (error) &#123; alert('error', error.code, error.description) // 表示没有更新版本，或者其他错误 &#125; else chcp.isUpdateAvailableForInstallation((error, data) =&gt; &#123; // 检查是否已加载更新并准备安装 if (error) &#123; alert('No update was loaded =&gt; nothing to install') &#125; else &#123; if ( window.confirm('检测到新版本，是否更新') ) &#123; chcp.installUpdate((error) =&gt; &#123; // 安装更新 if (error) &#123; alert('Failed to install the update with error code: ' + error.code) alert(error.description) &#125; else &#123; alert('Update installed!') &#125; &#125;); &#125; else &#123; window.alert('您已拒绝更新') &#125; alert('Current content version: ' + data.currentVersion) alert('Ready to be installed:' + data.readyToInstallVersion) &#125; &#125;) &#125;) &#125; 参考文章Cordova Hot Code Push Plugin CLI client https://github.com/nordnet/cordova-hot-code-push-cli cordova-hot-code-push wiki https://github.com/nordnet/cordova-hot-code-push/wiki/Update-workflow Cordova 代码热更新 https://www.jianshu.com/p/55fd5e9f96ea]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova之相机拍照以及本地图片获取上传]]></title>
    <url>%2F2018%2F08%2F27%2Fcordova_%E5%9B%BE%E7%89%87%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[安装12345678910图片获取此插件定义了一个全局navigator.camera对象，该对象提供用于拍摄照片和从系统图像库中选择图像的API支持平台：Android、BlackBerry、Browser、Firefox、FireOS、iOS、Windows、WP8、Ubuntucordova plugin add cordova-plugin-camera图片上传这个插件定义了全局FileTransfer，FileUploadOptions构造函数，用于传输文件看你上传的方式如果你使用bs64就可以不用这个插件支持平台：Amazon Fire OS、Android、BlackBerry 10、Browser、Firefox OS**、iOS、Windows Phone 7 and 8*、Windowscordova plugin add cordova-plugin-file-transfer camera.getPicture官方文档camera.getPicture 功能打开设备的默认相机应用程序接受三个参数：调用成功的回调，失败的回调，以及调用方法需要设置的参数 1234567891011navigator.camera.getPicture(Success, Error, Options)imageFile () &#123; navigator.camera.getPicture(success, error, &#123; quality: 50, destinationType: Camera.DestinationType.DATA_URL, sourceType:0 &#125;) function success(imageURI) &#123; alert(JSON.stringify(imageURI)) &#125; function error(message) &#123; alert(JSON.stringify(message)) &#125;&#125;, 自定义参数这里只列举了一些常用的 api，而且某些参数在不同平台表现会有差异，建议你去官方文档查看更详细的参数 quality：默认 50，保存图像的质量，表示为 0-100 的范围，其中 100 通常为全分辨率，不会因文件压缩而丢失。 destinationType：调用成功的返回值格式 DATA_URL（返回 base64 编码的字符串）、FILE_URI（文件 url）、NATIVE_URI（原生 url） sourceType：图片来源 PHOTOLIBRARY(从图片库中选择图片（与 SAVEDPHOTOALBUM for Android 相同）) CAMERA(相机拍照) SAVEDPHOTOALBUM(从图片库中选择图片（与 Android 的 PHOTOLIBRARY 相同）) Direction: 摄像头是前置还是后置，这个当然是 PictureSourceType 等于 CAMERA 时有效 BACK（前置） FRONT（后置） saveToPhotoAlbum：拍照后将图像是否保存到设备上的相册中，返回 boolean correctOrientation：拍照时是否旋转图像以校正设备的方向，返回 boolean EncodingType：图片格式，可选 JPEG 或者 JPEG MediaType：能否选择视频或者其他媒体类型，默认只能选择图片 popoverOptions：仅限 iOS 的选项，用于在从 iPad 的库或相册中选择图像时指定弹出框的锚元素位置和箭头方向 FileTransfer官方文档分为上传和下载 上传options：可选参数（Object） fileKey：表单元素的名称。默认为file fileName：在服务器上保存文件时使用的文件名。默认为image.jpg httpMethod：要使用的HTTP方法 - PUT或者POST。默认为POST mimeType：要上载的数据的mime类型。默认为image/jpeg params：一组可选的键/值对，用于传递HTTP请求。（对象，键/值 - DOMString） chunkedMode：是否以分块流模式上传数据。默认为true。（布尔） headers：标题名称/标题值的映射。使用数组指定多个值。在iOS，FireOS和Android上，如果存在名为Content-Type的标题，则不会使用多部分表单数据123let ft = new FileTransfer()ft.upload(fileURL,encodeURI("http://some.server.com/upload.php"), successCallback, errorCallback, options)参数：文件地址，上传接口，成功回调，失败回调，上传需设置的可选参数 下载12345678let ft = new FileTransfer();fileTransfer.download(uri, fileURL,successCallback successCallback, errorCallback,false,&#123; headers: &#123; "Authorization": "Basic dGVzdHVzZXJuYW1lOnRlc3RwYXNzd29yZA==" &#125; &#125;)参数：服务器url，设备上文件的文件系统URL，成功回调，失败回调，上传需设置的可选参数，是否接受所有安全证书，可选参数目前只支持header]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova获取设备信息以及sim卡MSISDN等信息]]></title>
    <url>%2F2018%2F08%2F24%2Fcordova_%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[设备信息获取支持平台：Android、Browser、iOS、Windows、OSX这是cordova官方插件，附上官方文档12插件安装cordova plugin add cordova-plugin-device 使用方法1234567891011document.addEventListener("deviceready", onDeviceReady, false) function onDeviceReady() &#123; alert(device.cordova) // 当前cordova的版本 alert(device.model) // 设备的模型或产品名称 alert(device.platform) // 获取操作系统 alert(device.uuid) // 设备通用唯一标识uuid alert(device.version) // 操作系统版本 alert(device.isVirtual) // 判断设备是否在虚拟机上运行,返回Boolean alert(device.serial) // 设备序列号 alert(device.serial) // 设备制造商 &#125; sim卡信息获取支持平台：Android、iOS、Windows Phone 7 and 8附上npm文档12插件安装cordova plugin add cordova-plugin-sim 使用方法，更多参数查看文档1234567891011document.addEventListener("deviceready", onDeviceReady, false) function onDeviceReady() &#123; window.plugins.sim.getSimInfo(function(res)&#123; alert(res.carrierName) // 供应商 (SPN) alert(res.countryCode) // ISO 国家代码[中国是CN] alert(res.mcc) // 移动信号国家码 alert(res.mnc) // 移动网络号码 &#125;, function()&#123; alert('error') &#125;) &#125; 关于MSISDN获取sim插件的phoneNumber这个获取MSISDN（手机号码）的参数还有deviceId、simSerialNumber、subscriptionId等等，官方文档表示了有时只能拿到一个空字符串 原因：MSISDN可以存储在SIM卡上，但大部分电话运营商都不会将MSISDN存储在SIM卡上，有以下一些原因： 动态MSISDN分配：首次使用预付费SIM时，有时会为其分配MSISDN。这意味着网络具有可用的MSISDN池，并在新的预付费SIM上线时分配它们。这意味着当SIM卡出厂时，它们还没有MSISDN，这意味着在发送SIM卡之前无法存储MSISDN。有些网络在一段时间不活动后会过期’MSISDN分配，特别是当它们的可用数量不足时，并将这些数字返回到可用池。 移动号码可携带性：一些国家/地区允许移动用户保留其MSISDN但更改网络。这意味着MSISDN将从用于1个网络的SIM移动到用于另一个网络的SIM。 因此SIM上的MSISDN条目通常为空，用户可以在SIM卡上存储MSISDN或者任意数字所以MSISDN通常为空，但如果你获取到了也是因为用户在设备中设置“我的电话号码”什么的所以也并不保证一定正确 可能的方法：通过WAP / WEB，当移动运营商在标题中包含MSISDN时（你可以做一些webview技巧来查看标题是通过的 - 但是你只看到这些如果是网络支持它，如果用户在移动数据上 - 即如果用户在WiFi上，它将无法工作 来源:https://stackoverflow.com/questions/10695601/msisdn-is-it-a-sim-card-data-why-all-the-provided-function-from-blackberry-a 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法(备忘)]]></title>
    <url>%2F2018%2F08%2F23%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[转义1特殊符号使用 \ 转义，例 \* \# \&gt; 字体颜色我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffcolor=gray 123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 官方文档 空格半方大的空白&ensp;或&#8194;全方大的空白&emsp;或&#8195;不断行的空白格&nbsp;或&#160; 123半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160; 代码12少量代码使用 ` 一个反引号包裹多行代码使用三个反引号包裹 使用三个反引号包裹并指定语言 123$(document).ready(function () &#123; alert('hello world');&#125;); 支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 字体大小1号2号3号4号5号6号123456# 1号## 2号### 3号#### 4号##### 5号###### 6号 字体着重这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 字体缩进 这是引用的内容 这是引用的内容 这是引用的内容 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 分割线12三个以上的 - 或者 * ,效果一样*** 123456```## 图片引用``` text![图片alt](图片地址 ''图片title'') 超链接1[百度](http://baidu.com) 列表 列表 1.列表内容2.列表内容3.列表内容 1234567891011无序列表，使用- + *效果一样- 列表+ 列表* 列表有序列表1.列表内容2.列表内容3.列表内容注意：符号跟内容之间要有一个空格 表格 表头 表头 表头 内容 内容 内容 内容 内容 内容 123456789表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容| 左对齐标题 | 右对齐标题 | 居中对齐标题 || :------| ------: | :------: |表格内换行使用 &lt;/br&gt; 标签 链接百度 1[百度](http://baidu.com)]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的常用命令(备忘)]]></title>
    <url>%2F2018%2F08%2F22%2Fhexo%2F</url>
    <content type="text"><![CDATA[常用命令官方文档 123456789101112131415$ git clone &apos;远程仓库&apos; themes/ &apos;本地文件名称&apos;hexo s 启动服务hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g 部署之前预先生成静态文件hexo d 部署hexo new &lt;title&gt; 新建一篇文章hexo new draft &lt;title&gt; 新建一篇草稿hexo publish &lt;title&gt; 将草稿移入posts文件夹图片上传插件npm install hexo-asset-image --save代码上传到github所需要的依赖包npm install hexo-deployer-git --save hexo部署报错：The file will have its original line endings in your working directory. 删除.deploy_git文件夹 运行 git config –global core.autocrlf false 正常流程 hexo clean / hexo g / hexo d]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫之selenium自动化测试让你爬虫更像用户]]></title>
    <url>%2F2018%2F08%2F22%2Fpython_selenium%2F</url>
    <content type="text"><![CDATA[全程序自动化操作 先科普一下selenium，这是一个用于Web应用程序测试的工具，支持多种浏览器多种语言 框架底层使用JavaScript模拟真实用户对浏览器进行操作，Selenium测试直接运行在浏览器中，代码执行时，可以自动打开浏览器/表单输入/按钮点击，就像真实用户在操作的一样 真真是反爬虫的一大神器啊 先附上文档了解一些基础知识：官方文档中文文档 关于安装1cmd命令：pip3 install selenium 下载谷歌驱动安装：https://sites.google.com/a/chromium.org/chromedriver/downloads 放在谷歌文件夹C:\Program Files (x86)\Google\Chrome\Application下再把这路径加入环境变量 基础知识Xpath是非常强大的元素查找方式，它可以定位到页面上的任意元素 我这里只介绍了一些今天这个实例会用到的 首先先了解一下它的一些语法// ： 相对路径，以这个开头表示从寻找文档的根节点开始查找元素，若出现在xpath路径中则表示寻找父节点下任意符合条件的子节点，不管嵌套了多少层级/：绝对路径，表示寻找父节点下的第一层子元素也就是直接子元素“//标签名[@属性名=’属性值’]”：表示从根目录查找和标签名、属性值相匹配的元素几乎所有的Xpath路径都是以上面3种方法来组合的 精准定位以下面这个百度文库这段html举例 要获取输入框怎么写，写法不只一种哈，这地方你也可以直接使用input的id获取元素（一个页面正常来讲不会有相同的id） input = browser.find_element(By.XPATH, “//form[@name=’ftop’]//input[@id=’kw’]”) 上面这行是用的是find_element是查找单个元素，api在下面可以先看下 表示从根目录查找第一个匹配路径 name为flop的form标签 ，找到这个元素之后再去他所有子元素里面查找id为kw的input框 假设这个页面有两个name为ftop的form标签（name一样的form标签讲道理一个页面是不会有两个现在只是假设，有可能你会遇到class名一样的div标签） 那么获取第二个form标签：”//form[@name=’ftop’][2]//input[@id=’kw’]”, 就在大括号后面加上他的索引，索引是从1开始的 模糊定位contains关键字：input = browser.find_element(By.XPATH, “//input[contains(@id, ‘kw’)]”)表示寻找页面中id属性值包含kw所有input元素 text关键字：input = browser.find_element(By.XPATH, “//button[contains(text(), ‘搜索’)]”)表示寻找页面中文字中包含有搜索的所有button元素 starts-with关键字：input = browser.find_element(By.XPATH, “//a[starts-with(@href,’http://‘)]”)表示寻找页面中href属性以http://开头的a标签 ends-with关键字：input = browser.find_element(By.XPATH, “//a[ends-with(@href,’com’)]”)表示寻找页面中href属性以’com’结尾的a标签关于ends-widh我在使用的时候会报错提示语法不正确而且网上关于ends-with介绍也很少所以我没有找到原因如果大家知道欢迎留言告诉我不胜感激 (´▽`ʃ♡ƪ) 这是一个简单的关于用selenium和xpath来做模糊查询的小实例123456789101112131415161718192021222324252627chrome_options = Options()chrome_options.add_argument("--headless")browser = webdriver.Chrome(chrome_options=chrome_options)# 打开百度网址browser.get("https://www.baidu.com/")# 获取第一个http链接element_contains = browser.find_element(By.XPATH, "//a[contains(@href, 'http://')]")print(element_contains.text)# 获取第一个包含文字中包含'地图'的a标签element_text = browser.find_element(By.XPATH, "//a[contains(text(), '地图')]")print(element_text.text)# 获取第一个文字以'贴'开头的a标签element_starts = browser.find_element(By.XPATH, "//a[starts-with(text(), '贴')]")print(element_starts.text)browser.close() selenium的一些常用apifind_element和find_elements的使用 browser.find_element(By.XPATH, ‘//button[text()=”Some text”]’) //单个元素获取 browser.find_elements(By.XPATH, ‘//button’) //多个元素获取 ID = “id”XPATH = “xpath”LINK_TEXT = “link text”PARTIAL_LINK_TEXT = “partial link text”NAME = “name”TAG_NAME = “tag name”CLASS_NAME = “class name”CSS_SELECTOR = “css selector” 单个元素选取（多个元素选取：就是在element后面加一个s，比如find_elements_by_id）： find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 获取到标签之后的界面交互： input.send_keys(“输入中”)input.clear() 清空输入框button.click() 按钮点击 常用的控制浏览器的api： browser.back() 浏览器后退browser.forward() 浏览器前进browser.get(“https://www.zhihu.com/explore&quot;) 打开页面browser.execute_script(“alert(‘To Button’)”) 执行js代码print(browser.window_handles) 所有的标签browser.switch_to_window(browser.window_handles[1]) 切换到指定标签页browser.close() 关闭当前标签页 代码实例关于页面模块引入123456789101112131415161718# 引入浏览器驱动from selenium import webdriver # 这里我们需要引入浏览器内核才可以使用浏览器的无头模式，这里我引入的是chrome# Gecko：是Firefox浏览器的内核# Trident：是IE浏览器的内核# Blink：是webkit的一个分支版本，由google开发# 关于什么是无头模式：即headless browser，是一种没有界面的浏览器，主要是用作爬虫，用以捕捉Web上的各类数据from selenium.webdriver.chrome.options import Options # 主要用于使用两个私有方法find_element和find_elementsfrom selenium.webdriver.common.by import By # 调用键盘apifrom selenium.webdriver.common.keys import Keys# 用于时间延迟import time 功能代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960chrome_options = Options()chrome_options.add_argument("--headless")browser = webdriver.Chrome()# 打开页面browser.get("https://wenku.baidu.com/") # 获取搜索输入框input = browser.find_element(ID, 'kw') # 输入内容input.send_keys("IT/计算机")# 模拟回车input.send_keys(Keys.ENTER) # 获取'我知道了'按钮btn = browser.find_element(By.XPATH, "//div[@class='new-filter-box fc5']//span[@class='btn-know']")btn.click()time.sleep(1) # 时间延迟# 点击列表的第一条数据btn = browser.find_element(By.XPATH, "//div[@class='main']//dl[1]//a[1]")btn.click()time.sleep(4)# 将browser页面切换至当前页面browser.switch_to_window(browser.window_handles[1])# 关闭当前页面browser.close()# 切换至第一个页面browser.switch_to_window(browser.window_handles[0])time.sleep(1)# 点击列表的第二条数据btn = browser.find_element(By.XPATH, "//div[@class='main']//dl[2]//a[1]")btn.click()time.sleep(4)# 视图切换至第一个页面browser.switch_to_window(browser.window_handles[0])time.sleep(2)# 去往百度页面browser.get("https://baidu.com/")# 打印所有标签print(browser.window_handles) 开启无头模式只需要修改一行代码1browser = webdriver.Chrome(chrome_options=chrome_options) 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova定位 + 仿钉钉打卡功能]]></title>
    <url>%2F2018%2F08%2F20%2Fcordova_%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[最近在研究hybridApp，使用vue+cordova，现在需要实现一个钉钉打卡的功能大致要实现这4个需求：地图显示、定位、地图覆盖效果、距离测量 定位定位相对而言比较复杂所以优先考虑，关于定位，我尝试了3种办法 第一个尝试了cordova自带的插件，结果是报错：code：2，message：network provider is not available，原因是新版的插件已经删掉了关于Android版定位的代码，改为基于系统浏览器(chrome内核)进行定位，但经测试发现因为国内网络原因根本无法定位 第二个是用的高德地图的JavaScript API，定位虽然成功但是定位和实际位置有几百米的误差这个肯定不行 第三个是用的cordova的baidumaplocation插件，误差在几十米之间还可以接受 首先附上插件github的连接 第一步你得先去百度创建一个应用 创建android应用签名文件/查看SHA1开发版本12345cd .android 进入 C:\Users\FLTD-Y01\.android&gt;调试版本使用debug.keystore，命令为：keytool -list -v -keystore debug.keystore。提示输入密钥库密码，调试版本默认密码是: android 发布版本12建立签名文件$ keytool -genkey -v -keystore key.keystore -alias key -keyalg RSA -validity 365 回车后会让你输入名字公司什么的，按照提示继续就好 执行完成后会在文件夹内创建一个key.keystore的签名文件 然后就能够看到md5、SHA1什么的了 12查看签名信息$ keytool -list -v -keystore key.keystore 安装baidumaplocation插件123安装baidumaplocation插件$ cordova plugin add cordova-plugin-baidumaplocation --variable ANDROID_KEY="你的key" --variable IOS_KEY="value" --save 只需要Android端或者IOS端，可以只填写一个相应的key，另外一个你还是得填点什么，不然你懂的 炒鸡简单的用法上代码12345$ baidumap_location.getCurrentPosition (function (result) &#123;$ console.log(JSON.stringify(result))$ &#125;, function (error) &#123;$ console.log(JSON.stringify(error))$ &#125;) 温馨提示：只有在手机上才能获取比较准确的信息，所以最好真机测试 地图显示、覆盖物效果、距离计算除了定位以外的其他功能我都用的是JavaScript API 那么第一步是去百度创建一个浏览器端类型的应用 然后你会得到一个key，然后在index引用百度地图API文件 1&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=您的密钥"&gt;&lt;/script&gt; 最后上代码1234567that.bmap = new BMap.Map("allmap") // 新建地图实例let location = new BMap.Point(enterprise1, enterprise2) // 新建坐标，参数为企业坐标that.bmap.centerAndZoom(location, 16) //设置企业坐标为中心点坐标let circle = new BMap.Circle(location, 500, &#123;strokeColor:"blue", strokeWeight:2, strokeOpacity:0.5&#125;) // 创建地图圆形覆盖效果that.bmap.addOverlay(circle) // 增加效果 let pointB = new BMap.Point(result.longitude, result.latitude) // 新建点坐标，参数为定位获取到的坐标console.log((that.bmap.getDistance(location, pointB)).toFixed(2)) // 计算距离，小于500可以打卡，反之则是超出范围 关于报错如果Android版获取到的信息是：{ “locType”: 505, “locTypeDescription”: “NetWork location failed because baidu location service check the key is unlegal, please check the key in AndroidManifest.xml !”, “latitude”: 5e-324, “longitude”: 5e-324, “radius”: 0, “userIndoorState”: -1, “direction”: -1}这个坑我是踩了，不管你信息是否获取成功过，只要出现了上面的信息就说明Key有问题 检查第一步创建的百度Android应用 检查下生成的AndroidManifest.xml文件里面是否有如下信息123&lt;service android:enabled="true" android:name="com.baidu.location.f" android:process=":remote"&gt;&lt;/service&gt;&lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="abcdefghijklmn" /&gt; 然后重新安装 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+ECharts4.x地图下钻/散点分布以及热力图]]></title>
    <url>%2F2018%2F08%2F15%2Fvue_ECharts4-x%2F</url>
    <content type="text"><![CDATA[最近用到了echarts，实现三个功能国家到省级的地图下钻和散点分布以及热力图显示 网上资料蛮少的，记录一个给后面的小伙伴一些参考 demo效果如下中国地图下显示为热力图，显示精确分布点只是demo所以数据是自己写的假数据只有几条点击进入省份地图，在地图之外还有那个小箭头是数据的原因不是bug改下数据就好 先上官网http://echarts.baidu.com/option.html#title，表白echarts，文档真的很详细，良心官网 demo代码如下下钻到市级县级道理也是如此123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081mapfun(name)&#123; console.log(this.chartNum) // 注意文件路径 this.$http.get('static/province/'+name+'.json').then(res =&gt; &#123; echarts.registerMap(name, res.body) let data = []; res.body.features.forEach(item =&gt; &#123; data.push(&#123; name:item.properties.name &#125;) &#125;) this.chartNum !== 1 ? this.myChart.dispose() : '' // 创建新实例之前一定要销毁上一个实例，否则重复多次点击无数的实例导致内存爆满 this.chartNum++ this.myChart = echarts.init(document.getElementById('myChart')) this.myChart.showLoading() this.myChart.setOption(&#123; title: &#123; // 标题 text: "分布图", left: "center", padding: 30, textStyle: &#123; color: "#fff", fontSize: "30" &#125; &#125;, visualMap: &#123; // 热力图颜色显示 default:'piecewise ', default: 5, calculable:true, textStyle:&#123; color: '#fef420' &#125;, inRange: &#123; color: ['#fef420', '#df383e','#379fdf'], &#125;, &#125;, geo: [&#123; // 地图 type: 'map', map: name, // 地区名字，重要参数 itemStyle: &#123; areaColor: "#d7bed9", borderColor: "#111", &#125;, emphasis: &#123; label:&#123; show: false &#125;, itemStyle: &#123; areaColor: "#f5d4f8" &#125; &#125;, data: data, // 数据，重要参数 label: &#123; // 标签的显示 normal: &#123; show: false &#125;, emphasis: &#123; show: true &#125; &#125;, &#125;], series: [&#123; // 散点分布 roam: true, type: name === 'china' ? "heatmap" : "scatter", // 中国地图下显示热力图，省级地图下显示精确分布点 coordinateSystem: "geo", data: [['116.347927', '39.948795', 100], ['100.06376', '30.554698', 75], ['104.05325', '29.646273', 50],['104.05325', '25.646273', 25],['94.05325', '30.646273', 1]], blurSize: 20, symbolSize: 20, symbol: 'arrow', minOpacity: 0.1, maxOpacity: 1, &#125;] &#125;) setTimeout(() =&gt; &#123; this.myChart.hideLoading() &#125;, 1000) this.myChart.on('click', params =&gt; &#123; // 点击函数 name === 'china' ? this.mapfun(params.name) : this.mapfun('china') &#125;) &#125;) &#125; &#125; 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作mysql/mysql增删查改语句]]></title>
    <url>%2F2018%2F08%2F09%2Fpython_mysql%2F</url>
    <content type="text"><![CDATA[PyMySQL安装/方法介绍PyMySQL是由python编写的，速度上比不上 MySQLdb，但是他安装非常方便同时也兼容 MySQL-python pip install pymssql 基本方法介绍close():关闭此connect对象commit():提交当前事务rollback():取消当前事务cursor():创建游标对象 关于游标游标是一段私有的SQL工作区,也就是一段内存区域,用于暂时存放受SQL语句影响到的数据。通俗理解就是将受影响的数据暂时放到了一个内存区域的虚表中，而这个虚表就是游标。 也就是说在commit之前你操作的都是这个游标，操作错误你可以使用rollback()方法回滚，如果在增删改之后没有commit所有操作都是白搭 操作游标的方法close():关闭此游标对象fetchone():得到结果集的下一行fetchmany([size = cursor.arraysize]):得到结果集的下几行fetchall():得到结果集中剩下的所有行excute(sql[, args]):执行一个数据库查询或命令excutemany(sql, args):执行多个数据库查询或命令 现在上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import pymysql# 连接mysql# host为数据库的主机IP地址, port为MySQL的默认端口号, user为数据的用户名, password为数据库的登录密码, db为数据库的名称config = &#123; 'host': 'localhost', 'port': 3306, 'user': 'root', 'password': '123456', 'database': 'reptiledata'&#125;db = pymysql.connect(**config)cursor = db.cursor() # 建立游标对象# -----------------------------------------表操作----------------------------------------------------------------# 如果存在就删除表cursor.execute("drop table if exists user")# 新增表cursor.execute("""create table if not exists user( id int auto_increment primary key, name varchar(5), sex char(1), id_card char(18), phone varchar(14), address varchar(12), create_time time)""")# 修改自增长Id,数据库新增的数据会从1000开始但是原来的数据不会改变cursor.execute('alter table user AUTO_INCREMENT=1000')# 新增数据库表字段cursor.execute('alter table user add plus varchar(8)')# --------------------------插入数据-------------------------------------------------------------------------------# 批量插入数据cursor.execute('alter table user drop plus')# 插入单条数据但因为后面用了db.rollback()回滚，所以此条数据不会被添加cursor.execute("""insert into user(name, sex, id_card, phone, address) values ('李四', '女', '511569845612354879', '10086', '数据不会被添加')""")db.rollback() # 批量插入数据，如果不列出字段名mysql会按照顺序添加sql = """insert into user(name, sex, id_card, phone, address) values (%s, %s, %s, %s, %s)"""sql_data = [['张三', '女', '511569845612354879', '10086', '太古里77号'], ['李四', '男', '511569845612354879', '10086', '太古里77号'], ['王麻子子', '男', '511569845612354879', '10086', '太古里66号'], ['张二', '女', '511569845612354879', '10086', '太古里77号'], ['李五', '男', '511569845612354879', '10086', '太古里88号'], ['王麻子', '女', '511569845612354879', '10086', '太古里99号']]cursor.executemany(sql, sql_data)# ----------------------------------------查询数据-----------------------------------------------------------------# order by 对查询结果进行排序 select 字段1,字段2,字段3 from 表名 order by 字段 desc(降序)||asc(升序)cursor.execute("select address,id from user order by id desc")select = cursor.fetchall()print(select)# 去重复查询 select distinct 字段 from 表名cursor.execute("select distinct address from user")select = cursor.fetchall()print(select)# 分页查询 limit select 字段1，字段2 from 表名 limit 初始位置，记录数cursor.execute("select id, name, sex, id_card from user limit 3,6")select = cursor.fetchall()print(select)# 精准查询 in 只查找括号内的数据； not in 则相反cursor.execute("select * from user where ID in (1001,1003)")select = cursor.fetchall()print(select)# 精准查询 between and 查找1001-1003范围内的数据；not between and 相反cursor.execute("select * from user where ID between 1001 and 1003")select = cursor.fetchall()print(select)# 模糊查询 like (% 代表任意字符 _ 代表单个字符)；not like相反cursor.execute("select * from user where name like '_麻%'")select = cursor.fetchall()print(select)# 多条件查询 and 关键字cursor.execute("select * from user where sex='女' and address='太古里77号'")select = cursor.fetchall()print(select)# 多条件查询 or 关键字 只需满足一个条件cursor.execute("select * from user where name='王麻子子' or address='太古里77号' ")select = cursor.fetchall()print(select)# ------删除数据和更新数据 or,and,between and,like等关键字可以查询到多条数据然后批量删除或者更新-----------------------------------# 删除数据cursor.execute("delete from user where name='王麻子子' or address='太古里77号'")# 数据库清空cursor.execute("truncate table user")# 更新数据cursor.execute("update user set name = '更新' where ID in (1005,1006)")cursor.close() # 关闭游标对象db.commit() # 提交操作db.close() # 关闭数据库 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue小程序以及微信直播踩坑总结]]></title>
    <url>%2F2018%2F08%2F07%2Fmpvue%2F</url>
    <content type="text"><![CDATA[前段时间刚写完一个mpvue的小程序，现在得闲必须赶紧记录和总结一下，不然很多东西又要忘了 我是比较熟悉vue的语法，但是也犹豫过是用原生还是用mpvue，因为那时候原生小程序已经相当成熟而mpvue才刚出来（踩坑和填坑的前人还很少） 所以我学习了几天原生的框架和语法，果断选择了mpvue，真的是没有对比就没有伤害，对比原生体验不要太好 mpvue是一个使用 Vue.js 开发小程序的前端框架，他是将我们写的vue文件重新编译成wxml等文件，最后的底层实现还是用的小程序语法，所以原生小程序语法也是比较重要的，而且像很多下拉刷新，到底部请求下一页什么的等等很多地方也是要用到小程序api的，所以建议大家在入坑之前还是了解一些小程序语法比较好 附上官方文档 项目配置使用官方的5分钟上手，生成一个基本框架，后来开发也没有手动修改过他的配置 用到了4个插件 mpvue-weui ui库，相当方便轻量好使官网地址：http://kuangpf.com/mpvue-weui/#/ mpvue-toast 一个基于mpvue的简单弹窗组件因为mpvue目前还不支持全局的组件，所以没有办法像vue组件引入一次就能在所有页面使用，但是mpvue团队已经在考虑新增全局组件功能了 github地址：https://github.com/linrui1994/mpvue-toast sass 不多介绍全局安装：npm install sass-loader node-sass –save-dev 在style节点加上lang=”scss”，这样就可以愉快地使用sass进行开发了 mpvue-router-patch 在mpvue 中使用 vue-router 兼容的路由写法当知道mpvue不支持vue-router的时候我还是非常难受，还好mpvue团队后面发布了这个插件，非常简单好用 github地址：https://github.com/F-loat/mpvue-router-patch 接下来的3个插件我没有用过但是和mpvue-router-patch一样是mpvue团队发布的，感觉应该也不差，也推荐给大家如果需要可以花时间了解一下 mpvue-echarts 适用于 Mpvue 的 ECharts 组件github地址：https://github.com/F-loat/mpvue-echarts 微信小程序富文本解析组件 适用于 Mpvue 的微信小程序富文本解析自定义组件github地址：https://github.com/F-loat/mpvue-wxParse mpvue-entry自动生成各页面的入口文件 集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新github地址：https://github.com/F-loat/mpvue-entry 关于ajax请求封装，拿走不谢123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let urlPath = '' // 项目的域名export function post(url, data) &#123; wx.showLoading(&#123; title: '努力加载中', &#125;)// 由于微信不会保存后端用于登陆验证的cookie，这里需要自己从登陆返回的数据里取到cookie，然后本地缓存，请求时在header里带上cookie let header = &#123;&#125; url === 'user/loginworker' // 通过传进来的url判断是否是登陆页 ? header = &#123;&#125; : header = &#123; 'content-type': 'application/x-www-form-urlencoded', 'cookie': wx.getStorageSync("sessionid") &#125; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: urlPath + url, data: data, method: 'get', header: header, success(res) &#123; console.log(res) if (res.statusCode === 200) &#123; if (res.data === 9999) &#123; // 后端返回9999表示cookie失效 wx.showModal(&#123; content: '登陆超时请重新登陆', showCancel: false, success: function (res) &#123; if (res.confirm) &#123; wx.navigateTo(&#123; url: '../../pages/login/main', &#125;) &#125; &#125; &#125;) &#125; else if (res.data.code &amp;&amp; res.data.code !== 200) &#123; // 若返回coode码且不等于200表示传入参数有问题 res.message = res.data.message, reject(res) &#125; else resolve(res) // 存储cookie res.data.message === '登录成功。' ? wx.setStorageSync("sessionid", res.header["Set-Cookie"]) : "" &#125;else &#123; res.message = '服务器错误请求失败' reject(res) &#125; wx.hideLoading() &#125;, fail(err) &#123; err.message = '请求超时请稍后再试' reject (err) wx.hideLoading() &#125; &#125;) &#125;)&#125; 生命周期钩子created是vue的生命周期在mpvue里所有页面的created函数会在项目加载的时候被一起调用，可用性不大，可以使用onShow()代替，但是onShow()只有在隐藏又显示后才会显示,也就是第一次加载不会执行 created() { console.log(‘created’) }, mounted() { console.log(‘mounted’) }, onLoad() { console.log(‘onLoad’) }, onShow() { console.log(‘onShow’) }, onUnload() { console.log(‘onUnload’) }, onHide() { console.log(‘onHide’) }, 页面跳转后并没有销毁页面实例比如一个搜索页面，页面第一次进来所有的数据都是空的，但你搜索一次之后，input框就有值了，这个时候再跳转到其他页面或者返回之后再进入这个页面那个值依然存在，页面跳转后并没有销毁页面实例，而是将其推入页面栈中，所以会保存之前的旧的数据，目前为止看到的比较统一的解决办法就是：在onShow()或者onLoad()手动清空 关于微信直播这个小程序需要引入监控相当于是直播功能，这个组件也是有点坑 Live-player组件本身只能播放，如果想要在组件上加功能，像什么全屏静音播放暂停之类的功能需要使用wx.createLivePlayerContext()方法，而且由于live-player层级是最高的，如果你需要在组件上加功能比如点一下全屏再点下退出全屏或者加css样式，你必须写在 cover-view cover-image上面，直接加在live-player上是没用的 123&lt;live-player id='liveInfo' src="" mode="live" autoplay='false' @bindstatechange="statechange" binderror="error"&gt; &lt;cover-image @click="requestFullScreen"&gt;&lt;/cover-image&gt;&lt;/live-player&gt; 你以为这样就完了嘛，不，如果你有一个直播列表，比如一个屏幕同时有一个以上的live-player组件那么你全屏的时候就会发现其余的组件因为层级的原因全部覆盖在你全屏的那个组件之上 解决办法：全屏是v-if隐藏其余的组件，退出时再显示 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫之爬取掘金网首页存入mysql数据库]]></title>
    <url>%2F2018%2F08%2F07%2Fpython_%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[博主是个前端小白，最近在学习爬虫，写个实战系列也是想记录自己学习的过程，以便后续回顾 欢迎大家一起交流学习、共同进步 这篇文章达成的效果是爬掘金网的首页的数据存到mysql数据库里 做这个实战你需要具有一点点python的基础知识，当然没有也行可以复制代码先跑一跑感受一下会有动力一点 爬取的网站：https://juejin.im/timeline 系统：win10 python版本:3.7 MYSQL安装包下载：https://dev.mysql.com/downloads/windows/installer/ mysql-installer-web-community 15.9M那个是在线安装 mysql-installer-community 推荐下载第二个离线安装 现在这个安装包好像不分32位还是64位，我是64位的安装成功，MSI安装版安装挺简单的我就不赘述了（其实我安装蛮久了没记录下来） 安装完成可以通过·mysql -u root -p查看 mysql安装成功后你还需要一个python操作mysql的库，cmd执行使用pip安装pymysql: pip install pymysql环境准备好后就开始愉快的学习吧 网站分析我们进入网站https://juejin.im/，然后打开f12（博主用的是chrome浏览器，在前端眼里chrome是最好浏览器没有之一） 掘金网是个动态网站，即客户端（浏览器）根据服务端（服务器）返回的数据动态渲染网页 那么数据从哪儿来，服务端会根据客户端不同的请求或者请求参数的差异来返回数据 这里我们需要登陆下，我们登陆成功即通过服务端验证后服务器会签发一个 Token发送给客户端，你可以理解为一个验证身份的令牌，客户端收到 Token 以后把它存储起来，每次向服务端请求资源的时候都需要带着这个token，服务端收到请求，去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 我们可以看到有很多请求，什么图片、脚本资源、svg很多 点击XHR按钮过滤请求只显示XMLHttpRequest方法发送的请求 过滤之后现在挨着查看，找到返回文章数据的那条请求 大部分数据都是页面或者服务器做判断用的，我们提取这些参数就好 [‘category’][‘name’] 文章分类[‘title’] 文章标题[‘content’] 文章概要[‘originalUrl’] 文章链接[’tags’] 文章标签[‘user’][‘username’] 文章作者 然后我们查看他的Headers，滑到底部可以看到uery string params是由客户端发给服务器时请求携带的参数 这些参数里面有个limit是请求的条数，就是你请求多少条就会返回多少条数据 现在上代码需要3个库，除了第一个pymsql以为都是python自带的123import pymysql # 操作mysql的库from urllib import request, parse #请求需要的库import json # 处理参数需要的库 我们先发送请求获取数据12345678910111213141516171819202122232425def juejin_req(data_num): # data_num是请求的条数 url = 'https://timeline-merger-ms.juejin.im/v1/get_entry_by_rank' # 请求的url req_data = &#123; # 请求需要携带的参数 'src': 'web', 'uid': '5b5ebcd1f265da0f60132076', 'device_id': 1533608440568, 'token': '你的token', 'limit': data_num, 'category': 'all', 'recomment': 1 &#125; req_data = str(parse.urlencode(req_data, 'utf-8')) # 由于是get请求所以我们在使用parse.urlencode()方法转换编码格式后还需要使用str()方法转换为字符串 json_data = request.urlopen(url+'?'+req_data) # 拼凑url发送请求 print('数据请求成功') json_data = json_data.read().decode('utf-8') # 拿到数据转换编码格式 json_data = json.loads(json_data) # 使用json.loads()将字符串序列化 json_data = json_data['d']['entrylist'] # 获取到数据列表 sql_data = [] # 最后储存到数据的变量 for item in json_data: # 循环遍历列表提取需要的数据 tag = [] for aa in item['tags']: # 提取标签 tag.append(aa['title']) sql_data.append((item['category']['name'], item['title'], item['content'], item['originalUrl'], str(tag), item['user']['username'],)) print('一共有%s条数据' % len(sql_data)) return sql_data 打开workbench，这是自带的一款可视化的sql操作工具 首先我们先新建一个连接点击新建一个连接—–填上连接名字hellosql—–点击ok—–在弹出的弹框中输入你的密码–点击ok 连接建立后我们新建一个数据库，在左侧红圈空白地方右键—create scheme（新建一个数据库），这地方我已经建了 输入数据库名字reptiledata—点击apply—出现一个弹框继续点击apply，这样我们就新建了一个数据库 这是操作数据库的代码，获取到请求的数据后将数据return处理在传给juejin_sql函数，所以把这段代码放在上面那段代码后面123456789101112131415161718192021222324252627282930313233def juejin_sql(sql_data): print('连接数据库') db = pymysql.connect(host='localhost', port=3306, # 端口号 user='root', password='123456', # 密码 database='reptiledata') # 数据库 cursor = db.cursor() # 建立一个游标对象 try: #判断表是否存在，若不存在则新建 cursor.execute("""CREATE TABLE IF NOT EXISTS juejin( category TEXT, title TEXT, content TEXT, originalUrl TEXT, tags TEXT, username TEXT)""") except: print("Table 'juejin' already exists") return False sql = """insert into juejin(category, title, content, originalUrl, tags, username) values (%s, %s, %s, %s, %s, %s)""" # sql语句 print('正在批量添加') cursor.executemany(sql, sql_data) # 批量添加 cursor.execute('select count(*) from juejin') results = cursor.fetchall() # 查询全部总条数 print('数据库目前有%d条数据' % results[0][0]) db.commit() # 对于数据增删改之后一定要提交操作 cursor.close() # 关闭游标 print('操作完成关闭数据库关闭游标') db.close() # 关闭数据库连接juejin_sql(juejin_req(100)) 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI和平面设计的区别]]></title>
    <url>%2F2018%2F06%2F24%2F%E5%B9%B3%E9%9D%A2%26%26ui%2F</url>
    <content type="text"><![CDATA[前段时间自告奋勇的给新项目做UI设计，项目包括一个网站一个app还有一个后台，后台没有设计套用以前的模板主要是将就前端也就是我还有我的小伙伴们,总的花费时间共一周左右 作为曾经的一只平面设计狗，这是我UI处女作 哈哈哈哈！！！ 在没做前端之前一直觉得平面和UI都是根据客户的需求设计画图嘛也都是平面图也没什么太大的区别，而且UI还不用像平面设计海报那样做一些复杂抓人眼球的效果，毕竟现在的页面为了追求速度用户体验什么的都是扁平化趋于简洁 这次呢是深切感受到了UI和平面的区别 在学习css开始我就知道UI画的图都是需要前端实现的，设计的时候，除了好的创意，还应该考虑到技术上的可行性，就像这次设计页面的时候是自动把自己代入了前端这个角色所以在设计时更多的考虑到css样式布局js的特效数据渲染什么的还有组件模块的复用问题等等，设计方面远不如平面设计那么自由洒脱 大部分平面设计的作品都是以印刷的平面形式表现，这需要设计师去了解各种材料之间的区别以及不同材料所做出来的成品效果的差别，但在设计方面却是比较自由的，在符合主题的情况下怎么好看怎么漂亮怎么抓人眼球怎么来，很多时候平面设计师一个人对接一个客户就能完成一个作品，而ui除了产品客户以外还得对接前端后端需要遵守一系列的项目流程，而最后的成功也是团队协作达成的效果，这也是很大的一个不同点 UI设计的时候除了考虑前端的实现还有最重要的是用户体验和交互，毕竟网页是会”动”起来的，不管是网站还是其他什么软件都是需要用户去操作，这需要去琢磨研究用户的行为，所以好的ui设计不只是画面的美观还要让用户操作起来感觉舒适简单自由 所以总的来讲呢，平面注重视觉创意，UI却是更注重用户交互，两者在视觉传达方面是共通的，但是在难点侧重点方面却是不一样的 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>RESTS</category>
      </categories>
      <tags>
        <tag>rests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令（备忘）]]></title>
    <url>%2F2018%2F05%2F23%2Fgit%2F</url>
    <content type="text"><![CDATA[克隆库到相对路径git clone https://github.com/stiekel/hexo-theme-random.git themes/random https://help.github.com/articles/removing-sensitive-data-from-a-repository/工作区：电脑里的目录，不包括隐藏的git目录暂存区：add提交到暂存区版本库：commit提交到版本库的分支上 指定用户名和邮箱git config –global user.name “”git config –global user.email “” 创建版本库Cd 版本库的位置/进入文件Mkdir 版本库名pwd（pwd将显示版本库目录和位置）git init（将这个目录变成git可以管理的版本库） 添加文件将文件放在版本库目录下git add files （告诉git添加了文件 可以add多个文件）git add –A(如果提交一整个文件夹，add后面加上这条命令)git commit –m “文件说明”（可以一次性提交多个文件） 修改文件git status (查看工作区状态)git diff（查看文件具体修改内容）修改文件之后要用add和commit -m重新提交 回退和前进git log(查看提交日志历史记录 时间是提交到git的时间 不会显示是哪个文件)git log -pretty=oneline（查看精简的历史记录）git reset –hard HEAD^^(在git中HEAD代表现在的版本，HEAD^代表上一个版本，HEAD^^代表上上个版本，在往上可以用HEAD~100)git reset –hard 版本号（用于当你已经回到之前的版本，想要回到最新的版本）cat files （查看文件内容）git reflog （用于你想要回到之前之后某一个版本但不知道那个版本号） 撤销修改git checkout – files （两种情况 1、files还没有提交到暂存区但是已经做了修改，这个命令丢弃工作区的更改。2、files提交到暂存区后又做了修改，这个命令可以回到刚提交暂存区的状态） 注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。git reset HEAD files（files已经提交到暂存区 这个命令撤销暂存区的文件，让文件回到工作区） 删除rm files (删除workspace的文件或者直接在电脑目录里删掉)git add –Agit commit –m”修改说明”删除之后不需要复原文件执行这两个命令git checkout – files(用repository里的files替换工作区的files，前提是files已经提交到repository)git rm files(delete the repository files)github删除文件操作 远程库提交ssh-keygen –t rsa –C “email address”(查看sshkey)git remote add origin 远程库地址（绑定远程仓库）git remote rm origin （用于上一个命令远程仓库填错了，之后重新绑定远程仓库）git push –u origin master（把本地库的内容推送到远程仓库）git push origin master（本地做了提交 用这个命令把最新修改推送到远程库）git oush –u origin +master (强行更新)git push origin 分支名字 （提交分支修改的内容） 远程库克隆到本地git clone远程库地址创建分支与合并分支查看分支：git branch（查看当前分支，会列出所有分支，当前分支前面会添加一个星号）创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout –b name合并某分支到当前分支：git merge name(在当前分支选择需要合并的分支) 删除分支：git branch –d name分支冲突你在两个分支上修改了内容最后要合并到主分支，照常合并之后查看工作区，在查看文件内容，文件已经更改 git merge –no-ff -m “注释” name通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。 查看远程库的信息 git remote查看远程库的详细信息 git remote –v 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova add android 报错4种解决方法]]></title>
    <url>%2F2018%2F05%2F16%2FCordova%20add%20android%20%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[方法一：可能网络有问题，换一个源（对我没有用）npm i nrm -g 安装nrm nrm ls 查看当前nrm内置的npm源 nrm use cnpm 切换源 方法二：可能版本有问题（对我没有用）npm view cordova-android 查看可选版本 cordova platform add android@7.0.0 切换版本 方法三：卸载cordva重新安装（对我没有用）运行命令：npm uninstall cordova -g删除文件夹：C：\ Users \ your-name \ .cordova重新安装cordova：npm install -g cordova现在转到项目文件夹，然后再试一次：cordova platform add android方法四：修改环境变量（解决）在环境变量path内加入C:\Windows\System32 如果以上方法对你没有用，可以用cordova -d platform add android调试看下提示信息相关博文：Android SDK 环境配置/Cordova环境搭建打包apk各种踩坑报错系列 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器]]></title>
    <url>%2F2018%2F05%2F13%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[新手入门弄了一个阿里云服务器自己学习使用 在官网上点击远程链接出现了终端管理的画面，安装官网的步骤一步一步的在本机尝试远程连接（系统win7），输入ip地址，用户名，点击确定，弹框输密码 然后就告诉我：你的凭据不工作，之前用于链接到***的凭据无法工作，请输入新凭据 之后各种百度，尝试各种方法 可能导致此故障的原因 1、客户端本地网络异常 [出现概率：3%] 这个就… 2、重置实例密码，未重启实例 [出现概率：7%] 找到原因，自己手贱改了密码不知道要重启故障现象：有实例密码修改记录，但无重启实例记录。 可能原因：您修改了实例密码，但是未重启 ECS 实例。 解决方法： 登录云服务器管理控制台。单击左侧导航栏中的 实例。单击页面顶部的地域。选择需要的实例。单击 重启。在弹出的提示框中，选择 重启，单击 确定。 3、防火墙配置异常（Windows 2008&amp;2012）[出现概率：10%] 前提条件：您只有在已授权可关闭防火墙的情况下，才能做该项排查。故障现象：远程无法连接，关闭 防火墙 后连接恢复。解决方法：调整防火墙配置策略，具体操作详见官网：ECS Windows 远程连接之防火墙设置。完成操作后，请再进行远程连接。 4、安全组公网规则 [出现概率：8%] 故障现象：ECS 服务器无法ping通，排查防火墙、网卡 IP 配置无误，回滚系统后仍然无法ping通。可能原因：ECS 实例安全组默认的公网规则被删除。解决方法：重新配置 ECS 实例的安全组公网规则，具体操作详见 ECS实例安全组默认的公网规则被删除导致无法ping通。 5、远程访问端口配置异常 [出现概率：10%] 故障现象：远程无法连接，远程访问端口非默认端口。解决方法：运行注册表，然后查看此文档https://yq.aliyun.com/articles/33712 6、CPU 负载过高 [出现概率：9%] 故障现象：CPU 负载过高导致系统无法进行远程连接。 附上官网关于连接失败的的文档： https://help.aliyun.com/knowledge_detail/40849.html?spm=a2c4g.11186623.4.1.zfSNDN https://help.aliyun.com/knowledge_detail/50982.html 其他楼主遇到的这格问题的一些解决方法，百度搜来大多都是差不多，这个楼主的方法蛮全的 https://blog.csdn.net/sun15732621550/article/details/50444398 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>SERVER</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular之constant和filter]]></title>
    <url>%2F2018%2F01%2F31%2Fangular_constant%26filter%2F</url>
    <content type="text"><![CDATA[背景介绍angular是什么：AngularJS最初由Misko Hevery和Adam Abrons于2009年开发，后来成为了Google公司的项目。AngularJS弥补了HTML在构建应用方面的不足，其通过使用标识符（directives）结构，来扩展Web应用中的HTML词汇，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。 constant，可以算作angular的全局数据，想要使用的话，只需要在控制器注入即可。 $filter，angular的过滤器，如果想要在控制器里面使用，也是注入，然后调用，而html中的数据过滤，直接键入过滤器名称和对应值即可。 知识剖析每当搜索constant时候，总会连带出现value的说明。 两者都可以作为全局变量使用，但是有两点不同： 1.value不可以在config里注入，但是constant可以。 2.value可以修改，但是constant不可以修改，一般直接用constant配置一些需要经常使用的数据。 下面是简单的应用例子：123456789101112131415angular.module('myApp', []).constant('apiKey', '123123123').value('FBid','231231231').controller('myController',function($scope,apiKey,FBid)&#123;$scope.a = apiKey;$scope.b = FBid;&#125;).config(function(apiKey) &#123;//在这里apiKey将被赋值为123123123//就像上面设置的那样&#125;).config(function(FBid) &#123;//这将抛出一个错误，未知的provider: FBid//因为在config函数内部无法访问这个值&#125;); filter是用来格式化数据用的12345基本原型：&#123;&#123;expression | filter&#125;&#125;多个filter连用版：&#123;&#123;expression | filter1 | filter2&#125;&#125;传入参数版：&#123;&#123;expression | filter:1:2&#125;&#125; 常见问题如何使用angular中constant和$filter？ 解决方案4.1 AngularJS内建了一些常用的filter： 1、格式化货币：1234567&#123;&#123; 12 | currency&#125;&#125; //将12格式化为货币，默认单位符号为'$',小数默认2位&#123;&#123; 12.45 | currency:'￥'&#125;&#125; //将12.45格式化为货币，使用自定义单位符号为'￥',小数默认2位&#123;&#123; 12.45 | currency:'CHY￥':1&#125;&#125; //将12.45格式化为货币，使用自定义单位符号为'CHY￥',小数指定1位,会执行四舍五入操作&#123;&#123; 12.55 | currency:undefined:0&#125;&#125; //将12.55格式化为货币， 不改变单位符号， 小数部分将四舍五入 2、格式化日期：1234567&#123;&#123; 1304375948024 | date:'medium'&#125;&#125;//May 03, 2011 06:39:08 PM&#123;&#123; 1304375948024 | date &#125;&#125;//结果：May 3, 2011&#123;&#123; 1304375948024 | date:"MM/dd/yyyy @ h:mma" &#125;&#125;//结果：05/03/2011 @ 6:39AM&#123;&#123; 1304375948024 | date:"yyyy-MM-dd hh:mm:ss" &#125;&#125;//结果：2011-05-03 06:39:08 3、过滤数组：12345$scope.arr = [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ]&#123;&#123;arr | filter:'s'&#125;&#125; //查找含有有s的行//上例结果：[&#123;"age":12,"id":11,"name":"sunm xing"&#125;,&#123;"age":44,"id":12,"name":"test abc"&#125;]&#123;&#123;arr | filter:&#123;'name':'ip'&#125; &#125;&#125;//查找name like ip的行//上例结果:[&#123;"age":20,"id":10,"name":"iphone"&#125;] 4、将对象格式化成标准的JSON格式：1&#123;&#123; &#123;name:'Jack', age: 21&#125; | json&#125;&#125; 5、字符串，对象截取：12345&#123;&#123; "i love tank" | limitTo:6 &#125;&#125;//结果：i love&#123;&#123; "i love tank" | limitTo:-4 &#125;&#125;//结果：tank&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ] | limitTo:1 &#125;&#125;//结果：[&#123;"age":20,"id":10,"name":"iphone"&#125;] 6、大小写转换：12China has joined the &#123;&#123; "wto" | uppercase &#125;&#125;.We all need &#123;&#123; "MONEY" | lowercase &#125;&#125;. 7、数值类：12&#123;&#123; 1.234567 | number:1 &#125;&#125; //结果：1.2&#123;&#123; 1234567 | number &#125;&#125; //结果：1,234,567 8、对象排序：123$scope.arr = [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ]&#123;&#123;arr | orderBy:'id':true &#125;&#125;//根id降序排&#123;&#123;arr | orderBy:'id' &#125;&#125;//根据id升序排 自定义filter方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465我们来自定义选择省份和职位HTML代码：&#123;&#123;1 | provinceFilter&#125;&#125;&#123;&#123;6 | fMes:'positionList':'type'&#125;&#125;app.js:angular.module('myApp',[])//数组.controller('personCtrl',function($scope)&#123; $scope.arr=[ &#123;"age":20,"id":10,"name":"iphone"&#125;, &#123;"age":12,"id":11,"name":"sunm xing"&#125;, &#123;"age":44,"id":12,"name":"test abc"&#125; ] &#125;)//自定义选择省份.filter('provinceFilter',function(PROVINCE)&#123;//省 return function(id)&#123; if(id!=undefined&amp;&amp;id!='')&#123; var name; angular.forEach(PROVINCE,function(data)&#123; if(data.ProID==id)&#123; name=data.ProName; &#125; &#125;); return name; &#125; &#125;&#125;)//自定义选择职位.filter('fMes',function(con)&#123; return function(input,field,str)&#123; if(input&gt;=0) &#123;//input != undefined &amp;&amp; var name; var aMes=con[field]; angular.forEach(aMes,function(data)&#123; if(data[str]==input)&#123; name=data.name; &#125; &#125;); return name; &#125;else&#123;console.log('false');&#125; &#125;&#125;);constant.jsangular.module("myApp") .value('val',&#123;&#125;)//公司编辑常量组.constant('con',&#123;//职业分类positionList:[ &#123;type:0,name:'ui设计师'&#125;, &#123;type:1,name:'运维工程师'&#125;, &#123;type:2,name:'产品'&#125;, &#123;type:3,name:'Java工程师'&#125;, &#123;type:4,name:'IOS工程师'&#125;, &#123;type:5,name:'Android工程师'&#125;, &#123;type:6,name:'Web前端工程师'&#125;]&#125;) 显示的结果是：Web前端工程师，改变type值，显示相应的职位。 拓展思考AngularJS的内置过滤器有哪些？ 参考文献参考一：angularJS constant和value参考二：AngularJS的Filter用法详解 更多提问1、constant函数取值，和直接用常量名有什么区别 答：大多数情况直接用常量名，但是在angular中，使用constant的字段约定与后台进行数据交互的时候很方便，结构更加清晰。constant()函数和直接使用常量名输出的效果是一样的，但函数可以动态的输出不同的常量，在使用上要灵活、方便。 2、filter怎么去掉时间的秒12答：&#123;&#123;date | date : 'yyyy-MM-dd hh:mm:ss EEEE'&#125;&#125;参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们 3、什么情况下使用filter 答：常用的就是一个date的格式转换，表格中进行排序、还有大量的一些约定字段，使用自定义的filter。]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用NPM？CNPM又是什么？]]></title>
    <url>%2F2018%2F01%2F18%2FNPM%26CNPM%2F</url>
    <content type="text"><![CDATA[背景介绍什么是npm npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）, NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，它是 Node 获得成功的重要原因之一。常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 什么是cnpm? 因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” 知识剖析NPM常用指令 1、npm install moduleNames：安装Node模块 安装完毕后会产生一个node_modules目录，其目录下就是安装的各个node模块。 node的安装分为全局模式和本地模式。 一般情况下会以本地模式运行，包会被安装到和你的应用程序代码的本地node_modules目录下。 在全局模式下，Node包会被安装到Node的安装目录下的node_modules下 一些npm的简单命令就不多说了 为什么要保存至PACKAGE.JSON？ 因为node插件包非常大，版本庞杂，所以不加入package信息，模块间的依赖变得非常困难，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包）。 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 PACKAGE.JSON 属性说明： name - 包名。（不要把node或者js放在名字中） version - 包的版本号。 dependencies - 项目运行所依赖的模块 devDependencies - 项目开发所需要的模块 bin - 这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/ 使用npm卸载插件：npm uninstall &lt; name &gt; [-g] [–save-dev] PS：不要直接删除本地插件包 使用npm更新插件：npm update &lt; name &gt; [-g] [–save-dev] 更新全部插件：npm update [–save-dev] 查看npm帮助：npm help 查看当前目录已安装插件：npm list PS：npm安装插件过程：从http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法就是cnpm CNPM介绍： 官方网址：http://npm.taobao.org 安装：命令提示符执行npm install cnpm -g –registry=https://registry.npm.taobao.org 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 PS：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 常见问题bower 和 npm有什么区别 解决方案npm 是伴随 Node.js 出现的一个包管理器，最开始只能支持 Node.js 的模块管理，但是后来， npm 官网经过一次改版，打出的口号是，javascript 的包管理器，所以，其已经不在局限于是 Node.js 的模块管理了，已经通用到了所有 js 的包管理工具了，可以说，前后通吃了。 bower 的话，从一开始，就是专门为前端表现设计的包管理器，一切全部为前端考虑的。npm 和 bower 的最大区别，就是 npm 支持嵌套地依赖管理，而 bower只能支持扁平的依赖（嵌套的依赖，由 程序员自己解决）。 嵌套依赖，指的就是，你依赖的软件包，还有它自己的依赖，好像摘葡萄，一摘一大串。在服务器环境的时候，这并没什么关系，因为存储空间够大，一切代码都是本地运行，只要解决完依赖就行了， 但是到了用户产品的浏览器里，就很成问题了，你不能让用户去下载好几M的js代码，那就太糟糕了。在这个情况下，就需要程序员自己手动解决用到的类库的嵌套依赖问题。比如确保各种各样的插件 都依赖同一个版本的jQuery。 扩展思考cnpm有哪些问题？ 1.cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以你用 cnpm publish 命令会执行失败的 2.不仅是 publish 会执行失败，其它的需要注册用户(npm adduser)、或者修改 package 状态等命令都无法用 cnpm 参考文献 npm 模块安装机制简介 开发者对 npm 公司不满，unpublish 了自己的所有模块 npm的一些常用命令 bower 和 npm 的区别详细介绍 更多提问Q:全局安装和本地安装的区别？ A:因为全局模式安装,包可以供所有的程序使用。本地安装则不可以。 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如 果把包安装到全局,可以提高程序的重复利用程度,避免同样的内容的多 份副本,但坏处是难以处理不同的版本依赖。如果把包安装到当前目录, 或者说本地,则不会有不同程序依赖不同版本的包的冲突问题,同时还减 轻了包作者的 API 兼容性压力,但缺陷则是同一个包可能会被安装许多次。 Q:为什么进行了全局安装还要进行本地安装 A:为什么进行了全局安装还要进行本地安装 1、在js实例代码中，默认下node.js会在NODE_PATH和目前js所在项目下的node_modules文件夹下去寻找模块，因此，如果只是全局安装，不能直接通过require()的方式去引用模块，需要手动解决包路径的配置问题，当然你也可以复制全局安装的node_modules文件夹到项目下，还有办法可以选择将环境变量的NODE_PATH设置为C:\Program Files\nodejs。 2.对于包的更新不好管理，可能你需要为每个包重新命名，如gulp@3.8.1、gulp@3.9.1…，为了区别不同项目使用指定的包，保证模块之间的相互依赖，区别每个项目正常运行 Q：如何在package.JSON的dependencies和devDependencies写入信息 A:npm install –save babel-cli和npm install -dev babel-cli使用这两个命令安装后可自动写入文件 npm install –save-dev babel-cli也可以在一起用]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON是什么，如何处理转义？]]></title>
    <url>%2F2018%2F01%2F04%2FJSON%2F</url>
    <content type="text"><![CDATA[背景介绍JSON一种数据交换格式。在JSON出现之前， 大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是， 加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特发明了JSON这种超轻量级的数据交换格式。 由于JSON非常简单，很快就风靡Web世界。而在JavaScript中，我们可 以直接使用JSON，因为JavaScript内置了JSON的解析。把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON 格式的字符串，这样才能够通过网络传递给其他计算机。如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaS cript对象，就可以在JavaScript中直接使用这个对象了。 知识剖析JSON语法 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON值 数字(整数/浮点数) 字符串(双引号) 布尔值(true/false) 数组(中括号中) 对象(大括号中) null 实例 JSON 数据的书写格式是：名称/值对。 名称/值对组合中的名称写在前面（在双引号中），值对写在后面，中间用冒号隔开， 其中 值 可以是：数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true或false）、数组（在方括号中）、对象（在花括号中）、null 使用方式： varjson= {“name”:”myname”,”password”:123456} 或者是嵌套使用1234567891011121314151617181920212223 myObj = &#123; "name":"runoob", "alexa":10000, "sites": &#123; "site1":"www.runoob.com", "site2":"m.runoob.com", "site3":"c.runoob.com" &#125; &#125; console.log(myObj)//输出结果：Object &#123;name: "runoob", alexa: 10000, sites: Object&#125; 转义概述 为什么需要转义？在js中我们使用的js对象进行处理，但是在与后端数据交换的时候，我们发送规定的json格式的字符串，所以在给后端发送或接受数据的时候，需要 {name:”myname”,password:123456} &lt;–&gt; “{“name”:”myname”,”password”:123456}” 其中json字符串转js对象，调用parse方法： js对象 = JSON.parse(json字符串); js对象转json字符串，调用stringify方法： json字符串 = JSON.stringify(js对象); 常见问题除了以上两种方法还有什么可以转化 解决方案12345678910111213141516用eval_r('('+json字符串+')')这个方法可以实现json计算var value = 1;var js = '&#123;"data1":"hello","data2":value++&#125;';console.log(js);var data1 = eval("("+js+")");console.log(data1);var data2=JSON.stringify(js);console.log(data2);` eval_r获取的json对象的值中，如果有执行代码，也将照样执行！所以若不能保证数据的安全性，不要使用eval_r方法进行转义。 扩展思考我们常看到{name:”myname”,password:123456}和{“name”:”myname”,”password”:123456}这样两种格式，即js对象和json，然而js对象和json有什么不一样的地方？ 一个栗子大家可以自己在浏览器上运行一下12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt;var jso1=&#123;a:"name","b":"age"&#125;;var jso2=&#123;"a":"name","b":"age"&#125;;console.log(jso1.a === jso2.a);console.log(jso1.b === jso2.b);console.log(jso1 === jso2);console.log(jso1);console.log(jso2);var jso3=JSON.stringify(jso1);console.log(jso3);var jso4=JSON.parse(&#123;'a':"name","b":"age"&#125;);var jso4=JSON.parse('&#123;\"a\":\"name\", \"b\":\"age\"&#125;');console.log(jso4);&lt;/script&gt;` 参考文献参考一：百度百科 参考二：Json对象和Json字符串的区别 参考三：json属性名必须加引号的讨论 更多讨论Q：JSON对象有什么遍历方法，如何做 A：用jq方法$.each遍历json对象 Q：angularjs如何转换字符串和对象 A：angular.fromJson( ); angular.toJson(); Q：json和jisonp有什么区别 A：json返回的是一串数据；而jsonp返回的是脚本代码（包含一个函数调用）]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的原型链是什么？]]></title>
    <url>%2F2017%2F12%2F26%2FJS_%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[背景介绍JS中万物皆对象，但是分为两大类，函数对象，普通对象 所有的函数对象都有一个prototype属性，这个属性引用了一个对象，即原型对象，也称原型。 然而普通对象是没有prototype属性，只有proto属性 知识剖析vara = {};console.log(a.prototype);//undefined console.log(a.proto);//Object {} var b =function(){} console.log(b.prototype);//b {} console.log(b.proto);//function() {} /1、字面量方式/ var a = {}; console.log(a.proto); //Object {} console.log(a.proto === a.constructor.prototype); //true /2、构造器方式/ var A = function(){}; var a = new A(); console.log(a.proto); //A {} console.log(a.proto === a.constructor.prototype); //true /3、Object.create()方式/ var a1 = {a:1} var a2 = Object.create(a1); console.log(a2.proto); //Object {a: 1} console.log(a.proto === a.constructor.prototype); //false constructor 属性返回对创建此对象的数组函数的引用 proto的指向取决于对象创建时的实现方式 大多数情况下，proto可以理解为构造器的原型，即：proto === constructor.prototype 但是通过Object.create()创建的对象不使用此等式 functionFoo1(){this.name1 =’1’;} functionFoo2(){this.name2 =’2’;} Foo2.prototype =newFoo1(); functionFoo3(){this.name =’3’;} Foo3.prototype =newFoo2(); varfoo3 =newFoo3(); console.log(foo3); 当我们「读取」 foo3的某个属性得时候，jS 引擎会做下面的事情： 看看 foo3 对象本身有没有这个属性。没有就走到下一步。 看看 foo3.proto 对象有没有这个属性，发现 foo3.proto 有这个属性，于是找到了 如果 foo3.proto 没有，那么浏览器会继续查看 foo3.proto.proto 如果 foo3.proto.proto 也没有，那么浏览器会继续查看 foo3.proto.proto.proto__ 直到找到 或者 proto 为 null。 常见问题若想访问一个对象的原型，应该使用什么方法？ 解决办法1、使用proto属性 每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法。 对象proto属性的值就是它所对应的原型对象； 使用proto是有争议的，而且是不鼓励的。 它从来没有被包括在EcmaScript语言规范中，但是现代浏览器实现了它, 无论如何。proto属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 建议使用Object.getPrototyOf() 参考文章：参考一： JS重点整理之JS原型链彻底搞清楚 参考二： 三张图搞懂JavaScript的原型对象与原型链 问题Q：prototype和proto区别 A：所有的函数对象都有一个prototype属性，这个属性引用了一个对象，即原型对象，也称原型。 然而普通对象是没有prototype属性，只有proto属性 Q：constructor 代表什么 A：constructor 属性返回对创建此对象的数组函数的引用 Q:proto的指向哪里 A:proto的指向取决于对象创建时的实现方式]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs双向绑定后，发生了什么事情？view层和controller层是如何进行绑定的？]]></title>
    <url>%2F2017%2F12%2F19%2Fangular_%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[背景介绍双向绑定，是从界面的操作能实时反映到数据，数据的变更也能 实时展现到界面 如何绑定如果我们自己实现双向数据绑定该怎么写？ 如何实现angular是一个MVVM（Model-View，View-Model）模式的框架。 MVC:View传送指令到Controller；Controller完成业务逻辑后，要求Model改变状态； Model将新的数据发送到View；所有通信都是单向的 MVVM它采用双向绑定：View的变动，自动反映在ViewModel，反之亦然。 View是angularjs编译html后呈现出来的，需要编译的是controller中的定义的属性和方法以及directive中定义的指令。 View和controller是独立开来的，他们之间的纽带就是scope。Controller负责向scope中提供属性和方法， 便于和view层面的html进行交互。 Angular双向绑定通过$watch,$digest，$apply实现的。 watch序列 watch监控model中是否有变化，会记录last值，也就是改变后的值，每一个model都会增加一个watch到watch队列中。 digest循环 当浏览器接收到可以被angular context处理的事件时，$digest循环就会触发，这个循环有两个子循环， 一个处理evalAsync队列，另一个处理watch队列，$digest会遍历$watch 既然所有的$watch都检查完了，那就要问了：有没有$watch更新过？如果有至少一个更新过，这个循环就会再次触发， 直到所有的$watch都没有变化。这样就能够保证每个model都已经不会再变化。记住如果循环超过10次的话， 它将会抛出一个异常，防止无限循环。 当$digest循环结束时，DOM相应地变化。 每一个进入angular context的事件都会执行一个$digest循环，也就是说每次我们输入一个字母循环都会检查整个页面的所有$watch。 常见问题$digest和$apply有何区别？干嘛不直接使用$digest? 解决方法这里值虽然改变了，但是没有强制执行$degest,watch根本没有执行 一般带ng的事件angular都会给你自动添加好了apply，但是你要操纵事件的时候加上apply才能实现数据输出到view层中。 为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行， 而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了 当你传入一个function到$apply()中的时候，这个function会被包装到一个try…catch块中，所以一旦有异常发生， 该异常会被$exceptionHandler service处理。 1.$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。 2.当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。 更多讨论Q、angular是什么框架 A、angular是一个MVVM（Model-View，View-Model）模式的框架 Q、为什么在ng-click里面调用$digest的话，会报错呢 A、因为Angular的设计，同一时间只允许一个$digest运行， 而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了 Q、$digest和$apply有何区别 A、1.$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。 2.当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。 7.参考文献 http://www.cnblogs.com/bigdataZJ/p/AngularjsInAction2.html view和controller的那些事儿 https://github.com/xufei/blog/issues/10 Angular沉思录（一）数据绑定 http://www.angularjs.cn/A0a6理解$watch，$apply和$digest —理解数据绑定过程]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx的反向代理跨域]]></title>
    <url>%2F2017%2F12%2F01%2FNginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是跨域？跨域是指a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，或是a页面为ip地址， b页面为域名地址，所进行的访问行动都是跨域 产生的原因？浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源 同ip（或domain）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写 本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略 现代浏览器在安全性和可用性之间选择了一个平衡点。 在遵循同源策略的基础上，选择性地为同源策略“开放了后门”。例如img script style等标签，都允许垮域引用资源,然而， 你也只能是引用这些资源而已，并不能读取这些资源的内容 同源策略限制以下几种行为：1.Cookie、LocalStorage 和 IndexDB 无法读取 2.DOM 和 Js对象无法获得 3.AJAX 请求不能发送 常见跨域场景http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 nginx反向代理解决跨域正向代理：代理位于网站和客户端中间， 客户端无法访问某网站，就将请求发送给代理服务器，代理从网站取回来再发送给客户端，网站并不知道为谁提供服务 反向代理：客户端访问某网站的一个页面， 但是网站并没有，就偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，用户不知道真正提供服务的是谁 对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过 检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确 处理请求，并且并不知道这个请求是来自代理服务器的。 简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实 的服务器，让它以为这个http请求是直接来自与用户浏览器的。 12345Location/carrots-admin-ajax/&#123; proxy_passhttp://dev.admin.carrots.ptteng.com/;&#125; proxy_pass把请求代理到其他主机两种写法hhttp://dev.admin.carrots.ptteng.com/ 和 http://dev.admin.carrots.ptteng.com 如果访问url=http://server/html/test.jsp，则被nginx代理后 情况1: 将test/作为根路径，请求test/路径下的资源。 情况2: 则被nginx代理后，请求路径会变为http://proxy_pass/test.jsp，直接访问server的根资源。 /carrots-admin-ajax/是一个匹配规则，用于拦截请求，匹配任何以/proxy/html/开头的地址，匹配符合以后，停止往下搜索正则。 对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 简单说，nginx服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写url，欺骗了真实的服务器，让它以为这个http请求是直接来自与用户浏览器的。 nginx rewrite指令执行顺序：1.执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域，其它xx块类似) 2.执行location匹配 3.执行选定的location中的rewrite指令 如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件 如果循环超过10次，则返回500 Internal Server Error错误 参考文章参考一：https://www.cnblogs.com/gabrielchen/p/5066120.html 参考二：http://blog.csdn.net/shendl/article/details/48443299 其他问题Q：例如img script style等标签，都允许垮域引用资源？ A：在浏览器中，并且加载的方式其实相当于一次普通的GET请求，唯一不同的是，为了安全起见，浏览器不允许这种方式下对加载到的资源的读写操作，而只能使用标签本身应当具备的能力（比如脚本执行、样式应用等等）。 Q：JSONP和nginx跨域有什么不同 JSONP和nginx是完全不同的 是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数 原理：是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数 script标签是可以加载异域的JavaScript并执行的，通过预先设定好的callback函数来实现和母页面的交互。它有一个大名，叫做JSONP跨域，JSONP是JSON with Padding的略称。它是一个非官方的协议，明明是加载script，为啥和JSON扯上关系呢？原来就是这个callback函数，对它的使用有一个典型的方式，就是通过JSON来传参，即将JSON数据填充进回调函数，这就是JSONP的JSON+Padding的含义。JSONP只支持GET请求。 欢迎留言交流 (´▽`ʃ♡ƪ)]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>

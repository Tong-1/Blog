<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="welcome"><meta name="descriptioon" content="没事儿,tong-h,Tong-H"><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="http://at.alicdn.com/t/font_1200423_cpvgoq4ya9s.css"><title>canvas性能优化篇 [ 没事儿 ]</title><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/post.css"></head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header"><div class="maxwidth"><div class="nav"><a id="artlist" href="/archives"><i class="iconfont iconArchives"></i><span class="headhid">&nbsp;Archives</span></a><a id="artlist" href="/about"><i class="iconfont iconAbout"></i><span class="headhid">&nbsp;About</span></a><a id="artlist" href="/404"><i class="iconfont iconCommonweal"></i><span class="headhid">&nbsp;Commonweal</span></a></div><div class="search">It's more tiring to stop</div></div></div><div class="line"></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div id="sidebar"><div class="info"><img src="/images/user.png" alt="头像"><div><p>没事儿</p></div></div><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="/atom.xml" title="RSS 源订阅"><i class="iconfont iconsubscribe-1-copy"></i></a><a href="mailto:tongt0232@gmail.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a href="https://github.com/tong-h" title="GitHub"><i class="iconfont iconGitHub"></i></a><a href="https://www.jianshu.com/u/20de04cc53de" title="简书"><img src="/images/jianicon-sidebar.png"></a></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rests/">rests</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">6</span></li></ul><div class="tags"><a href="/tags/ECharts/" style="font-size: 14px; color: #ffac00">ECharts</a> <a href="/tags/Electron/" style="font-size: 14px; color: #ffac00">Electron</a> <a href="/tags/JSON/" style="font-size: 14px; color: #ffac00">JSON</a> <a href="/tags/angular/" style="font-size: 22px; color: #da8d00">angular</a> <a href="/tags/canvas/" style="font-size: 22px; color: #da8d00">canvas</a> <a href="/tags/cordova/" style="font-size: 30px; color: #b46e00">cordova</a> <a href="/tags/ffmpeg/" style="font-size: 14px; color: #ffac00">ffmpeg</a> <a href="/tags/git/" style="font-size: 14px; color: #ffac00">git</a> <a href="/tags/hexo/" style="font-size: 14px; color: #ffac00">hexo</a> <a href="/tags/http/" style="font-size: 14px; color: #ffac00">http</a> <a href="/tags/markdown/" style="font-size: 14px; color: #ffac00">markdown</a> <a href="/tags/mpvue/" style="font-size: 14px; color: #ffac00">mpvue</a> <a href="/tags/mysql/" style="font-size: 14px; color: #ffac00">mysql</a> <a href="/tags/nginx/" style="font-size: 14px; color: #ffac00">nginx</a> <a href="/tags/nodejs/" style="font-size: 14px; color: #ffac00">nodejs</a> <a href="/tags/npm/" style="font-size: 14px; color: #ffac00">npm</a> <a href="/tags/python/" style="font-size: 14px; color: #ffac00">python</a> <a href="/tags/rests/" style="font-size: 14px; color: #ffac00">rests</a> <a href="/tags/search/" style="font-size: 14px; color: #ffac00">search</a> <a href="/tags/vue/" style="font-size: 14px; color: #ffac00">vue</a> <a href="/tags/原型链/" style="font-size: 14px; color: #ffac00">原型链</a> <a href="/tags/服务器/" style="font-size: 14px; color: #ffac00">服务器</a> <a href="/tags/死磕英语/" style="font-size: 14px; color: #ffac00">死磕英语</a> <a href="/tags/网络爬虫/" style="font-size: 22px; color: #da8d00">网络爬虫</a> <a href="/tags/跨域/" style="font-size: 14px; color: #ffac00">跨域</a></div></div><div class="post rightside"><div class="title">canvas性能优化篇</div><div class="info"><i class="iconfont iconshijian1">2019-03-18 11:40</i><i class="iconfont iconshijian1">2019-03-18 16:48</i><i class="iconfont iconshijian1">[object Object]</i><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span><i class="iconfont iconwenzi">8841</i></div><div class="postDetail"><p>看了很多大佬的文章，自己也对项目做了一些优化，其实有很多地方平常码代码的时候稍微注意一下就能节约很多性能开销</p>
<h1 id="1-离屏渲染"><a href="#1-离屏渲染" class="headerlink" title="1.离屏渲染"></a>1.离屏渲染</h1><p>在离屏canvas上预渲染相似的图形或重复的对象，通俗的解释是将离屏canvas当成预渲染，在离屏canvas上绘制好一整块图形，绘制好后在放到视图canvas中，适合每一帧画图运算复杂的图形</p>
<p>比如你想把一张图片放到canvas上，使用drawImage()方法，有三种写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将image放到目标canvas指定位置</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy); </span><br><span class="line"><span class="comment">// 将image放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 将image裁剪之后放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure></p>
<p>第一种只是把图片原样放到canvas里，第二章指定宽高就意味着放大或者缩小图片后再放进去，带三种是裁剪后再放大或者缩小放到canvas中，这三种写法操作依次增加，性能开销也是依次提高<br>而离屏渲染就可以让我们先把图片裁剪成想要的尺寸内容保存起来，绘制的时候就可以使用第一种写法简单的把图片放进去就完了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在离屏 canvas 上绘制</span></span><br><span class="line"><span class="keyword">var</span> offscreencanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="comment">// 宽高赋值为想要的图片尺寸</span></span><br><span class="line">offscreencanvas.width = dWidth;</span><br><span class="line">offscreencanvas.height = dHeight;</span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">offscreencanvas.getContext(<span class="string">'2d'</span>).drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 在视图canvas中绘制</span></span><br><span class="line">viewcontext.drawImage(canvas, x, y);</span><br></pre></td></tr></table></figure>
<h1 id="2-分层画布"><a href="#2-分层画布" class="headerlink" title="2.分层画布"></a>2.分层画布</h1><p>多个相互重叠的canvas根据变化程度分开渲染，越复杂的场景越适合</p>
<p>比如一个简单的游戏场景，游戏背景始终不变或者变化次数较少但是人物游戏的主体是一直在根据玩家的指挥不停的改变，</p>
<p>场景：最近写的一个画板，比如这样一个简单的画圆，可以看到有原来的绘画的痕迹，那就要 渲染没画圆之前的画布 -&gt; 再画圆，鼠标移动的时候不断的执行这个渲染过程</p>
<p><img src="/2019/03/18/canvas-3/canvas-3.gif" alt="示例画圆gif"></p>
<p>这个时候就可以使用分层画布，画画在一个上层canvas上，原来绘画痕迹在下层canvas上，那么画圆的过程就是清空 -&gt; 画圆，画好之后再放到下层canvas上，这样就不需要去渲染之前的画布，就能节约性能开销</p>
<h1 id="3-一次性绘制"><a href="#3-一次性绘制" class="headerlink" title="3.一次性绘制"></a>3.一次性绘制</h1><p>绘制操作的性能开销较高，可以创建一个包含所有线条的路径，然后通过单个绘制路径调用进行绘制</p>
<p>从这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变成这样，在绘制复杂路径时，最好将所有点都放入路径中，而不是分别呈现各个片段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">&#125;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p>
<h1 id="4-使用requestAnimationFrame执行动画"><a href="#4-使用requestAnimationFrame执行动画" class="headerlink" title="4.使用requestAnimationFrame执行动画"></a>4.使用requestAnimationFrame执行动画</h1><p>canvas动画的本质是不断地擦除和重绘，再结合一些时间控制的方法达到动画的目的<br>显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms<br>而requestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命</p>
<p>详细看<a href="https://tong-h.github.io/2019/03/07/canvas-2/#more" target="_blank" rel="noopener">这儿</a></p>
<h1 id="5-清空画布"><a href="#5-清空画布" class="headerlink" title="5.清空画布"></a>5.清空画布</h1><p>三种方法性能，性能依次提高<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect()</span><br><span class="line">context.clearRect()</span><br><span class="line">canvas.width = canvas.width; <span class="comment">// 一种画布专用的技巧</span></span><br></pre></td></tr></table></figure></p>
<h1 id="6-减少调用canvas的api"><a href="#6-减少调用canvas的api" class="headerlink" title="6.减少调用canvas的api"></a>6.减少调用canvas的api</h1><p>比如像背景可以使用css属性设置或者img标签加一些定位什么的</p>
<p>画布的缩放可以使用CSS transforms，不要将小画布放大，而是去将大画布缩小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scaleX = canvas.width / <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> scaleY = canvas.height / <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scaleToFit = <span class="built_in">Math</span>.min(scaleX, scaleY);</span><br><span class="line"><span class="keyword">var</span> scaleToCover = <span class="built_in">Math</span>.max(scaleX, scaleY);</span><br><span class="line"></span><br><span class="line">stage.style.transformOrigin = <span class="string">'0 0'</span>; <span class="comment">//scale from top left</span></span><br><span class="line">stage.style.transform = <span class="string">'scale('</span> + scaleToFit + <span class="string">')'</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h1><ul>
<li>尽可能使用计算代替canvas渲染，通常情况下，渲染比计算的开销大很多（3~4 个量级）</li>
<li>减少改变 context 的状态以及不要赋一些乱七八糟类型的值，比如人家要一个number你要给一个string，浏览器会用一些额外时间来处理这些非法输入，可能会造成三四倍的时间开销</li>
<li>避免使用浮点数坐标，使用非整数的坐标绘制内容，系统会自动使用抗锯齿功能，尝试对线条进行平滑处理，这又是一种性能消耗。可以调用 Math.round 四舍五入取整</li>
<li>减少使用 shadowBlur 效果，和很多图像环境渲染一样，阴影渲染的性能开销通常比较高</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a><br><a href="https://www.html5rocks.com/zh/tutorials/canvas/performance/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/canvas/performance/</a><br><a href="http://taobaofed.org/blog/2016/02/22/canvas-performance/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/02/22/canvas-performance/</a></p>
</div></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?a4d08c5088ca0d4b18c14260c9ca89a1";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})()</script></body></html>
<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="没事儿,tong-h,Tong-H,tong-h blog"><meta name="descriptioon" content="personal blog by tong/没事儿"><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/iconfont.css"><title>博客 [ 没事儿 ]</title><link rel="stylesheet" href="/css/partial/footer.css"><link rel="stylesheet" href="/css/partial/posts.css"><link rel="stylesheet" href="/css/partial/posts.css"><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/archive.css"><link rel="stylesheet" href="/css/index.css"></head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header"><div class="maxwidth"><div class="nav"><a id="artlist" href="/404"><i class="iconfont icon404"></i><span class="headhid">&nbsp;404</span></a><a class="focuspage" id="artlist" href="/archives"><i class="iconfont iconarchives"></i><span class="headhid">&nbsp;博 客</span></a><a id="artlist" href="/about"><i class="iconfont iconabout"></i><span class="headhid">&nbsp;关 于</span></a><a id="artlist" href="/link"><i class="iconfont iconlink"></i><span class="headhid">&nbsp;友 链</span></a></div><div class="search">It's more tiring to stop</div></div></div><div class="headerline"></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div id="sidebar"><div class="info"><a href="/"><img src="/images/user.png" alt="头像"></a><div><p>没事儿</p></div></div><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="/atom.xml" title="RSS 源订阅"><i class="iconfont iconsubscribe-1-copy"></i></a><a href="mailto:tongt0232@gmail.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a href="https://github.com/tong-h" title="GitHub"><i class="iconfont iconGitHub"></i></a><a href="https://www.jianshu.com/u/20de04cc53de" title="简书"><img src="/images/jianicon-sidebar.png"></a></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MYSQL/">MYSQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PYTHON/">PYTHON</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RESTS/">RESTS</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SERVER/">SERVER</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a><span class="category-list-count">23</span></li></ul><div class="tags"><a href="/tags/ECharts/" style="font-size: 14px; color: #ffac00">ECharts</a> <a href="/tags/Electron/" style="font-size: 14px; color: #ffac00">Electron</a> <a href="/tags/JSON/" style="font-size: 14px; color: #ffac00">JSON</a> <a href="/tags/angular/" style="font-size: 18px; color: #ec9d00">angular</a> <a href="/tags/canvas/" style="font-size: 26px; color: #c77e00">canvas</a> <a href="/tags/cordova/" style="font-size: 30px; color: #b46e00">cordova</a> <a href="/tags/domain/" style="font-size: 14px; color: #ffac00">domain</a> <a href="/tags/ffmpeg/" style="font-size: 14px; color: #ffac00">ffmpeg</a> <a href="/tags/git/" style="font-size: 14px; color: #ffac00">git</a> <a href="/tags/gitment/" style="font-size: 14px; color: #ffac00">gitment</a> <a href="/tags/hexo/" style="font-size: 22px; color: #da8d00">hexo</a> <a href="/tags/http/" style="font-size: 14px; color: #ffac00">http</a> <a href="/tags/markdown/" style="font-size: 14px; color: #ffac00">markdown</a> <a href="/tags/mpvue/" style="font-size: 14px; color: #ffac00">mpvue</a> <a href="/tags/mysql/" style="font-size: 14px; color: #ffac00">mysql</a> <a href="/tags/nginx/" style="font-size: 14px; color: #ffac00">nginx</a> <a href="/tags/nodejs/" style="font-size: 14px; color: #ffac00">nodejs</a> <a href="/tags/npm/" style="font-size: 14px; color: #ffac00">npm</a> <a href="/tags/python/" style="font-size: 14px; color: #ffac00">python</a> <a href="/tags/rests/" style="font-size: 14px; color: #ffac00">rests</a> <a href="/tags/search/" style="font-size: 14px; color: #ffac00">search</a> <a href="/tags/server/" style="font-size: 14px; color: #ffac00">server</a> <a href="/tags/vue/" style="font-size: 14px; color: #ffac00">vue</a> <a href="/tags/yarn/" style="font-size: 14px; color: #ffac00">yarn</a> <a href="/tags/原型链/" style="font-size: 14px; color: #ffac00">原型链</a> <a href="/tags/死磕英语/" style="font-size: 14px; color: #ffac00">死磕英语</a> <a href="/tags/缓存/" style="font-size: 14px; color: #ffac00">缓存</a> <a href="/tags/网络爬虫/" style="font-size: 18px; color: #ec9d00">网络爬虫</a> <a href="/tags/跨域/" style="font-size: 14px; color: #ffac00">跨域</a></div></div><div class="archive rightside"><div id="list_archives" style="opacity: 0;display:  none"><div class="switch" id="arshow"><i class="iconfont iconArchives"></i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">3</span></li></ul></div><div id="normalposts"><div class="switch" id="poshow"><i class="iconfont iconshijian"></i></div><article><a class="artititle" href="/2019/08/06/gitment/">gitment 评论系统博客接入</a><div class="content ellipse"><p></p><h2 id="配-置"><a href="#配-置" class="headerlink" title="配 置"></a>配 置</h2><p>1.去<a href="https://github.com/settings/developers" target="_blank" rel="noopener">新建 OAuth App</a> 完成注册<br>2.在主题配置文件 _config.yaml 中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  id: &apos;&apos;</span><br><span class="line">  owner: Tong-H # 你的 github 用户名，可以不用太在意大小写</span><br><span class="line">  repo: Tong-H.github.io #存储评论的 repo</span><br><span class="line">  client_id: 5658f62c9837c979f96f #新建 OAuth App 时的 Client ID</span><br><span class="line">  client_secret: 36813d127f4f0918cd30231a403e09d81015e014 #新建 OAuth App 时的 Client secret</span><br></pre></td></tr></table></figure>
<p>3.新建一个 comment 组件，看了一些博客，大部分都是用的 ejs，我用的是 Pug，这个区别不大<br><em>注意，网上有很多文章这段代码都是不可用的，会出现初始化不了的情况，这里贴出的是可用的
</em>引入两个文件，一个 css 和 一个 js<br><em>使用 dataset 将 hexo 的变量传递给页面
</em>新建 gitment 对象的时候要注意使用 setTimeout 轮询查看 gitment 是否存在文件加载是否完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">block prepend cssFile</span><br><span class="line">    link(rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>)</span><br><span class="line"></span><br><span class="line">#comment</span><br><span class="line">    <span class="comment">// 使用 data</span></span><br><span class="line">    #gitment_container(data-gitment=JSON.stringify(theme.gitment) data-title=page.title)</span><br><span class="line">    script(src=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>)</span><br><span class="line">    script.</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">commentinit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (Gitment) &#123;</span><br><span class="line">                    <span class="keyword">let</span> string = <span class="built_in">JSON</span>.parse(<span class="built_in">document</span>.getElementById(<span class="string">'gitment_container'</span>).dataset.gitment)</span><br><span class="line">                    <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">                        id: <span class="built_in">document</span>.getElementById(<span class="string">'gitment_container'</span>).dataset.title,</span><br><span class="line">                        owner: string.owner,</span><br><span class="line">                        repo: string.repo,</span><br><span class="line">                        oauth: &#123;</span><br><span class="line">                            client_id: string.client_id,</span><br><span class="line">                            client_secret: string.client_secret,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;)</span><br><span class="line">                    gitment.render(<span class="string">'gitment_container'</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> commentinit()</span><br><span class="line">            &#125;,<span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        commentinit()</span><br></pre></td></tr></table></figure>
<h2 id="Comments-Not-Initialized"><a href="#Comments-Not-Initialized" class="headerlink" title="Comments Not Initialized"></a>Comments Not Initialized</h2><p>需要你先登录下初始化，不要在本地 localhost 登录，因为localhost：4000 和你注册时填写的 Authorization Callback URL 的域名不同，点击登录会跳转到 你的 Authorization Callback URL 页面</p>
<p>当然你也可以再去新建一个 OAuth Application 填 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 也可以</p>
<p>每新建一个文章都需要去初始化，相当于重新开一个 issue</p>
<h2 id="初始化时在评论框点击登录，但是没有跳到授权页面"><a href="#初始化时在评论框点击登录，但是没有跳到授权页面" class="headerlink" title="初始化时在评论框点击登录，但是没有跳到授权页面"></a>初始化时在评论框点击登录，但是没有跳到授权页面</h2><p>查看页面 login 按钮的 a 标签的 href 是这样的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"gitment-editor-login-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?scope=public_repo&amp;amp;redirect_uri=https%3A%2F%2Ftong-h.github.io%2F2019%2F08%2F05%2Fhexo_theme%2F&amp;amp;client_id=5658f62c9837c979f96f&amp;amp;client_secret=36813d127f4f0918cd30231a403e09d81015e014"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 redirect_uri 是当前页面的 url，url 的域名和你注册时填写的 Authorization Callback URL 的域名一定要一致，我检查才发现我填的时 <a href="http://tong-h.github.io" target="_blank" rel="noopener">http://tong-h.github.io</a>, 但实际请求的却是https</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>添加Gitment评论系统踩过的坑 <a href="http://xichen.pub/2018/01/31/2018-01-31-gitment/" target="_blank" rel="noopener">http://xichen.pub/2018/01/31/2018-01-31-gitment/</a><br>Hexo博客框架下Gitment取代多说评论 <a href="https://zonghongyan.github.io/2017/06/29/201706292034/" target="_blank" rel="noopener">https://zonghongyan.github.io/2017/06/29/201706292034/</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">2</i><i class="iconfont iconwenzi" title="字数">593</i><i class="iconfont iconshijian" title="创建时间">2019-08-06 12:50</i></div></article><article><a class="artititle" href="/2019/08/05/hexo_theme/">hexo 主题制作</a><div class="content ellipse"><p></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>hexo 是一个免费简单的博客框架，有很多好看开源主题，但是当你看到别人的博客和你自己的博客一模一样的时候，还是有点奇怪，熟悉又陌生的感觉</p>
<p>Hexo 内建 Swig 模板引擎，但是可以另外安装插件来获得 <a href="https://github.com/hexojs/hexo-renderer-ejs" target="_blank" rel="noopener">EJS</a>、<a href="https://github.com/hexojs/hexo-renderer-haml" target="_blank" rel="noopener">Haml</a> 或 <a href="https://github.com/hexojs/hexo-renderer-jade" target="_blank" rel="noopener">Jade</a> 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：layout.ejs，layout.swig</p>
<p>我有尝试过用 Swig，毕竟不需要安装插件，但是用过之后还是果断换回了 Pug(原 jade )，如果你两种模板引擎都没接触过那推荐你用 Swig，上手简单会快些，但如果你也是 Pug 的忠实粉丝，那么还是安装插件吧</p>
<p>你需要安装 2 个插件，渲染 jade 页面的插件和热更新的插件，并保存在 packagejson devDependencies 是开发时需要的插件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server hexo-browsersync hexo-renderer-jade --save-dev</span><br></pre></td></tr></table></figure>
<h2 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h2><p>在…\blog\themes 新建一个文件夹，文件夹名称是你主题的名字，一个主题可能是这样的结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── languages       语言文件，用于国际化</span><br><span class="line">├── layout          页面模板文件</span><br><span class="line">├────── index       首页，url 根目录默认加载首页</span><br><span class="line">├────── Archive     归档页</span><br><span class="line">├────── Tag         标签页</span><br><span class="line">├────── Category    分类页</span><br><span class="line">├────── Post        文章页</span><br><span class="line">├────── Page        页面详情，像<span class="number">404</span>、友链这种自定义页面都是在 page 页面</span><br><span class="line">├── scripts    脚本文件夹，在启动时，Hexo 会载入此文件夹内的 JavaScript 文件</span><br><span class="line">├── source     主题资源文件，包括页面样式，脚本，字体等</span><br><span class="line">├────── css</span><br><span class="line">├────── js</span><br><span class="line">├────── img</span><br></pre></td></tr></table></figure>
<p>如果你的网站在二级目录可以在网站配置文件_config.yml 更改 url</p>
<p>每个主题都可以有一个 layout 的页面布局文件，因为像 footer、header 等都是可以做复用的，所以我们可以最大化的利用 pug 或者 swig 等模板引擎的局部模板功能<br>比如 pug，更多详细内容可以查看<a href="https://pug.bootcss.com/language/inheritance.html" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extends // 被继承的模板路径</span><br><span class="line">block   // 定义一个代码块，可以被子模块填充、修改、覆盖</span><br><span class="line">prepend // 向块的头部添加内容</span><br><span class="line">append  // 向块的尾部添加内容</span><br></pre></td></tr></table></figure>
<h2 id="Yeoman-生成基本框架"><a href="#Yeoman-生成基本框架" class="headerlink" title="Yeoman 生成基本框架"></a>Yeoman 生成基本框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install yo -g // 全局安装 Yeoman</span><br><span class="line">npm install generator-hexo-theme -g // 主题生成工具</span><br><span class="line">yo hexo-theme // 生成主题</span><br></pre></td></tr></table></figure>
<h2 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h2><p>hexo 提供了很多<a href="https://hexo.io/zh-cn/docs/helpers" target="_blank" rel="noopener">辅助函数</a>和<a href="https://hexo.io/zh-cn/docs/variables" target="_blank" rel="noopener">变量</a><br>在开发过程中 hexo 是服务端渲染，所以他的所有变量是 node 的全局变量，非页面的</p>
<h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><p>WordCount 字数统计</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yarn add hexo-wordcount</span><br><span class="line"># or</span><br><span class="line">npm i --save hexo-wordcount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字数统计</span></span><br><span class="line">wordcount(post.content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阅读时长预计</span></span><br><span class="line">min2read(post.content)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置阅读速度</span></span><br><span class="line">min2read(post.content, &#123;<span class="attr">cn</span>: <span class="number">300</span>, <span class="attr">en</span>: <span class="number">160</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总字数统计</span></span><br><span class="line">totalcount(site)</span><br></pre></td></tr></table></figure>
<p>卜蒜子 阅读量统计</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>*hexo 主题制作官方文档： <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/permalinks</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">2</i><i class="iconfont iconwenzi" title="字数">764</i><i class="iconfont iconshijian" title="创建时间">2019-08-05 17:42</i></div></article><article><a class="artititle" href="/2019/08/05/about_blog/">博客折腾总结</a><div class="content ellipse"><p></p><p>&emsp;&emsp;之前看到有人说，写 Blog 的人都是这样的，从刚接触 Blog 感觉很新鲜，用的都是免费的开箱即用先搭起来再说，然后发现免费的限制总是很多，开始不安分想法开始变得有点多，开始自己购买域名和空间，搭建独立博客想怎么折腾怎么折腾，后来又觉得独立博客的管理太麻烦，只是想要个能写能看能发布的简单的，再有那么一点点的自定义，周周转转还是回来了</p>
<p>&emsp;&emsp;前段时间自己买了域名、服务器、搭建环境，用 koa 写接口 + mysql 管理 + pug（原 jade ） 写页面做服务器渲染，接触了很多没接触过的东西</p>
<p>&emsp;&emsp;但是看看这个博客其实还是用 hexo 生成，之前是用的 next 主题，很好看符合大多数人的审美，但是用的人太多了，其实再看到有一个一样的博客的时候就想换了，所以这次还是自己写了个主题，一直在犹豫要不要发布到 hexo 的主题列表，又想独一无二又想骗几个 star，还是发了万一有人喜欢呢，虽然样式方面还是被周围同志吐槽了一下，但是我自己觉得挺好看的啊，就这样，但是评论截至现在还没搞好</p>
<p>&emsp;&emsp;关于 koa，以前用过 express，其实已经不大记得了，所以这次用了 koa，官网很简单很短但是全英文所以我看得还是很慢，也看了阮一峰的koa的教程，上手要比当时用 express 快些，翻了翻以前的代码再看看现在 koa 的代码，感觉差别不大，自己使用场景还是太少了</p>
<p>&emsp;&emsp;以前写的项目都是前端写页面，后端给接口，前后端分离，做服务器渲染还是第一次，也是第一次接触 pug、ejs 这样的模板引擎，用之前也在 ejs 和 pug 之间犹豫，用ejs的人比较多，ejs 的结构更像 html 上手也更简单，pug 上手比起ejs稍微难些但是回了就很爽，我是想着学会了难的是那么简单的需要的时候再学也不会花费很多时间，所以最后用了 pug，使用感一个字 “棒”，用起来实在是太舒服了，pug 之于 html 就像 scss 之于 css 一样，jq 之于 js 一样，大大的减少了代码量，代码简单干净规范，后面写 hexo 主题的时候因为 hexo 本身不支持 pug 需要安装一些插件才行所以用了 Swig，Swig 确实更简单些，文档就那么几段话上手很快，但是写了个开头果断还是换成了 pug，后来在项目里 vue 的模板引擎也换成了 pug</p>
<p>&emsp;&emsp;关于服务器，之前也买过但是只是一个空间，这次买了 linux 服务器，以前没用过 linux 从搭建到部署，一把血泪史，各种命令实在太多了，后面一定要把我的小笔记里关于 linux 的整理一下给以后用的时候看</p>
<p>&emsp;&emsp;关于 mysql，一直接触的都不多，只会一些简单的增删查改，这次接触了一些更难的吧，比如群组、多条件查询，还是要感谢旁边的后端同学</p>
<p>&emsp;&emsp;关于正则，之前用正则机会一直不多，都是断断续续的，时不时有那么一个场景会用到就在你快要忘了的时候，所以我的小笔记关于正则记得很详细，公司大佬对正则很熟练，成功的让我看到了正则的魅力还有强大的地方，而这次写 blog 因为需要在本地筛选文件、过滤文章内容提取文章信息，所以其实用了蛮多正则的，正则确实是很强大的工具</p>
<p>&emsp;&emsp;总的来说，涨了知识，也不算白折腾，但是服务器也买了、域名也买了，还是想要再弄点什么</p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">3</i><i class="iconfont iconwenzi" title="字数">1.1k</i><i class="iconfont iconshijian" title="创建时间">2019-08-05 17:13</i></div></article><article><a class="artititle" href="/2019/08/05/domain/">域名解析</a><div class="content ellipse"><p></p><h2 id="二级域名设置"><a href="#二级域名设置" class="headerlink" title="二级域名设置"></a>二级域名设置</h2><p>阿里云的域名解析设置页面 —&gt; 点击添加记录 —&gt; 出现弹框<br>    <em>@：直接解析主域名 aliyun.com<br>    **：泛解析，匹配其他所有域名 </em>.aliyun.com<br>    <em>mail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器
    </em>二级域名：如：abc.aliyun.com，填写abc<br>    <em>手机网站：如：m.aliyun.com，填写m
    </em>显性URL/隐形URL：转发的地址必须完成备案且备案接入商为阿里云</p>
<p>TTL：为缓存时间，数值越小，修改记录各地生效时间越快，默认为10分钟</p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">1</i><i class="iconfont iconwenzi" title="字数">150</i><i class="iconfont iconshijian" title="创建时间">2019-08-05 14:13</i></div></article><article><a class="artititle" href="/2019/07/01/npm&amp;&amp;yarn/">npm &amp;&amp; yarn 差异以及常用命令</a><div class="content ellipse"><p></p><p>yarn 从去年vue-cli更新以来一直用，但一直都没认真了解过</p>
<h2 id="yarn-背景介绍"><a href="#yarn-背景介绍" class="headerlink" title="yarn 背景介绍"></a>yarn 背景介绍</h2><p>安装方法 <a href="https://yarn.bootcss.com/docs/install" target="_blank" rel="noopener">三种安装方式</a><br>Yarn 是一个包管理器，代码通过包（package） 或者模块（module）的方式来共享， 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 package.json 。</p>
<h2 id="yarn-npm-差异"><a href="#yarn-npm-差异" class="headerlink" title="yarn npm 差异"></a>yarn npm 差异</h2><ul>
<li>同步安装：npm 是按照队列执行每个 package，Yarn 是同步执行所有任务</li>
<li>离线模式：Yarn可以从缓存中获取以前安装过的安装包，而npm每次都从网络下载</li>
<li>安装版本统一：yarn.lock 文件记录了所有安装模块的版本号，这样使我们每次拉取同一个项目依赖时使用都是一样的版本号，而 npm 需要执行 npm shrinkwrap 才会生成一个锁定文件 npm-shrinkwrap.json</li>
<li>npm 输出内容多长，安装慢就算了还老是失败，相较而言 yarn 真的快多了</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>更多命令 <a href="https://yarn.bootcss.com/docs/cli/" target="_blank" rel="noopener">官网 CLI 命令</a></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>npm 命令</strong></th>
<th style="text-align:center"><strong>yarn 命令</strong></th>
<th style="text-align:center"><strong>命令介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">npm install xxx  <br>  npm i xxx</td>
<td style="text-align:center">yarn</td>
<td style="text-align:center">安装但不写入package.json</td>
</tr>
<tr>
<td style="text-align:center">npm install –save xxx  <br>  npm i -s xxx</td>
<td style="text-align:center">yarn add xxx</td>
<td style="text-align:center">安装xxx模块，并且记录到package.json字段对应的dependency</td>
</tr>
<tr>
<td style="text-align:center">npm install –save-dev xxx  <br>  npm i -D xxx</td>
<td style="text-align:center">yarn add xxx –dev</td>
<td style="text-align:center">安装xxx模块，并且记录到package.jso字段对应的dev-dependency是开发环境必须依赖的模块</td>
</tr>
<tr>
<td style="text-align:center">npm install –global xxx  <br>  npm i -g xxx</td>
<td style="text-align:center">yarn global add xxx</td>
<td style="text-align:center">全局安装xxx模块，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>
</tr>
<tr>
<td style="text-align:center">npm uninstall react –save</td>
<td style="text-align:center">yarn remove taco</td>
<td style="text-align:center">安装并记录package.json中的dependency字段</td>
</tr>
<tr>
<td style="text-align:center">npm update –save</td>
<td style="text-align:center">yarn upgrade</td>
<td style="text-align:center">更新并记录package.json中的dependency字段</td>
</tr>
</tbody>
</table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://yarn.bootcss.com" target="_blank" rel="noopener">官网命令</a><br><a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">知乎文章：npm和yarn的区别，我们该如何选择？</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">1</i><i class="iconfont iconwenzi" title="字数">458</i><i class="iconfont iconshijian" title="创建时间">2019-07-01 17:26</i></div></article><article><a class="artititle" href="/2019/05/14/browser_cache/">理解浏览器缓存机制</a><div class="content ellipse"><p></p><p>有关浏览器缓存的几个疑问</p>
<ul>
<li>浏览器缓存判断流程？</li>
<li>两种分类协商缓存和强制缓存是什么？怎么判断？</li>
<li>缓存的资源放在哪儿？</li>
<li>不同的刷新对缓存的影响？</li>
</ul>
<h2 id="浏览器缓存的流程"><a href="#浏览器缓存的流程" class="headerlink" title="浏览器缓存的流程"></a>浏览器缓存的流程</h2><p>当客户端请求某个资源，首先需要询问浏览器是否存在缓存<br>有以下三种结果：</p>
<ul>
<li>不存在，那么直接向服务器发起请求，就像第一次访问该网站一样</li>
<li>存在，通过Cache-Control、Expires判断后缓存已失效，那么则使用协商缓存，携带该资源缓存标识向服务器发起请求，服务器根据 http header 判断后决定是否使用缓存，若协商缓存失效重新拉取请求结果则状态码为 200 ，若协商缓存生效那么继续使用缓存状态码为 304</li>
<li>存在，通过Cache-Control、Expires判断后未失效，那么继续使用缓存状态码为 304</li>
</ul>
<p>图示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  浏览器发起请求</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">    是否有缓存 ——— 是 ——— 缓存是否失效 ——— 是 ——— 协商缓存 ———— 成功</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        否                    否                  失败          |</span><br><span class="line">        |                     |                    |           |</span><br><span class="line">        |—————————————————————|————————————————————|           |</span><br><span class="line">        |                     |                                |</span><br><span class="line">  向服务器请求资源           读取缓存————————————————————————————|</span><br><span class="line">        |                     |</span><br><span class="line">        |                     |</span><br><span class="line">根据 http header 存缓存        |</span><br><span class="line">        |                     |</span><br><span class="line">        |—————————————————————|</span><br><span class="line">        |</span><br><span class="line">     完成加载</span><br></pre></td></tr></table></figure>
<p>所以有两种缓存类型，强制缓存和协商缓存，优先判断的不需要发 http 请求的是强制缓存<br>当强制缓存无效时才启用协商缓存，协商缓存需要发送 http 请求交由服务器判断，可以应用于一些时常需要动态更新的资源文件</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>浏览器判断强制缓存是否存在和是否失效这两个：Cache-Control、Expires</p>
<ul>
<li>Cache-Control *</li>
</ul>
<p>http/1.1的字段，控制网页缓存的主要规则，取值：</p>
<ul>
<li>public： 所有内容都将被缓存</li>
<li>private：默认值，所有内容只有客户端可以缓存， CDN 等中继缓存服务器不能缓存</li>
<li>no-cache：客户端缓存内容，但由协商缓存决定是否使用缓存</li>
<li>no-store：所有内容都不会被缓存</li>
<li>max-ag=xxx：缓存内容在xxx秒后失效</li>
<li>max-stale=xxx: 指定时间内，即使缓存过时依然使用资源</li>
<li>min-fresh=xxx：缓存的资源至上要保持指定时间的新鲜期</li>
<li>only-if-cached：仅仅返回已经缓存的资源，不访问网络，无缓存返回 504</li>
<li><p>no-transform：强制要求代理服务器不要对资源进行转换，禁止代理服务器对 Content-Type、Content-Encoding, Content-Range 字段进行修改</p>
</li>
<li><p>Expires *</p>
</li>
</ul>
<p>http/1.0 的字段，请求结果缓存到期时间，优先级低于 Cache-Control:max-age<br>由于 Expires 设置的时绝对时间<br>若 Expires 和 Cache-Control:max-age 两者都没出现浏览器默认使用启发式算法：响应头的（ Date - Last - Modified ）<em> 10，也就是（响应时间 - 文件最后修改时间 ）</em> 10</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>Etag / If-None-Match 优先级高于Last-Modified / If-Modfied-Since，同时存在前者生效</p>
<ul>
<li><p>Last-Modified / If-Modified-Since / If-Unmodified-since *</p>
</li>
<li><p>Last-Modified 是服务器响应请求时返回该资源在服务器的最后修改时间</p>
</li>
<li>If-Modified-Since 是客户端再次发起请求时携带上次服务器返回的Last-Modified, 服务器接收到这个时间将与该资源在服务器最后修改的时间进行对比，若服务器修改的时间大于客户端发送的时间，则状态码200重新返回资源，否则返回304表示资源无更新继续使用缓存</li>
<li><p>If-Unmodified-since 同上，资源未修改正常执行更新反之返回412</p>
</li>
<li><p>Etag / If-None-Match *</p>
</li>
<li><p>Etag 是资源唯一标识符，服务器响应请求时返回当前资源的唯一标识符</p>
</li>
<li>If-None-Match 是客户端再次发起该请求时携带上次请求时服务器返回的唯一标识符 Etag，服务器接收到该值会与该资源在服务器的 Etag 值做对比，一致状态码 304 表示无更新继续使用缓存，反之则返回资源文件状态码 200</li>
</ul>
<h2 id="缓存的资源在哪儿？"><a href="#缓存的资源在哪儿？" class="headerlink" title="缓存的资源在哪儿？"></a>缓存的资源在哪儿？</h2><p>浏览器通过 http 请求获取到资源，那么资源会缓存在哪儿</p>
<p>memory cache：内存缓存，会将编译解析的文件，直接存入该进程内存中，占据一定的内存资源，以便下次快速读取，进程关闭即清空</p>
<p>from disk cache：硬盘缓存，盘缓存是将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行i/o操作，然后解析读取，速度比内存缓存慢</p>
<p>浏览器读取缓存时 memory ——&gt; disk ——&gt; 两者都没有便发起网络请求 ——&gt; 获取资源缓存到硬盘和内存</p>
<p>在浏览器中，css 文件会存入硬盘文件中，因为 css 文件通常只在页面渲染时加载一次，<br>而 js 和图片等文件解析执行后直接存入内存缓存中，是因为可能会频繁读取，当刷新页面时只需直接从内存缓存中读取</p>
<h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><ul>
<li>刷新网页，如果缓存没有失效，浏览器直接使用缓存，反之 http 请求数据</li>
<li>手动刷新 / F5，浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新</li>
<li>强制刷新 / Ctrl + F5，浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>其他和缓存相关的 header 头部 *</p>
</li>
<li><p>date 响应生成时间</p>
</li>
<li>age 代理服务器生成，表示代理服务器对于请求资源的已缓存时间, 单位为秒</li>
<li>Pragma：no-cache: http / 1.0 作用和 Cache-Control:no-cache 一样，如果在控制台勾选 Disable cache, 浏览器自动带上该字段</li>
<li><p>vary 缓存版本，可用于区分 pc 和 移动端需要加载的资源</p>
</li>
<li><p>浏览器禁用缓存 *</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache, no-store, must-revalidate"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">浏览器的缓存机制小结</a><br><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a><br>[]</p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">5</i><i class="iconfont iconwenzi" title="字数">1.6k</i><i class="iconfont iconshijian" title="创建时间">2019-05-14 11:44</i></div></article><article><a class="artititle" href="/2019/04/23/canvas-fontparticle/">canvas 文字粒子特效</a><div class="content ellipse"><p></p><p>一个文字粒子效果,折腾了一些时间，纯粹觉得好玩 <a href="https://tong-h.github.io/canvas-store/fontparticle/index.html" target="_blank" rel="noopener">点这里看效果</a></p>
<h2 id="随机初始化部分粒子"><a href="#随机初始化部分粒子" class="headerlink" title="随机初始化部分粒子"></a>随机初始化部分粒子</h2><p>1、首先要明白每个粒子都是一个对象，都有自己的移动轨迹，起点，移动速度，终点</p>
<p>2、粒子活动轨迹：初始化 —- 聚合拼合文字形状 —- 散开 —- 再聚合 —- 散开…</p>
<p>3、我们需要根据动画时间调整粒子移动的速度来安排他们的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.startx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * docsize[<span class="number">0</span>]),   <span class="comment">// 初始起点</span></span><br><span class="line">        <span class="keyword">this</span>.starty = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * docsize[<span class="number">1</span>]),</span><br><span class="line">        <span class="keyword">this</span>.speedx = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed,     <span class="comment">// 移动速度</span></span><br><span class="line">        <span class="keyword">this</span>.speedy = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed, </span><br><span class="line">        <span class="keyword">this</span>.endx = <span class="number">0</span>,                                          <span class="comment">// 终点</span></span><br><span class="line">        <span class="keyword">this</span>.endy = <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>)              <span class="comment">// 粒子颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    endpoint(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.endx = x</span><br><span class="line">        <span class="keyword">this</span>.endy = y</span><br><span class="line">    &#125;</span><br><span class="line">    animal() &#123;</span><br><span class="line">        <span class="keyword">this</span>.startx += <span class="keyword">this</span>.speedx</span><br><span class="line">        <span class="keyword">this</span>.starty += <span class="keyword">this</span>.speedy</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达边界改变粒子运动方向</span></span><br><span class="line">        <span class="keyword">this</span>.speedx *= <span class="keyword">this</span>.startx &gt; docsize[<span class="number">0</span>] || <span class="keyword">this</span>.startx &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">        <span class="keyword">this</span>.speedy *= <span class="keyword">this</span>.starty &gt; docsize[<span class="number">1</span>] || <span class="keyword">this</span>.starty &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整点的移动速度用以聚和拼合文字</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">100</span> || time === <span class="number">600</span> || time === <span class="number">1100</span>) &#123; </span><br><span class="line">            <span class="keyword">this</span>.speedx = (<span class="keyword">this</span>.endx - <span class="keyword">this</span>.startx) / joinspeed</span><br><span class="line">            <span class="keyword">this</span>.speedy = (<span class="keyword">this</span>.endy - <span class="keyword">this</span>.starty) / joinspeed</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达终点后静止不动</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">100</span> + joinspeed || time === <span class="number">600</span> + joinspeed || time === <span class="number">1100</span> + joinspeed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.speedx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">this</span>.speedy = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 散开</span></span><br><span class="line">        <span class="keyword">if</span>(time === <span class="number">300</span> || time === <span class="number">800</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.speedx = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed</span><br><span class="line">            <span class="keyword">this</span>.speedy = (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>) * pointspeed</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maincontent.beginPath()</span><br><span class="line">        maincontent.fillStyle = color[<span class="keyword">this</span>.color]</span><br><span class="line">        maincontent.arc(<span class="keyword">this</span>.startx, <span class="keyword">this</span>.starty, <span class="number">7</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>)</span><br><span class="line">        maincontent.fill()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-canvas-画板生成文字"><a href="#使用-canvas-画板生成文字" class="headerlink" title="使用 canvas 画板生成文字"></a>使用 canvas 画板生成文字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【文字面积，循环时用于判读y轴高度，粒子大小间隔， 文字宽度】</span></span><br><span class="line"><span class="keyword">let</span> [imgdata, cyclic, size, textwith] = [&#123;&#125;, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">textcontext.font = <span class="string">"normal 900 "</span> + fontsize +<span class="string">"px Avenir, Helvetica Neue, Helvetica, Arial, sans-serif"</span></span><br><span class="line">textwith = <span class="built_in">Math</span>.floor(textcontext.measureText(text).width)</span><br><span class="line">textcontext.fillStyle = <span class="string">'#ff0000'</span></span><br><span class="line">textcontext.fillText(text, (docsize[<span class="number">0</span>] - textwith) / <span class="number">2</span>, (docsize[<span class="number">1</span>]) / <span class="number">2</span>)</span><br><span class="line">textwith = ~~ (textwith) * size + size</span><br></pre></td></tr></table></figure>
<h2 id="遍历-imageData-获取文字区域的像素坐标"><a href="#遍历-imageData-获取文字区域的像素坐标" class="headerlink" title="遍历 imageData 获取文字区域的像素坐标"></a>遍历 imageData 获取文字区域的像素坐标</h2><p>不了解 imagedata 怎么用？ 看看这篇文章<a href="https://tong-h.github.io/2019/02/21/canvas-1/#more" target="_blank" rel="noopener">cannvas的imagedata对象</a></p>
<p>获取坐标这里有很多种方法，我看了一些教程好像没人像我这么写，要注意的是</p>
<ul>
<li>imageData 4个元素为一个像素，也就是一个R G B A 值，A 是 alpha 透明度</li>
<li>空白的区域rgba就是 0,0,0,0 , 文字区域就是有颜色的如果你没有设置字体颜色默认是黑色 rgba 就是 0,0,0,255，通过判断第四个元素可以获取文字区域</li>
<li>但是我建议重新设置一个其他的颜色比如红色 255,0,0,255，用第1个和2个数字来判断这样字体边缘会圆滑些，因为在字体边缘黑色和白色的交界处可能有某几个像素不是透明的</li>
<li>每个坐标最后都会生成一个圆，所以这里获取的是圆心的坐标，圆之间还需要留有空隙，所以遍历的时候你要根据你的圆的大小掌握好间隔</li>
<li>获取文字区域粒子数量后需要判断，目前屏幕上现有的粒子是否足够拼合和文字或者是否还需再添加粒子</li>
<li>确定粒子数量后再将文字坐标作为粒子移动终点赋值给粒子</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文字所在区域，尽可能减小面积</span></span><br><span class="line">imgdata = textcontext.getImageData(<span class="number">0</span>,<span class="number">0</span>, textwith, fontsize * <span class="number">2</span>)</span><br><span class="line">textcontext.clearRect(<span class="number">0</span>, <span class="number">0</span>, docsize[<span class="number">0</span>], docsize[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粒子圆心坐标，粒子数组</span></span><br><span class="line"><span class="keyword">let</span> [x, y, len] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历data数据查找文字所在的坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgdata.data.length; i += size * <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (imgdata.data[i] === <span class="number">255</span> &amp;&amp; imgdata.data[i+<span class="number">3</span>] === <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前粒子数量是否能够拼合文字</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; pointarr.length - <span class="number">1</span>) pointarr.push(<span class="keyword">new</span> Point)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每个粒子聚拢的终点</span></span><br><span class="line">        pointarr[len].endpoint(i /<span class="number">4</span> % textwith, cyclic)</span><br><span class="line">        len ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i/<span class="number">4</span> == cyclic * textwith) &#123;</span><br><span class="line">        cyclic += size</span><br><span class="line">        i = textwith * (cyclic<span class="number">-1</span>) * <span class="number">4</span></span><br><span class="line">    &#125;·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pointarr.length - <span class="number">1</span> - len &gt; <span class="number">0</span> ? pointarr.splice(len, pointarr.length - len) : <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h2 id="源码带有详细的注解点这儿"><a href="#源码带有详细的注解点这儿" class="headerlink" title="源码带有详细的注解点这儿"></a>源码带有详细的注解<a href="https://tong-h.github.io/canvas-store/roundPercent/index.html" target="_blank" rel="noopener">点这儿</a></h2><p><a href="https://github.com/Tong-H/canvas-store" target="_blank" rel="noopener">更多效果</a><br>开源不易，觉得还不错点个 start 吧 (´▽`ʃ♡ƪ)</p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">4</i><i class="iconfont iconwenzi" title="字数">982</i><i class="iconfont iconshijian" title="创建时间">2019-04-23 15:43</i></div></article><article><a class="artititle" href="/2019/04/21/webworker/">Web Worker &amp;&amp; postMessage &amp;&amp; onMessage 使用教程</a><div class="content ellipse"><p></p><p>最近使用 iframe 的时候想要获取 iframe 文档信息的时候遇到了跨域问题，最后使用 postmessage 做父子页面通信解决需求也顺便学习了下 webworker 的使用<br>webWoker 使用依赖 postMessage() 和 onMessage(), 所以先说这两个吧</p>
<h1 id="postMessage-amp-amp-onMessage"><a href="#postMessage-amp-amp-onMessage" class="headerlink" title="postMessage &amp;&amp; onMessage"></a>postMessage &amp;&amp; onMessage</h1><ul>
<li>提供网页文档之间互相发送和接收信息的功能，可用于解决跨域访问的问题</li>
<li>会在所有页面脚本执行完毕之后(包括方法之后或者之前设置的timeout 事件)再执行</li>
<li>挂载于window对象上</li>
</ul>
<h2 id="postMessage-语法：-otherWindow-postMessage-message-targetOrigin-transfer"><a href="#postMessage-语法：-otherWindow-postMessage-message-targetOrigin-transfer" class="headerlink" title="postMessage 语法： otherWindow.postMessage(message, targetOrigin, [transfer]);"></a>postMessage 语法： otherWindow.postMessage(message, targetOrigin, [transfer]);</h2><p>&emsp;&emsp;message: 发送的数据，不限类型，因为他自己会序列化<br>&emsp;&emsp;targetOrigin：通过窗口的origin属性指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI<br>&emsp;&emsp;transfer：可选参数；一个 Transferable 对象([什么是Transferable[(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable))，和message" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable))，和message</a> 同时传递的,对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</p>
<h2 id="onMessage-语法："><a href="#onMessage-语法：" class="headerlink" title="onMessage 语法："></a>onMessage 语法：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; ... &#125;)</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取到的-event-对象包含"><a href="#获取到的-event-对象包含" class="headerlink" title="获取到的 event 对象包含"></a>获取到的 event 对象包含</h2><p>&emsp;&emsp;data：接收的数据对象，对应 postMessage 的 message 参数<br>&emsp;&emsp;origin：消息发送方窗口的 origin，字符串由 协议、“://“、域名、“ : 端口号”拼接而成<br>&emsp;&emsp;source：对发送消息的窗口对象的引用</p>
<h2 id="举个小栗子"><a href="#举个小栗子" class="headerlink" title="举个小栗子"></a>举个小栗子</h2><ul>
<li><p>父页面向子页面传值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 在 iframe 加载完毕后，获取 iframe 的 window 对象，调用 postMessage 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="actionscript">        frame.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            frame.contentWindow.postMessage(&#123; name: <span class="string">'a page'</span> &#125;,<span class="string">'*'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子页面监听 message 事件设置回调打印 event</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>b page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (event) =&gt; <span class="built_in">console</span>.log(<span class="string">'this b page'</span>, event), <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子页面向父页面传值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父页面监听 message 事件设置回调打印 event</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"b.html"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, (event) =&gt; <span class="built_in">console</span>.log(<span class="string">'this a page'</span>, event), <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 使用 parent 获取 window 对象，调用 postMessage 方法</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>b page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(parent)</span></span><br><span class="line"><span class="actionscript">        parent.postMessage( &#123;name: <span class="string">'b page'</span>&#125;, <span class="string">'*'</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Workers"><a href="#Workers" class="headerlink" title="Workers"></a>Workers</h1><ul>
<li>我自己感觉很多比较麻烦耗内存的js逻辑操作都可以放在worker里，比如轮询服务器状态或者一些很耗时量很大的数据操作用</li>
<li>让脚本在浏览器后台线程中运行</li>
<li>在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" target="_blank" rel="noopener">window对象下可用的方法</a></li>
<li>worker 中也能再创建 worker</li>
<li>由于安全限制 Worker 不能读取本地文件，所以脚本必须来自网络，读取本地文件会报错 “Uncaught SecurityError: Failed to create a worker: script at ‘(path)/worker.js’ cannot be accessed from origin ‘null’.”</li>
<li>关于<a href="https://caniuse.com/#search=webworker" target="_blank" rel="noopener">兼容性</a></li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在使用 worker 的 js文件里<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Worker() 指定脚本 url 创建一个新的 worker</span></span><br><span class="line"><span class="comment">// 参数就是 Worker 线程所要执行的任务</span></span><br><span class="line"><span class="comment">// Worker 使用 postMessage 和 onMessage 进行通信</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">"worker.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 postMessage() 和 onMessage() 发送和接收数据</span></span><br><span class="line">myWorker.postMessage(<span class="string">"request"</span>);</span><br></pre></td></tr></table></figure></p>
<p>在 worker.js文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息响应</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  <span class="built_in">console</span>.log(self)</span><br><span class="line">  <span class="comment">// 消息回传</span></span><br><span class="line">  postMessage(workerResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关闭-错误-加载脚本"><a href="#关闭-错误-加载脚本" class="headerlink" title="关闭/错误/加载脚本"></a>关闭/错误/加载脚本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 文件中，强制终止</span></span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 worker 线程中，自己关闭</span></span><br><span class="line">self.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 错误代理</span></span><br><span class="line">worker.onerror(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送的数据无法序列化成字符串时，会触发这个事件</span></span><br><span class="line">Worker.onmessageerror(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 使用 importScripts() 加载脚本，可以加载多个</span></span><br><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'script2.js'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h2><p>如果你现在没有条件加载网络上的文件，可以使用 URL.createObjectURL 方法建立缓存 URL<br>可以试着运行一下面两个页面感受一下</p>
<p>可以运行一下这个页面，一个普通的 for 循环，因为数字太大运行时会有明显的卡顿<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Web worker<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span>(<span class="keyword">var</span> num=<span class="number">99</span>;num&lt;<span class="number">1000000000</span>;num++)&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"numshow"</span>).innerHTML += event.data+<span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"numshow"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个可以使用 URL.createObjectURL 方法建立缓存 URL<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Web worker<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">5</span>);</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">"("</span> + webWorker.toString() + <span class="string">")()"</span>], &#123;type: <span class="string">'text/javascript'</span>&#125;)));</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        worker.onmessage= <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 数据打印</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"numshow"</span>).innerHTML += event.data+<span class="string">"&lt;br/&gt;"</span>; </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 向 worker 线程发送数据</span></span></span><br><span class="line"><span class="actionscript">            event.data === <span class="number">1</span> ? worker.postMessage(<span class="string">'num'</span>):<span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;; </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">webWorker</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// worker 对象 self</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(self)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 接收来自主线程的数据</span></span></span><br><span class="line"><span class="actionscript">        self.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> num = <span class="number">1</span>; num &lt; <span class="number">1000000000</span>; num++) &#123; </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 当 num === 200的时候关闭 worker 线程</span></span></span><br><span class="line"><span class="actionscript">            num === <span class="number">200</span> ? (postMessage(<span class="string">"worker关闭"</span>), close()) : postMessage(num**<span class="number">2</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"numshow"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>postMessage：MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a><br>webworker：MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a><br>阮一峰：<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">6</i><i class="iconfont iconwenzi" title="字数">1.3k</i><i class="iconfont iconshijian" title="创建时间">2019-04-21 16:19</i></div></article><article><a class="artititle" href="/2019/03/25/ts-1/">typescript 学习之基础篇</a><div class="content ellipse"><p></p><p>vue-cli已经内置了 TypeScript 工具支持，在 Vue  (3.x) 中也计划了相当多的 TypeScript 支持改进，很多大佬以及用过的人也都在推荐入坑，而且目前也比较成熟，资源也很丰富，值得入坑</p>
<h1 id="typescript"><a href="#typescript" class="headerlink" title="? typescript"></a>? typescript</h1><p>官方介绍 TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上<br>我的理解是 TypeScript扩展了JavaScript的语法，为 js 增加了类型机制，引入类，接口，枚举，泛型，方法重载等一系列的概念和方法，丰富了js的使用，而且和 VScode 搭配写起来是真的舒服</p>
<p>全局安装：npm install -g typescript<br>编译命令：tsc hello.ts</p>
<p>TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀<br>在报错的时候终止 js 文件的生成，在 tsconfig.json 中配置 noEmitOnError </p>
<h1 id="原始数据类型声明"><a href="#原始数据类型声明" class="headerlink" title="原始数据类型声明"></a>原始数据类型声明</h1><p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>在ts中变量声明，变量或者参数都必须要声明其类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> createdByBoolean: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">'string'</span></span><br><span class="line"><span class="comment">// ` 用来定义 ES6 中的模板字符串，$&#123;expr&#125; 用来在模板字符串中嵌入表达式</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.I'll be <span class="subst">$&#123;myAge + 1&#125;</span> years old next month.`</span>; </span><br><span class="line"></span><br><span class="line">Null 和 Undefined 和 <span class="built_in">void</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>; <span class="comment">// void只能赋值为 undefined 和 null</span></span><br></pre></td></tr></table></figure></p>
<h1 id="内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量"><a href="#内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量" class="headerlink" title="内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量"></a>内置对象：指根据标准在全局作用域（Global）上存在的对象，这些对象可作为类型赋值给变量</h1><p>这些内置对象的定义文件可以在<a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>查找</p>
<p>ECMAScript 标准的内置对象比如Boolean、Date、RegExp等，更多内置对象<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN</a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure></p>
<p>DOM 和 BOM 的内置对象比如Document、HTMLElement、Event、NodeList等<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="赋值多个类型"><a href="#赋值多个类型" class="headerlink" title="赋值多个类型"></a>赋值多个类型</h1><h2 id="任意类型-any：表示允许赋值为任意类型，且能在赋值过程中改变类型"><a href="#任意类型-any：表示允许赋值为任意类型，且能在赋值过程中改变类型" class="headerlink" title="任意类型 any：表示允许赋值为任意类型，且能在赋值过程中改变类型"></a>任意类型 <code>any</code>：表示允许赋值为任意类型，且能在赋值过程中改变类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>变量声明，赋值但未指定其类型，TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'7'</span> <span class="comment">// TypeScript会推断为string类型</span></span><br><span class="line">a = <span class="number">7</span>  <span class="comment">// 这个赋值会导致报错</span></span><br></pre></td></tr></table></figure></p>
<p>变量声明，未赋值未指定其类型，会被推断成 <code>any</code>类型而完全不被类型检查<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a    <span class="comment">// any 类型</span></span><br><span class="line">a = <span class="string">'7'</span></span><br><span class="line">a = <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h2 id="联合类型：可以指定多种类型，可赋值为其中一种，使用-分隔每个类型"><a href="#联合类型：可以指定多种类型，可赋值为其中一种，使用-分隔每个类型" class="headerlink" title="联合类型：可以指定多种类型，可赋值为其中一种，使用 |` 分隔每个类型"></a>联合类型：可以指定多种类型，可赋值为其中一种，使用 |` 分隔每个类型</h2><p>示例<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 指定类型为 string 和 number</span></span><br><span class="line">a = <span class="string">'7'</span>; <span class="comment">// 类型推断为 number</span></span><br><span class="line">a = <span class="number">7</span>; <span class="comment">// 类型推断为 string</span></span><br><span class="line">a = <span class="literal">true</span>; <span class="comment">// 类型推断为 boolean 报错</span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用接口定义对象类型"><a href="#使用接口定义对象类型" class="headerlink" title="使用接口定义对象类型"></a>使用接口定义对象类型</h1><ul>
<li>接口使用<code>interface</code> 关键字定义</li>
<li>接口首字母大写</li>
<li><p>对象类型的属性分为确定属性、只读属性、可选属性、任意属性</p>
</li>
<li><p>确定属性：也就是固定的属性，接口有 变量声明时就必须有,</p>
</li>
<li>只读属性：<code>readonly</code> 关键字定义，第一次赋值后无法更改，是在接口创建后只能<strong> 第一次给对象赋值的时候为只读属性赋值 </strong>， 而不是第一次给只读属性赋值</li>
<li>可选属性：属性名 + ?，表示该属性可以不存在</li>
<li>任意属性：<code>[propName: string]: any;</code> 冒号前半部分表示任意属性取 <code>string类型</code>的值，后半部分是类型的子集</li>
<li>一旦定义了任意属性，那么另外三种属性的类型都必须是它的类型的子集，可将任意属性的类型的子集定义为 <code>联合类型</code> 或者 <code>any 类型</code></li>
</ul>
<p>一个栗子：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;                <span class="comment">// 只读属性</span></span><br><span class="line">    a: <span class="built_in">string</span>;                                  <span class="comment">// 确定属性</span></span><br><span class="line">    b?: <span class="built_in">number</span>;                             <span class="comment">// 可选属性</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;     <span class="comment">// 任意属性</span></span><br><span class="line">&#125;       <span class="comment">// 会报错，任意属性类型的子集为 string，而 b 和 id 的类型为number，不属于任意属性类型的子集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: Person = &#123; <span class="comment">// 报错 没有给只读属性 id 赋值</span></span><br><span class="line">    a: <span class="string">'123'</span>,</span><br><span class="line">    b: <span class="number">456</span>,</span><br><span class="line">    c: <span class="string">'789'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.id = <span class="number">89757</span>; <span class="comment">// 报错 因为这不是对象第一次赋值</span></span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    a: <span class="built_in">string</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj: Person = &#123; </span><br><span class="line">    id: <span class="number">8</span>,</span><br><span class="line">    a: <span class="string">'123'</span>,</span><br><span class="line">    b: <span class="number">456</span>,</span><br><span class="line">    c: <span class="string">'789'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="数组类型：类型-方括号，-数组的每一项元素都必须符合类型"><a href="#数组类型：类型-方括号，-数组的每一项元素都必须符合类型" class="headerlink" title="数组类型：类型 + 方括号，  数组的每一项元素都必须符合类型 "></a>数组类型：类型 + 方括号， <strong> 数组的每一项元素都必须符合类型 </strong></h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// 数组元素类型只能是 number</span></span><br><span class="line"><span class="keyword">let</span> c: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// 联合类型和数组的结合</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">3</span>, &#123;a: <span class="number">1</span>&#125;]; <span class="comment">// any 类型</span></span><br></pre></td></tr></table></figure>
<p>接口定义<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure></p>
<h1 id="函数的类型定义"><a href="#函数的类型定义" class="headerlink" title="函数的类型定义"></a>函数的类型定义</h1><ul>
<li>函数的输入和输出为必须，且都必须定义类型</li>
<li>可选参数：参数名 + ? ，可选参数必须在必填参数后面</li>
<li>默认参数：设置了默认值的参数会被 TypeScript 识别为可选参数，但不受 “可选参数必须在必填参数后面” 这个限制</li>
<li>剩余参数：指除了 必选参数 和 可选参数 以外的参数，使用 … 获取剩余参数为数组格式需定义类型，剩余参数必须排在参数末尾</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小括号里面是输入的参数包括对参数类型的定义，花括号前面的number是输出的类型</span></span><br><span class="line"><span class="comment">// y 设置了默认参数，为可选参数</span></span><br><span class="line"><span class="comment">// z为可选参数</span></span><br><span class="line"><span class="comment">// rest 为剩余参数，any 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = 6, z?: <span class="built_in">number</span>, ...rest: <span class="built_in">any</span>[]</span>): <span class="title">number</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 4,5 为剩余参数</span></span><br></pre></td></tr></table></figure>
<p>函数表达式:  <code>=&gt;</code>不是箭头函数，他表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="类型断言：-lt-类型-gt-值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型"><a href="#类型断言：-lt-类型-gt-值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型" class="headerlink" title="类型断言：&lt;类型&gt;值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型"></a>类型断言：&lt;类型&gt;值，当需要在还不确定类型的时候就访问其中一个类型的属性或方法时我们可以手动指定这个值的类型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="comment">// 当然这地方你也可以将他定义为any类型</span></span><br><span class="line">    <span class="keyword">return</span> something.length;  <span class="comment">// 报错 类型“number”上不存在属性“length”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">使用类型断言</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`ts</span></span><br><span class="line"><span class="string">function getLength(something: string): number &#123;</span></span><br><span class="line"><span class="string">    return (&lt;string&gt;something).length;  // 将参数定义为string后再去访问他的length</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="类型别名：使用type关键字给一个类型起个新名字，常用于联合类型"><a href="#类型别名：使用type关键字给一个类型起个新名字，常用于联合类型" class="headerlink" title="类型别名：使用type关键字给一个类型起个新名字，常用于联合类型"></a>类型别名：使用<code>type</code>关键字给一个类型起个新名字，常用于联合类型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个"><a href="#字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个" class="headerlink" title="字符串字面量类型：使用type关键字约束取值只能是某几个字符串中的一个"></a>字符串字面量类型：使用<code>type</code>关键字约束取值只能是某几个字符串中的一个</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  </span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，dbclick不在EventNames中</span></span><br></pre></td></tr></table></figure>
<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><ul>
<li>声明文件以<code>.d.ts</code>为后缀</li>
<li><code>@type</code>引入第三方声明文件：npm install @types/jquery –save-dev，可以统一管理第三方库的声明文件只需在插件名称前加上<code>@type</code></li>
<li>declare var/let/const 声明全局变量，一般全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var / let</li>
<li>declare function 声明全局方法</li>
<li>declare class 声明全局类</li>
<li>declare enum 声明全局枚举类型</li>
<li>declare namespace 声明全局对象（含有子属性）</li>
<li>interface 和 type 声明全局类型</li>
</ul>
<h1 id="元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象"><a href="#元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象" class="headerlink" title="元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象"></a>元祖：数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'first'</span>, <span class="number">15</span>];  <span class="comment">// 定义，定义时也可不赋值</span></span><br><span class="line">tup = [<span class="string">'second'</span>, <span class="number">30</span>]                    <span class="comment">// 直接赋值</span></span><br><span class="line">tup[<span class="number">0</span>] = <span class="string">'second'</span>                       <span class="comment">// 通过索引赋值</span></span><br><span class="line">tup = [<span class="string">'second'</span>]                         <span class="comment">// 报错，需要提供所有元组类型中指定的项</span></span><br><span class="line">tup.push(<span class="number">20</span>);                             <span class="comment">// 添加越界元素</span></span><br><span class="line">tup.push(<span class="literal">true</span>);                          <span class="comment">// 报错，越界元素类型会被限制为元组中每个类型的联合类型</span></span><br></pre></td></tr></table></figure>
<h1 id="枚举：enum关键字用于限定取值在一定范围内"><a href="#枚举：enum关键字用于限定取值在一定范围内" class="headerlink" title="枚举：enum关键字用于限定取值在一定范围内"></a>枚举：<code>enum</code>关键字用于限定取值在一定范围内</h1><p>普通枚举<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举成员会被赋值为从 0 开始递增的数字</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">"Sun"</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Sun === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">"Sun"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们手动赋值时，未被赋值的枚举项会接着上一个枚举项 +1 递增，手动赋值的枚举项也可以为小数或负数</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon = <span class="number">8</span>, Tue, Wed, Thu = <span class="number">5.5</span>, Fri, Sat&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Days.Mon === <span class="number">8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Wed === <span class="number">10</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days.Fri === <span class="number">6.5</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动赋值的枚举项可以不是数字，需要使用类型断言来让 tsc 无视类型检查，非数字枚举项后面不能跟未手动赋值的枚举项，因为无法获得初始值</span></span><br><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon, Tue, Wed, Thu, Fri, Sat = &lt;<span class="built_in">any</span>&gt;<span class="string">"S"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当枚举项是计算所得项时，后面不能跟是未手动赋值的项</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue = <span class="string">"blue"</span>.length&#125;;</span><br></pre></td></tr></table></figure></p>
<p>常数枚举：<code>const enum</code>关键字定义，常数枚举会在编译阶段被删除，并且不能包含计算成员<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;Up, Down, Left, Right&#125;</span><br></pre></td></tr></table></figure></p>
<p>外部枚举：是指使用<code>declare enum</code> 定义的枚举类型，只会用于编译时的检查，编译结果中会被删除<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;Up, Down, Left, Right&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="类：基于es6-class-和-es7-新提案的基础上添加了三种访问修饰符"><a href="#类：基于es6-class-和-es7-新提案的基础上添加了三种访问修饰符" class="headerlink" title="类：基于es6 class 和 es7 新提案的基础上添加了三种访问修饰符"></a>类：基于es6 class 和 es7 新提案的基础上添加了三种访问修饰符</h1><p><em>public：修饰的属性或方法是公有的，任何地方都能被访问
</em>private：修饰的属性或方法是私有的，不能在声明它的类的外部访问<br>*protected：和 private 类似，区别是它在子类中允许被访问 </p>
<h1 id="泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性"><a href="#泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性" class="headerlink" title="泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性"></a>泛型：定义函数、接口或类的时候，使用的时候再指定类型的一种特性</h1><p>vs code 提示：Experimental support for decorators is a feature that is subject to change in a future release. Set the ‘experimentalDecorators’ option to remove this </p>
<p>在 tsconfig.json 文件中修改规则 experimentalDecorators</p>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p>官网 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">http://www.typescriptlang.org/</a><br>对新手比官网更友好些 <a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" target="_blank" rel="noopener">https://ts.xcatliu.com/introduction/what-is-typescript.html</a><br>vue + ts项目实战 <a href="https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-14</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">10</i><i class="iconfont iconwenzi" title="字数">2.6k</i><i class="iconfont iconshijian" title="创建时间">2019-03-25 11:40</i></div></article><article><a class="artititle" href="/2019/03/18/canvas-3/">canvas性能优化篇</a><div class="content ellipse"><p></p><p>看了很多大佬的文章，自己也对项目做了一些优化，其实有很多地方平常码代码的时候稍微注意一下就能节约很多性能开销</p>
<h1 id="1-离屏渲染"><a href="#1-离屏渲染" class="headerlink" title="1.离屏渲染"></a>1.离屏渲染</h1><p>在离屏canvas上预渲染相似的图形或重复的对象，通俗的解释是将离屏canvas当成预渲染，在离屏canvas上绘制好一整块图形，绘制好后在放到视图canvas中，适合每一帧画图运算复杂的图形</p>
<p>比如你想把一张图片放到canvas上，使用drawImage()方法，有三种写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将image放到目标canvas指定位置</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy); </span><br><span class="line"><span class="comment">// 将image放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 将image裁剪之后放到目标canvas指定位置，指定宽高渲染</span></span><br><span class="line"><span class="keyword">void</span> ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure></p>
<p>第一种只是把图片原样放到canvas里，第二章指定宽高就意味着放大或者缩小图片后再放进去，带三种是裁剪后再放大或者缩小放到canvas中，这三种写法操作依次增加，性能开销也是依次提高<br>而离屏渲染就可以让我们先把图片裁剪成想要的尺寸内容保存起来，绘制的时候就可以使用第一种写法简单的把图片放进去就完了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在离屏 canvas 上绘制</span></span><br><span class="line"><span class="keyword">var</span> offscreencanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="comment">// 宽高赋值为想要的图片尺寸</span></span><br><span class="line">offscreencanvas.width = dWidth;</span><br><span class="line">offscreencanvas.height = dHeight;</span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">offscreencanvas.getContext(<span class="string">'2d'</span>).drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// 在视图canvas中绘制</span></span><br><span class="line">viewcontext.drawImage(canvas, x, y);</span><br></pre></td></tr></table></figure>
<h1 id="2-分层画布"><a href="#2-分层画布" class="headerlink" title="2.分层画布"></a>2.分层画布</h1><p>多个相互重叠的canvas根据变化程度分开渲染，越复杂的场景越适合</p>
<p>比如一个简单的游戏场景，游戏背景始终不变或者变化次数较少但是人物游戏的主体是一直在根据玩家的指挥不停的改变，</p>
<p>场景：最近写的一个画板，比如这样一个简单的画圆，可以看到有原来的绘画的痕迹，那就要 渲染没画圆之前的画布 -&gt; 再画圆，鼠标移动的时候不断的执行这个渲染过程</p>
<p><img src="/2019/03/18/canvas-3/canvas-3.gif" alt="示例画圆gif"></p>
<p>这个时候就可以使用分层画布，画画在一个上层canvas上，原来绘画痕迹在下层canvas上，那么画圆的过程就是清空 -&gt; 画圆，画好之后再放到下层canvas上，这样就不需要去渲染之前的画布，就能节约性能开销</p>
<h1 id="3-一次性绘制"><a href="#3-一次性绘制" class="headerlink" title="3.一次性绘制"></a>3.一次性绘制</h1><p>绘制操作的性能开销较高，可以创建一个包含所有线条的路径，然后通过单个绘制路径调用进行绘制</p>
<p>从这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变成这样，在绘制复杂路径时，最好将所有点都放入路径中，而不是分别呈现各个片段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = points[i];</span><br><span class="line">  <span class="keyword">var</span> p2 = points[i+<span class="number">1</span>];</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">&#125;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p>
<h1 id="4-使用requestAnimationFrame执行动画"><a href="#4-使用requestAnimationFrame执行动画" class="headerlink" title="4.使用requestAnimationFrame执行动画"></a>4.使用requestAnimationFrame执行动画</h1><p>canvas动画的本质是不断地擦除和重绘，再结合一些时间控制的方法达到动画的目的<br>显示器刷新频率是60Hz，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms<br>而requestAnimationFrame就是根据显示器刷新频率来的，这是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能，如果页面不是激活状态下的话，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命</p>
<p>详细看<a href="https://tong-h.github.io/2019/03/07/canvas-2/#more" target="_blank" rel="noopener">这儿</a></p>
<h1 id="5-清空画布"><a href="#5-清空画布" class="headerlink" title="5.清空画布"></a>5.清空画布</h1><p>三种方法性能，性能依次提高<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect()</span><br><span class="line">context.clearRect()</span><br><span class="line">canvas.width = canvas.width; <span class="comment">// 一种画布专用的技巧</span></span><br></pre></td></tr></table></figure></p>
<h1 id="6-减少调用canvas的api"><a href="#6-减少调用canvas的api" class="headerlink" title="6.减少调用canvas的api"></a>6.减少调用canvas的api</h1><p>比如像背景可以使用css属性设置或者img标签加一些定位什么的</p>
<p>画布的缩放可以使用CSS transforms，不要将小画布放大，而是去将大画布缩小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scaleX = canvas.width / <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">var</span> scaleY = canvas.height / <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scaleToFit = <span class="built_in">Math</span>.min(scaleX, scaleY);</span><br><span class="line"><span class="keyword">var</span> scaleToCover = <span class="built_in">Math</span>.max(scaleX, scaleY);</span><br><span class="line"></span><br><span class="line">stage.style.transformOrigin = <span class="string">'0 0'</span>; <span class="comment">//scale from top left</span></span><br><span class="line">stage.style.transform = <span class="string">'scale('</span> + scaleToFit + <span class="string">')'</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h1><ul>
<li>尽可能使用计算代替canvas渲染，通常情况下，渲染比计算的开销大很多（3~4 个量级）</li>
<li>减少改变 context 的状态以及不要赋一些乱七八糟类型的值，比如人家要一个number你要给一个string，浏览器会用一些额外时间来处理这些非法输入，可能会造成三四倍的时间开销</li>
<li>避免使用浮点数坐标，使用非整数的坐标绘制内容，系统会自动使用抗锯齿功能，尝试对线条进行平滑处理，这又是一种性能消耗。可以调用 Math.round 四舍五入取整</li>
<li>减少使用 shadowBlur 效果，和很多图像环境渲染一样，阴影渲染的性能开销通常比较高</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a><br><a href="https://www.html5rocks.com/zh/tutorials/canvas/performance/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/canvas/performance/</a><br><a href="http://taobaofed.org/blog/2016/02/22/canvas-performance/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/02/22/canvas-performance/</a></p>
<p></p></div><div class="meta"><i class="iconfont iconweibiaoti--" title="阅读时长">5</i><i class="iconfont iconwenzi" title="字数">1.3k</i><i class="iconfont iconshijian" title="创建时间">2019-03-18 11:40</i></div></article><div id="paginator"><span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><a class="page-number" href="/archives/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/5/">5</a><a class="extend next" rel="next" href="/archives/page/2/">Next</a></div></div><script>document.getElementById('arshow').onclick = function() {
    document.getElementById('list_archives').style = 'opacity: 0;display: none'
    document.getElementById('normalposts').style = 'opacity: 0;display: block'
    setTimeout(() => {
        document.getElementById('normalposts').style.opacity = '1'                        
    }, 100);
}
document.getElementById('poshow').onclick = function() {
    document.getElementById('normalposts').style = 'opacity: 0;display: none'
    document.getElementById('list_archives').style = 'opacity: 1;display: block'
}</script></div><link rel="stylesheet" href="/css/partial/footer.css"><div class="footer"><p><span>Copyright © 2017 - 2019  </span><a href="http://www.beian.miit.gov.cn/">蜀ICP备19024124号</a></p><p>Powered by <a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a> Theme by <a href="https://github.com/Tong-H/hexo-theme-energy" target="_blank">ENERGY</a></p><p><i class="iconfont iconchakan"><span>本站总访问量</span><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span></i><i class="iconfont iconabout"><span>本站访客数</span><span id="busuanzi_container_site_uv">  <span id="busuanzi_value_site_uv"></span> </span></i></p></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?a4d08c5088ca0d4b18c14260c9ca89a1";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})()</script></body></html>